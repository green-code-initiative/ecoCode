<!-- Generated using CodeNarc 2.2.0 -->
<rules>
  <!-- basic rules -->

  <rule>
    <key>org.codenarc.rule.basic.AssertWithinFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assert Within Finally Block]]></name>
    <internalKey><![CDATA[AssertWithinFinallyBlock]]></internalKey>
    <description><![CDATA[<p>Checks for <em>assert</em> statements within a <em>finally</em> block. An <em>assert</em> can throw an exception,
hiding the original exception, if there is one.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    int myMethod(int count) {
        try {
            doSomething()
        } finally {
            assert count * 0        // violation
        }
    }
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.AssignmentInConditionalRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assignment In Conditional]]></name>
    <internalKey><![CDATA[AssignmentInConditional]]></internalKey>
    <description><![CDATA[<p>An assignment operator (=) was used in a conditional test. This is usually a typo, and the comparison operator (==) was intended.</p>
<p>Example of violations:</p>
<pre><code>    if ((value = true)) {
        // should be ==
    }

    while (value = true) {
        // should be ==
    }

    (value = true) ? x : y
    (value = true) ?: x

    // the following code has no violations
    if (value == true) {
    }

    value == true ? x : y
    value == true ?: x
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.BigDecimalInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Big Decimal Instantiation]]></name>
    <internalKey><![CDATA[BigDecimalInstantiation]]></internalKey>
    <description><![CDATA[<p>Checks for calls to the <code>java.math.BigDecimal</code> constructors that take a <code>double</code> value as
the first parameter. As described in the <code>BigDecimal</code> javadoc, the results from these constructors
can be somewhat unpredictable, and their use is generally not recommended. This is because some numbers,
such as 0.1, cannot be represented exactly as a <code>double</code>.</p>
<p>For instance, executing <code>println new BigDecimal(0.1)</code> prints out
<code>0.1000000000000000055511151231257827021181583404541015625</code>.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def b1 = new BigDecimal(0.1)               // violation
    def b2 = new java.math.BigDecimal(23.45d)  // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.BitwiseOperatorInConditionalRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Bitwise Operator In Conditional]]></name>
    <internalKey><![CDATA[BitwiseOperatorInConditional]]></internalKey>
    <description><![CDATA[<p>Checks for bitwise operations in conditionals. For instance, the condition <code>if (a | b)</code> is almost
always a mistake and should be <code>if (a || b)</code>. If you need to do a bitwise operation then it is
best practice to extract a temp variable.</p>
<p>Example of violations:</p>
<pre><code>    if (a | b) { }
    if (a &amp; b) { }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.BooleanGetBooleanRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Boolean Get Boolean]]></name>
    <internalKey><![CDATA[BooleanGetBoolean]]></internalKey>
    <description><![CDATA[<p>This rule catches usages of java.lang.Boolean.getBoolean(String) which reads a boolean from the System properties. It is often mistakenly used to attempt to read user input or parse a String into a boolean. It is a poor piece of API to use; replace it with System.properties['propÍ„'].</p>
<p>Example of violations:</p>
<pre><code>    // produces violation
    Boolean.getBoolean(value)

    // zero or two parameters is OK, must be different method
    Boolean.getBoolean(value, 1)
    Boolean.getBoolean()
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.basic.BrokenNullCheckRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Broken Null Check]]></name>
    <internalKey><![CDATA[BrokenNullCheck]]></internalKey>
    <description><![CDATA[<p>Looks for faulty checks for <em>null</em> that can cause a <code>NullPointerException</code>.</p>
<p>Examples:</p>
<pre><code>    if (name != null || name.length * 0) { }            // violation
    if (name != null || name.length) { }                // violation
    while (record == null &amp;&amp; record.id * 10) { }        // violation
    if (record == null &amp;&amp; record.id &amp;&amp; doStuff()) { }   // violation
    def isNotValid = record == null &amp;&amp; record.id * 10   // violation
    return record == null &amp;&amp; !record.id                 // violation

    if (name != null || name.size() * 0) { }            // violation
    if (string == null &amp;&amp; string.equals(&quot;&quot;)) { }        // violation
    def isValid = name != null || name.size() * 0       // violation
    return name != null || !name.size()                 // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.BrokenOddnessCheckRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Broken Oddness Check]]></name>
    <internalKey><![CDATA[BrokenOddnessCheck]]></internalKey>
    <description><![CDATA[<p>The code uses <code>x % 2 == 1</code> to check to see if a value is odd, but this won't work for negative numbers
(e.g., <code>(-5) % 2 == -1)</code>. If this code is intending to check for oddness, consider using <code>x &amp; 1 == 1</code>,
or <code> x % 2 != 0</code>.</p>
<p>Examples:</p>
<pre><code>    if (x % 2 == 1) { }             // violation
    if (method() % 2 == 1) { }      // violation

    if (x &amp; 1 == 1) { }             // OK
    if (x % 2 != 0) { }             // OK
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ClassForNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class For Name]]></name>
    <internalKey><![CDATA[ClassForName]]></internalKey>
    <description><![CDATA[<p>Using <code>Class.forName(...)</code> is a common way to add dynamic behavior to a system. However, using this method can cause
resource leaks because the classes can be pinned in memory for long periods of time. If you're forced to do dynamic
class loading then use ClassLoader.loadClass instead. All variations of the <code>Class.forName(...)</code> method suffer from the
same problem.</p>
<p>For more information see these links:</p>
<ul>
<li>
<p><a href="http://blog.bjhargrave.com/2007/09/classforname-caches-defined-class-in.html">http://blog.bjhargrave.com/2007/09/classforname-caches-defined-class-in.html</a></p>
</li>
<li>
<p><a href="http://www.osgi.org/blog/2011/05/what-you-should-know-about-class.html">http://www.osgi.org/blog/2011/05/what-you-should-know-about-class.html</a></p>
</li>
</ul>
<p>Example of violations:</p>
<pre><code>    Class.forName('SomeClassName')
    Class.forName(aClassName, true, aClassLoader)
</code></pre>
]]></description>
    <tag>leak</tag>
    <tag>owasp-a1</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ComparisonOfTwoConstantsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Comparison Of Two Constants]]></name>
    <internalKey><![CDATA[ComparisonOfTwoConstants]]></internalKey>
    <description><![CDATA[<p>Checks for expressions where a <em>comparison operator</em> or <code>equals()</code> or <code>compareTo()</code> is used to
compare two constants to each other or two literals that contain only constant values.</p>
<p>Here are examples of code that produces a violation:</p>
<pre><code>    23 == 67                    // violation
    Boolean.FALSE != false      // violation
    23 * 88                     // violation
    0.17 *= 0.99                // violation
    &quot;abc&quot; * &quot;ddd&quot;               // violation
    [Boolean.FALSE] *= [27]     // violation
    [a:1] *=* [a:2]             // violation

    [1,2].equals([3,4])                                     // violation
    [a:123, b:true].equals(['a':222, b:Boolean.FALSE])      // violation

    [a:123, b:456].compareTo([a:222, b:567]                 // violation
    [a:false, b:true].compareTo(['a':34.5, b:Boolean.TRUE]  // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ComparisonWithSelfRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Comparison With Self]]></name>
    <internalKey><![CDATA[ComparisonWithSelf]]></internalKey>
    <description><![CDATA[<p>Checks for expressions where a <em>comparison operator</em> or <code>equals()</code> or <code>compareTo()</code> is used to compare a
variable to itself, e.g.: <code>x == x, x != x, x \*=\* x, x \* x, x \*= x, x.equals(x) or x.compareTo(x)</code>, where
<code>x</code> is a variable.</p>
<p>Here are examples of code that produces a violation:</p>
<pre><code>    if (x == x) { }                 // violation
    if (x != x) { }                 // violation
    while (x * x) { }               // violation
    if (x *= x) { }                 // violation
    while (x * x) { }               // violation
    if (x *= x) { }                 // violation
    def c = (x *=* x) { }           // violation
    println isReady = x.equals(x)   // violation
    println x.compareTo(x)          // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ConstantAssertExpressionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Constant Assert Expression]]></name>
    <internalKey><![CDATA[ConstantAssertExpression]]></internalKey>
    <description><![CDATA[<p>Checks for <em>assert</em> statements with a constant value for the <em>assert</em> boolean expression, such as
<code>true</code>, <code>false</code>, <code>null</code>, or a literal constant value. These <em>assert</em> statements
will always pass or always fail, depending on the constant/literal value. Examples of violations include:</p>
<pre><code>    assert true
    assert false, &quot;assertion message&quot;
    assert Boolean.TRUE
    assert Boolean.FALSE
    assert null
    assert 0
    assert 99.7
    assert &quot;&quot;
    assert &quot;abc&quot;
    assert [:]
    assert [a:123, b:456]
    assert [a, b, c]
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ConstantIfExpressionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constant If Expression]]></name>
    <internalKey><![CDATA[ConstantIfExpression]]></internalKey>
    <description><![CDATA[<p>Checks for <em>if</em> statements with a constant value for the <em>if</em> boolean expression, such as
<code>true</code>, <code>false</code>, <code>null</code>, or a literal constant value. These <em>if</em> statements
can be simplified or avoided altogether. Examples of violations include:</p>
<pre><code>    if (true) { .. }
    if (false) { .. }
    if (Boolean.TRUE) { .. }
    if (Boolean.FALSE) { .. }
    if (null) { .. }
    if (0) { .. }
    if (99.7) { .. }
    if (&quot;&quot;) { .. }
    if (&quot;abc&quot;) { .. }
    if ([:]) { .. }
    if ([a:123, b:456]) { .. }
    if ([a, b, c]) { .. }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ConstantTernaryExpressionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constant Ternary Expression]]></name>
    <internalKey><![CDATA[ConstantTernaryExpression]]></internalKey>
    <description><![CDATA[<p>Checks for ternary expressions with a constant value for the boolean expression, such as
<code>true</code>, <code>false</code>, <code>null</code>, or a literal constant value. Examples of violations include:</p>
<pre><code>    true ? x : y
    false ? x : y
    Boolean.TRUE ? x : y
    Boolean.FALSE ? x : y
    null ? x : y
    0 ? x : y
    99.7 ? x : y
    &quot;&quot; ? x : y
    &quot;abc&quot; ? x : y
    [:] ? x : y
    [a:123, b:456] ? x : y
    [a, b, c] ? x : y
</code></pre>
<p>The rule also checks for the same types of constant values for the boolean expressions within the &quot;short&quot;
ternary expressions, also known as the &quot;Elvis&quot; operator, e.g.:</p>
<pre><code>    true ?: y
    null ?: y
    99.7 ?: y
    &quot;abc&quot; ?: y
    [:] ?: y
    [a, b, c] ?: y
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.DeadCodeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Dead Code]]></name>
    <internalKey><![CDATA[DeadCode]]></internalKey>
    <description><![CDATA[<p>Dead code appears after a <code>return</code> statement or an exception is thrown. If code appears after one of these
statements then it will never be executed and can be safely deleted.</p>
]]></description>
    <tag>unused</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.DoubleNegativeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Double Negative]]></name>
    <internalKey><![CDATA[DoubleNegative]]></internalKey>
    <description><![CDATA[<p>There is no point in using a double negative, it is always positive. For instance <code>!!x</code> can always be
simplified to <code>x</code>. And <code>!(!x)</code> can as well.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.DuplicateCaseStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Case Statement]]></name>
    <internalKey><![CDATA[DuplicateCaseStatement]]></internalKey>
    <description><![CDATA[<p>Check for duplicate <code>case</code> statements in a <code>switch</code> block, such as two equal
integers or strings. Here are some examples of code that produces violations:</p>
<pre><code>    switch( 0 ) {
        case 1: break;
        case 2: break;
        case 2: break;          // violation
    }

    switch( &quot;test&quot; ) {
        case &quot;$a&quot;: break;
        case &quot;$a&quot;: break;       // ok; only flags constant values (not GStrings)
        case &quot;ab&quot;: break;
        case &quot;ab&quot;: break;       // violation
        case &quot;abc&quot;: break;
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.DuplicateMapKeyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Map Key]]></name>
    <internalKey><![CDATA[DuplicateMapKey]]></internalKey>
    <description><![CDATA[<p>A <em>Map</em> literal is created with duplicated key. The map entry will be overwritten.</p>
<p>Example of violations:</p>
<pre><code>    def var1 = [a:1, a:2, b:3]        //violation
    def var2 = [1:1, 1:2, 2:3]        //violation
    def var3 = [&quot;a&quot;:1, &quot;a&quot;:2, &quot;b&quot;:3]  //violation

    // these are OK
    def var4 = [a:1, b:1, c:1]
    def var5 = [1:1, 2:1, 3:1]
    def var6 = [&quot;a&quot;:1, &quot;b&quot;:1, &quot;c&quot;:1]
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.DuplicateSetValueRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Set Value]]></name>
    <internalKey><![CDATA[DuplicateSetValue]]></internalKey>
    <description><![CDATA[<p>A <em>Set</em> literal is created with duplicate constant value. A set cannot contain two elements with the same value.</p>
<p>Example of violations:</p>
<pre><code>    def a = [1, 2, 2, 4] as Set
    def b = [1, 2, 2, 4] as HashSet
    def c = [1, 2, 2, 4] as SortedSet
    def d = [1, 2, 2, 4] as FooSet
    def e = ['1', '2', '2', '4'] as Set
    def f = ['1', '2', '2', '4'] as HashSet
    def g = ['1', '2', '2', '4'] as SortedSet
    def h = ['1', '2', '2', '4'] as FooSet

    // these are OK
    def a = [1, 2, 3, 4] as Set
    def b = ['1', '2', '3', '4'] as Set
    def c = [1, '1'] as Set
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyCatchBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Catch Block]]></name>
    <internalKey><![CDATA[EmptyCatchBlock]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>catch</em> blocks. In most cases, exceptions should not be caught and ignored (swallowed).</p>
<p>The rule has a property named <code>ignoreRegex</code> that defaults to the value 'ignore|ignored'. If the name of the exception
matches this regex then no violations are produced.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        try {
            doSomething
        } catch(MyException e) {                //violation
            // should do something here
        }
    }

    def myMethod() {
        try {
            doSomething
        } catch(MyException ignored) {
            //no violations because the parameter name is ignored
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
    <param>
      <key>ignoreRegex</key>
      <description><![CDATA[Regular expression - exception parameter names matching this regular expression are ignored and no violations are produced.]]></description>
      <defaultValue>'ignore|ignored'</defaultValue>
    </param>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Class]]></name>
    <internalKey><![CDATA[EmptyClass]]></internalKey>
    <description><![CDATA[<p>Reports classes without methods, fields or properties. Why would you need a class like this?</p>
<p>This rule ignores interfaces, abstract classes, enums, anonymous inner classes, subclasses (extends), and classes with annotations.</p>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyElseBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Else Block]]></name>
    <internalKey><![CDATA[EmptyElseBlock]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>else</em> blocks. Empty <em>else</em> blocks are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        if (x==23) {
            println 'ok'
        } else {
            // empty
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Finally Block]]></name>
    <internalKey><![CDATA[EmptyFinallyBlock]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>finally</em> blocks. Empty <em>finally</em> blocks are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        try {
            doSomething()
        } finally {
            // empty
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyForStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty For Statement]]></name>
    <internalKey><![CDATA[EmptyForStatement]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>for</em> blocks. Empty <em>for</em> statements are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        for (int i=0; i * 23; i++) {
            // empty
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyIfStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty If Statement]]></name>
    <internalKey><![CDATA[EmptyIfStatement]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>if</em> statements. Empty <em>if</em> statements are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        if (x==23) {
            // empty
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyInstanceInitializerRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Instance Initializer]]></name>
    <internalKey><![CDATA[EmptyInstanceInitializer]]></internalKey>
    <description><![CDATA[<p>An empty class instance initializer was found. It is safe to remove it. Example:</p>
<pre><code>    class MyClass {
        { }     // empty instance initializer, not a closure
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Method]]></name>
    <internalKey><![CDATA[EmptyMethod]]></internalKey>
    <description><![CDATA[<p>A method was found without an implementation. If the method is overriding or implementing a parent method,
then mark it with the <code>@Override</code> annotation. This rule should not be used with Java 5 code because you cannot
put <code>@Override</code> on a method implementing an interface. Use with Java 6 and higher.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {

        // violation, empty method
        public void method1() {}

        // violation, empty method
        def method2() {}

        // OK because of @Override
        @Override
        public void method3() {}
    }

    abstract class MyBaseClass {
        // OK, handled by EmptyMethodInAbstractClass Rule
        public void method() {}
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyStaticInitializerRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Static Initializer]]></name>
    <internalKey><![CDATA[EmptyStaticInitializer]]></internalKey>
    <description><![CDATA[<p>An empty static initializer was found. It is safe to remove it. Example:</p>
<pre><code>    class MyClass {
        static { }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptySwitchStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Switch Statement]]></name>
    <internalKey><![CDATA[EmptySwitchStatement]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>switch</em> statements. Empty <em>switch</em> statements are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        switch(myVariable) {
            // empty
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptySynchronizedStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Synchronized Statement]]></name>
    <internalKey><![CDATA[EmptySynchronizedStatement]]></internalKey>
    <description><![CDATA[<p>~</p>
<p>Checks for empty <em>synchronized</em> statements. Empty <em>synchronized</em> statements are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    class MyClass {
        def myMethod() {
            synchronized(lock) {
            }
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyTryBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Try Block]]></name>
    <internalKey><![CDATA[EmptyTryBlock]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>try</em> blocks. Empty <em>try</em> blocks are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        try {
            // empty
        } catch(MyException e) {
            e.printStackTrace()
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyWhileStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty While Statement]]></name>
    <internalKey><![CDATA[EmptyWhileStatement]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>while</em> statements. Empty <em>while</em> statements are confusing and serve no purpose.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        while (!stopped) {
            // empty
        }
    }
</code></pre>
]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EqualsAndHashCodeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Equals And Hash Code]]></name>
    <internalKey><![CDATA[EqualsAndHashCode]]></internalKey>
    <description><![CDATA[<p>Checks that if either the <code>boolean equals(Object)</code> or the <code>int hashCode()</code> methods
are overridden within a class, then both must be overridden.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    class MyClass {
        boolean equals(Object object) {
            // do something
        }
    }
</code></pre>
<p>And so does this:</p>
<pre><code>    class MyClass {
        int hashCode() {
            return 0
        }
    }
</code></pre>
]]></description>
    <tag>pitfall</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.EqualsOverloadedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Equals Overloaded]]></name>
    <internalKey><![CDATA[EqualsOverloaded]]></internalKey>
    <description><![CDATA[<p>The class has an <code>equals</code> method, but the parameter of the method is not of type <code>Object</code>.
It is not overriding <code>equals</code> but instead overloading it.</p>
<p>Example of violations:</p>
<pre><code>    class Object1 {
        //parameter should be Object not String
        boolean equals(String other) { true }
    }

    class Object2 {
        // Overloading equals() with 2 parameters is just mean
        boolean equals(Object other, String other2) { true }
    }

    class Object3 {
        // a no-arg equals()? What is this supposed to do?
        boolean equals() { true }
    }


    // all of these are OK and do not cause violations
    class Object4 {
        boolean equals(Object other) { true }
    }

    @SuppressWarnings('EqualsOverloaded')
    class Object5 {
        boolean equals(String other) { true }
    }

    class Object6 {
        boolean equals(java.lang.Object other) { true }
    }

    class Object7 {
        boolean equals(other) { true }
    }
</code></pre>
]]></description>
    <tag>pitfall</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.basic.ExplicitGarbageCollectionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Garbage Collection]]></name>
    <internalKey><![CDATA[ExplicitGarbageCollection]]></internalKey>
    <description><![CDATA[<p>Calls to <code>System.gc()</code>, <code>Runtime.getRuntime().gc()</code>, and <code>System.runFinalization()</code> are not advised. Code should have
the same behavior whether the garbage collection is disabled using the option <code>-Xdisableexplicitgc</code> or not. Moreover,
&quot;modern&quot; JVMs do a very good job handling garbage collections. If memory usage issues unrelated to memory leaks develop
within an application, it should be dealt with JVM options rather than within the code itself.</p>
]]></description>
    <tag>unpredictable</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ForLoopShouldBeWhileLoopRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[For Loop Should Be While Loop]]></name>
    <internalKey><![CDATA[ForLoopShouldBeWhileLoop]]></internalKey>
    <description><![CDATA[<p>A <code>for</code> loop without an init and update statement can be simplified to a <code>while</code> loop.</p>
<p>Example of violations:</p>
<pre><code>    int i = 0;
    for(; i * 5;) {     // Violation
        println i++
    }

    // These are OK
    for(i in [1,2])         // OK
       println i

    for(int i = 0; i*5;)    // OK
        println i++

    int i = 0;
    for(; i * 5; i++)       // OK
        println i

    for (Plan p : plans) {  // OK
        println &quot;Plan=$p&quot;
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.HardCodedWindowsFileSeparatorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Hard Coded Windows File Separator]]></name>
    <internalKey><![CDATA[HardCodedWindowsFileSeparator]]></internalKey>
    <description><![CDATA[<p>This rule finds usages of a Windows file separator within the constructor call of a File object. It is better to use
the Unix file separator or use the File.separator constant.</p>
<p>Example of violations:</p>
<pre><code>   new File('.\\foo\\')
   new File('c:\\dir')
   new File('../foo\\')
</code></pre>
]]></description>
    <tag>pitfall</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.HardCodedWindowsRootDirectoryRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Hard Coded Windows Root Directory]]></name>
    <internalKey><![CDATA[HardCodedWindowsRootDirectory]]></internalKey>
    <description><![CDATA[<p>This rule find cases where a File object is constructed with a windows-based path. This is not portable across operating systems
or different machines, and using  the File.listRoots() method is a better alternative.</p>
<p>Example of violations:</p>
<pre><code>   new File('c:\\')
   new File('c:\\dir')
   new File('E:\\dir')
</code></pre>
]]></description>
    <tag>pitfall</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.IntegerGetIntegerRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Integer Get Integer]]></name>
    <internalKey><![CDATA[IntegerGetInteger]]></internalKey>
    <description><![CDATA[<p>This rule catches usages of java.lang.Integer.getInteger(String, ...) which reads an Integer from the System properties.
It is often mistakenly used to attempt to read user input or parse a String into an Integer.
It is a poor piece of API to use; replace it with System.properties['prop'].</p>
<p>Example of violations:</p>
<pre><code>    // violations
    Integer.getInteger(value)
    Integer.getInteger(value, radix)

    // zero or more than 2 parameters is OK, must be different method
    Integer.getInteger()
    Integer.getInteger(value, radix, locale)
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.basic.MultipleUnaryOperatorsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Multiple Unary Operators]]></name>
    <internalKey><![CDATA[MultipleUnaryOperators]]></internalKey>
    <description><![CDATA[<p>Checks for multiple consecutive unary operators. These are confusing, and are likely typos and bugs.</p>
<p>Example of violations:</p>
<pre><code>    int z = ~~2             // violation
    boolean b = !!true      // violation
    boolean c = !!!false    // 2 violations
    int j = -~7             // violation
    int k = +~8             // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ParameterAssignmentInFilterClosureRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Parameter Assignment In Filter Closure]]></name>
    <internalKey><![CDATA[ParameterAssignmentInFilterClosure]]></internalKey>
    <description><![CDATA[<p>&lt;Since CodeNarc 2.1.0&gt;</p>
<p>An assignment operator was used on a parameter, or a property or subproperty of the parameter, in a filtering or searching closure. This is usually a typo, and the comparison operator (==) was intended.</p>
<p>This rule will check the following filter methods: <code>find</code>, <code>findAll</code>, <code>findIndexOf</code>, <code>every</code>, <code>any</code>, <code>filter</code>, <code>grep</code>, <code>dropWhile</code> and <code>takeWhile</code>.</p>
<p>Example of violations:</p>
<pre><code>    List someList = [1,2,3]
    someList.find {it == 2}
    someList.find {it = 2}                  // violation, this actually finds 1 instead.
    someList.find { int integer -&gt;
        integer == 2
    }
    someList.find { int integer -&gt;
        integer = 2                         // violation, this actually finds 1 instead.
    }
    someList.takeWhile { it.name = 42 }     // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.RandomDoubleCoercedToZeroRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Random Double Coerced To Zero]]></name>
    <internalKey><![CDATA[RandomDoubleCoercedToZero]]></internalKey>
    <description><![CDATA[<p>The Math.random() method returns a double result greater than or equal to 0.0 and less than 1.0. If you coerce this
result into an Integer, Long, int, or long then it is coerced to zero. Casting the result to int, or assigning it to an int
field is probably a bug.</p>
<p>Example of violations:</p>
<pre><code>    (int) Math.random()
    (Integer) Math.random()
    int x = Math.random()
    Integer y = Math.random()
    int m() { Math.random() }
    Integer m() { Math.random() }
    (Math.random()) as int
    (Math.random()) as Integer
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.RemoveAllOnSelfRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Remove All On Self]]></name>
    <internalKey><![CDATA[RemoveAllOnSelf]]></internalKey>
    <description><![CDATA[<p>Don't use <code>removeAll</code> to clear a collection. If you want to remove all elements from a
collection <code>c</code>, use <code>c.clear</code>, not <code>c.removeAll(c)</code>. Calling <code>c.removeAll(c)</code>
to clear a collection is less clear, susceptible to errors from typos, less efficient and
for some collections, might throw a <code>ConcurrentModificationException</code>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ReturnFromFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Return From Finally Block]]></name>
    <internalKey><![CDATA[ReturnFromFinallyBlock]]></internalKey>
    <description><![CDATA[<p>Checks for a return from within a <em>finally</em> block. Returning from a <em>finally</em> block is confusing and
can hide the original exception.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    int myMethod() {
        try {
            doSomething()
            return 0
        } catch(Exception e) {
            return -1
        } finally {
            return 99               // violation
        }
    }
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ThrowExceptionFromFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Exception From Finally Block]]></name>
    <internalKey><![CDATA[ThrowExceptionFromFinallyBlock]]></internalKey>
    <description><![CDATA[<p>Checks for throwing an exception from within a <em>finally</em> block. Throwing an exception from a
<em>finally</em> block is confusing and can hide the original exception.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    int myMethod() {
        try {
            doSomething()
            throw new Exception()
        } finally {
            println 'finally'
            throw new Exception()   // violation
        }
    }
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- braces rules -->

  <rule>
    <key>org.codenarc.rule.braces.ElseBlockBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Else Block Braces]]></name>
    <internalKey><![CDATA[ElseBlockBraces]]></internalKey>
    <description><![CDATA[<p>Checks that <em>else</em> blocks use braces, even for a single statement.</p>
<p>By default, braces are not required for an <em>else</em> if it is followed immediately by an <em>if</em>.
Set the <em>bracesRequiredForElseIf</em> property to true to require braces is that situation as well.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>bracesRequiredForElseIf</key>
      <description><![CDATA[Set to "true" to require braces for an else block followed immediately by an if statement.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.braces.ForStatementBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[For Statement Braces]]></name>
    <internalKey><![CDATA[ForStatementBraces]]></internalKey>
    <description><![CDATA[<p>Checks that <em>for</em> statements use braces, even for a single statement.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.braces.IfStatementBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[If Statement Braces]]></name>
    <internalKey><![CDATA[IfStatementBraces]]></internalKey>
    <description><![CDATA[<p>Checks that <em>if</em> statements use braces, even for a single statement.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.braces.WhileStatementBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[While Statement Braces]]></name>
    <internalKey><![CDATA[WhileStatementBraces]]></internalKey>
    <description><![CDATA[<p>Checks that while statements use braces, even for a single statement.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- comments rules -->

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.comments.ClassJavadocRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Javadoc]]></name>
    <internalKey><![CDATA[ClassJavadoc]]></internalKey>
    <description><![CDATA[<p>Makes sure each class and interface definition is preceded by javadoc. Enum definitions are not checked, due to strange
behavior in the Groovy AST. By default, only the main class in a file is checked for Javadoc. The main class is defined as
the class that has the same name as the source file, for instance MyClass is the main class in MyClass.groovy but the class
MyOtherClass defined in the same source file is not the main class. To check all the classes in the file set the rule
property <code>applyToNonMainClasses</code> to true.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocConsecutiveEmptyLinesRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Consecutive Empty Lines]]></name>
    <internalKey><![CDATA[JavadocConsecutiveEmptyLines]]></internalKey>
    <description><![CDATA[<p>Checks for javadoc comments with more than one consecutive empty line.</p>
<p>Known limitation: Only the first occurrence of consecutive empty lines within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Description
     *
     *                                                                          // violation
     * @param startIndex - the starting index
     * @return the full count
     * @throws RuntimeException if you are not pure of spirit
     *
     * NOTE: Only the first occurrence of consecutive empty lines
     *       within a javadoc comment is found, so the following
     *       lines are not flagged as violations!!!
     *
     *
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyAuthorTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Author Tag]]></name>
    <internalKey><![CDATA[JavadocEmptyAuthorTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty @author tags within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @author within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex - the starting index
     * @return the count
     * @author                                             // violation
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyExceptionTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Exception Tag]]></name>
    <internalKey><![CDATA[JavadocEmptyExceptionTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty @exception tag within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @exception within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex - the starting index
     * @return the count
     * @exception                                           // violation
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyFirstLineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty First Line]]></name>
    <internalKey><![CDATA[JavadocEmptyFirstLine]]></internalKey>
    <description><![CDATA[<p>Check for javadoc comments with an empty top line.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     *                                                      // violation
     * Sample class
     *
     * @author Some Developer
     */
    class MyClass {

        /**
         *                                                  // violation
         * Return the calculated count of some stuff,
         * starting with the specified startIndex.
         *
         * @param startIndex - the starting index
         * @return the full count
         * @throws RuntimeException when the Singularity occurs
         */
        int countThings(int startIndex) {
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyLastLineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Last Line]]></name>
    <internalKey><![CDATA[JavadocEmptyLastLine]]></internalKey>
    <description><![CDATA[<p>Check for javadoc comments with an empty line at the bottom.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Sample class
     *
     * @author Some Developer
     *                                                      // violation
     */
    class MyClass {

        /**
         * Return the calculated count of some stuff,
         * starting with the specified startIndex.
         *
         * @param startIndex - the starting index
         * @return the full count
         * @throws RuntimeException when life finds a way
         *                                                  // violation
         */
        int countThings(int startIndex) {
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyParamTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Param Tag]]></name>
    <internalKey><![CDATA[JavadocEmptyParamTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>@param</em> tags within javadoc</p>
<p>Known limitation: Only the first occurrence of an empty @param within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param                                               // violation
     * @return the full count
     * @throws RuntimeException upon self-reflection
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyReturnTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Return Tag]]></name>
    <internalKey><![CDATA[JavadocEmptyReturnTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty @return tags within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @return within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex - the starting index
     * @return                                  // violation
     * @throws RuntimeException if you don't say &quot;please&quot;
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptySeeTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty See Tag]]></name>
    <internalKey><![CDATA[JavadocEmptySeeTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty <em>@see</em> tags within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @see within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Sample class
     *
     * @see                                                         // violation
     */
    class MyClass {

        /**
         * Return the calculated count of some stuff,
         * starting with the specified startIndex.
         *
         * @param startIndex - the starting index
         * @return the full count
         * @throws RuntimeException when you least expect it
         *     @see                                                 // violation
         *
         * NOTE: Only the first occurrence of an empty @see tag
         *       within a javadoc comment is found, so the
         *       following line is not flagged as a violation!!!
         * @see
         */
        int countThings(int startIndex) { }

        /**
         *@see                                                      // violation
         */
        String name = 'joe'
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptySinceTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Since Tag]]></name>
    <internalKey><![CDATA[JavadocEmptySinceTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty @since tags within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @since within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex - the starting index
     * @return the count
     * @since                                          // violation
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyThrowsTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Throws Tag]]></name>
    <internalKey><![CDATA[JavadocEmptyThrowsTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty @throws tag within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @throws within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex - the starting index
     * @return the count
     * @throws                                          // violation
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocEmptyVersionTagRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Empty Version Tag]]></name>
    <internalKey><![CDATA[JavadocEmptyVersionTag]]></internalKey>
    <description><![CDATA[<p>Checks for empty @version tags within javadoc.</p>
<p>Known limitation: Only the first occurrence of an empty @version within a javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex - the starting index
     * @return the count
     * @version                                          // violation
     */
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.4 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocMissingExceptionDescriptionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Missing Exception Description]]></name>
    <internalKey><![CDATA[JavadocMissingExceptionDescription]]></internalKey>
    <description><![CDATA[<p>Checks for missing description within @exception javadoc tags.</p>
<p>Known limitation: Only the first occurrence of a missing description for an @exception javadoc comment is found.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex the starting index; must be *= 0
     * @return the full count
     * @exception RuntimeException                   // violation
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.4 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocMissingParamDescriptionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Missing Param Description]]></name>
    <internalKey><![CDATA[JavadocMissingParamDescription]]></internalKey>
    <description><![CDATA[<p>Checks for missing description within Javadoc @param tags.</p>
<p>Known limitation: Only the first occurrence of a missing description for a @param javadoc comment is found</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex                           // violation
     * @return the full count
     * @throws RuntimeException if it senses fear
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 1.4 -->
  <rule>
    <key>org.codenarc.rule.comments.JavadocMissingThrowsDescriptionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Javadoc Missing Throws Description]]></name>
    <internalKey><![CDATA[JavadocMissingThrowsDescription]]></internalKey>
    <description><![CDATA[<p>Checks for missing description within Javadoc @throws tags.</p>
<p>Known limitation: Only the first occurrence of a missing description for a @throws javadoc comment is found</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations:</p>
<pre><code>    /**
     * Return the calculated count of some stuff.
     *
     * @param startIndex the starting index; must be *= 0
     * @return the full count
     * @throws RuntimeException                   // violation
     */
    int countThings(int startIndex) { }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowMultiline</key>
      <description><![CDATA[Set to "true" to allow the tag content (name, description, etc.) to start on the following line. If false, that content must start on the same line as the tag.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- concurrency rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.BusyWaitRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Busy Wait]]></name>
    <internalKey><![CDATA[BusyWait]]></internalKey>
    <description><![CDATA[<p>Busy waiting (forcing a <code>Thread.sleep()</code> while waiting on a condition) should be avoided. Prefer using the gate and
barrier objects in the <code>java.util.concurrent</code> package.</p>
<p>Example of violations:</p>
<pre><code>    while (x) { Thread.sleep(1000) }
    while (x) { Thread.sleep(1000) { /* interruption handler */} }
    for (int x = 10; x; x--) {
        sleep(1000)     // sleep is added to Object in Groovy
    }

    // here is the proper way to wait:
    countDownLatch.await()

    // this is weird code to write, but does not cause a violation
    for (def x : collections) {
        sleep(1000)
    }

    while (x) {
        // you should use a lock here, but technically you are
        // not just busy waiting because you are doing other work
        doSomething()
        sleep(1000)
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.DoubleCheckedLockingRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Double Checked Locking]]></name>
    <internalKey><![CDATA[DoubleCheckedLocking]]></internalKey>
    <description><![CDATA[<p>This rule detects double checked locking, where a 'lock hint' is tested for null before initializing an object within
a synchronized block. Double checked locking does not guarantee correctness and is an anti-pattern.</p>
<p>A full explanation of why double checked locking is broken in Java is available on Wikipedia:
<a href="http://en.wikipedia.org/wiki/Double-checked_locking">http://en.wikipedia.org/wiki/Double-checked_locking</a></p>
<p>Example of violations:</p>
<pre><code>    if (object == null) {
        synchronized(this) {
            if (object == null) {
                // createObject() could be called twice depending
                // on the Thread Scheduler.
                object = createObject()
            }
        }
    }

    // there are several idioms to fix this problem.
    def result = object;
    if (result == null) {
        synchronized(this) {
            result = object;
            if (result == null)
                object = result = createObject()
        }
    }

    // and a better solution for a singleton:
    class myClass  {
        private static class ObjectHolder {
           public static Object object = createObject()
        }
        public static Object getObject() {
            return ObjectHolder.object;
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.InconsistentPropertyLockingRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Inconsistent Property Locking]]></name>
    <internalKey><![CDATA[InconsistentPropertyLocking]]></internalKey>
    <description><![CDATA[<p>Class contains similarly-named get and set methods where one method of the pair is marked either @WithReadLock
or @WithWriteLock and the other is not locked at all. This may result in incorrect behavior at runtime, as
callers of the get and set methods will not necessarily lock correctly and my see an inconsistent state for the object.
The get and set method should both be guarded by @WithReadLock/@WithWriteLock or neither should be guarded.</p>
<p>Example of violations:</p>
<pre><code>    class Person {
        String name
        Date birthday
        boolean deceased
        boolean parent

        @WithWriteLock setName(String name) {
            this.name = name
        }
        // violation, get method should be locked
        String getName() {
            name
        }

        // violation, set method should be locked
        void setBirthday(Date birthday) {
            this.birthday = birthday
        }

        @WithReadLock String getBirthday() {
            birthday
        }

        // violation, set method should be locked
        void setDeceased(boolean deceased) {
            this.deceased = deceased
        }

        @WithReadLock boolean isDeceased() {
            deceased
        }

        @WithWriteLock void setParent(boolean parent) {
            this.parent = parent
        }

        // violation, get method should be locked
        boolean isParent() {
            parent
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.InconsistentPropertySynchronizationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Inconsistent Property Synchronization]]></name>
    <internalKey><![CDATA[InconsistentPropertySynchronization]]></internalKey>
    <description><![CDATA[<p>Class contains similarly-named get and set methods where the set method is synchronized and the get method is not,
or the get method is synchronized and the set method is not. This may result in incorrect behavior at runtime, as
callers of the get and set methods will not necessarily see a consistent state for the object. The get and set method
should both be synchronized or neither should be synchronized.</p>
<p>Example of violations:</p>
<pre><code>    class Person {
        String name
        Date birthday
        boolean deceased
        boolean parent
        int weight

        synchronized setName(String name) {
            this.name = name
        }
        // violation, get method should be synchronized
        String getName() {
            name
        }

        // violation, set method should be synchronized
        void setBirthday(Date birthday) {
            this.birthday = birthday
        }

        synchronized String getBirthday() {
            birthday
        }

        // violation, set method should be synchronized
        void setDeceased(boolean deceased) {
            this.deceased = deceased
        }

        synchronized boolean isDeceased() {
            deceased
        }

        synchronized void setParent(boolean parent) {
            this.parent = parent
        }

        // violation, get method should be synchronized
        boolean isParent() {
            parent
        }

        // violation get method should be synchronized
        @groovy.transform.Synchronized
        void setWeight(int value) {
            weight = value
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.NestedSynchronizationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Nested Synchronization]]></name>
    <internalKey><![CDATA[NestedSynchronization]]></internalKey>
    <description><![CDATA[<p>This rule reports occurrences of nested <code>synchronized</code> statements.</p>
<p>Nested <code>synchronized</code> statements should be avoided. Nested <code>synchronized</code> statements
are either useless (if the lock objects are identical) or prone to deadlock.</p>
<p>Note that a <em>closure</em> or an <em>anonymous inner class</em> carries its own context (scope).
A <code>synchronized</code> statement within a <em>closure</em> or an <em>anonymous inner class</em> defined
within an outer <code>synchronized</code> statement does not cause a violation (though nested
<code>synchronized</code> statements within either of those will).</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def myMethod() {
        synchronized(this) {
            // do something ...
            synchronized(this) {
                // do something else ...
            }
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticCalendarFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Calendar Field]]></name>
    <internalKey><![CDATA[StaticCalendarField]]></internalKey>
    <description><![CDATA[<p><code>Calendar</code> objects should not be used as <code>static</code> fields. Calendars are inherently unsafe for multithreaded use. Sharing a
single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.
Under 1.4 problems seem to surface less often than under Java 5 where you will probably see random <code>ArrayIndexOutOfBoundsException</code>
or <code>IndexOutOfBoundsException</code> in <code>sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()</code>. You may also experience
serialization problems. Using an instance field or a <code>ThreadLocal</code> is recommended.</p>
<p>For more information on this see Sun Bug #6231579 and Sun Bug #6178997.</p>
<p>Examples:</p>
<pre><code>    // Violations
    class MyClass {
        static Calendar calendar1
        static java.util.Calendar calendar2

        static final CAL1 = Calendar.getInstance()
        static final CAL2 = Calendar.getInstance(Locale.FRANCE)
        static def cal3 = Calendar.getInstance(timezone)
        static Object cal4 = Calendar.getInstance(timezone, locale)
    }

    // These usages are OK
    class MyCorrectClass {
        private final Calendar calendar1
        static ThreadLocal*Calendar* calendar2
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticConnectionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Connection]]></name>
    <internalKey><![CDATA[StaticConnection]]></internalKey>
    <description><![CDATA[<p>Creates violations when a <code>java.sql.Connection</code> object is used as a <code>static</code> field. Database connections
stored in <code>static</code> fields will be shared between threads, which is unsafe and can lead to race conditions.</p>
<p>A transactional resource object such as database connection can only be associated with one transaction at a time.
For this reason, a connection should not be shared between threads and should not be stored in a static field.
See Section 4.2.3 of the <em>J2EE Specification</em> for more details.</p>
<p>References:</p>
<ul>
<li>Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) APP3630.1 CAT II</li>
<li>Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 362, CWE ID 567</li>
<li>Standards Mapping - SANS Top 25 2009 - (SANS 2009) Insecure Interaction - CWE ID 362</li>
<li>Standards Mapping - SANS Top 25 2010 - (SANS 2010) Insecure Interaction - CWE ID 362</li>
<li>Java 2 Platform Enterprise Edition Specification, v1.4 Sun Microsystems</li>
</ul>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticDateFormatFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Date Format Field]]></name>
    <internalKey><![CDATA[StaticDateFormatField]]></internalKey>
    <description><![CDATA[<p><code>DateFormat</code> objects should not be used as <code>static</code> fields. DateFormats are inherently unsafe for multithreaded use. Sharing a
single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.
Under 1.4 problems seem to surface less often than under Java 5 where you will probably see random <code>ArrayIndexOutOfBoundsException</code>
or <code>IndexOutOfBoundsException</code> in <code>sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()</code>. You may also experience
serialization problems. Using an instance field or a <code>ThreadLocal</code> is recommended.</p>
<p>For more information on this see Sun Bug #6231579 and Sun Bug #6178997.</p>
<p>Examples:</p>
<pre><code>    // Violations
    class MyClass {
        static DateFormat dateFormat1
        static java.text.DateFormat dateFormat2

        static final DATE1 = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE)
        static final def DATE2 = DateFormat.getDateInstance(DateFormat.LONG)
        static Object date3 = DateFormat.getDateInstance()

        static final DATETIME1 = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT, Locale.FRANCE)
        static final def DATETIME2 = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT)
        static final Object DATETIME3 = DateFormat.getDateTimeInstance()

        static final TIME1 = DateFormat.getTimeInstance(DateFormat.LONG, Locale.FRANCE)
        static final def TIME2 = DateFormat.getTimeInstance(DateFormat.LONG)
        static final Object TIME3 = DateFormat.getTimeInstance()
    }

    // These usages are OK
    class MyCorrectClass {
        private DateFormat calendar1
        static ThreadLocal*DateFormat* calendar2
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticMatcherFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Matcher Field]]></name>
    <internalKey><![CDATA[StaticMatcherField]]></internalKey>
    <description><![CDATA[<p>Matcher objects should not be used as static fields. Calendars are inherently unsafe for multithreaded use. Sharing a single
instance across thread boundaries without proper synchronization will result in erratic behavior of the application.</p>
<p>Example of violations:</p>
<pre><code>    // two violations
    class MyClass {
      static Matcher matcher1
      static java.util.regex.Matcher matcher2
    }

    // these usages are OK
    class MyCorrectClass {
      private Matcher matcher1
      static ThreadLocal*Matcher* matcher2
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticSimpleDateFormatFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Simple Date Format Field]]></name>
    <internalKey><![CDATA[StaticSimpleDateFormatField]]></internalKey>
    <description><![CDATA[<p><code>SimpleDateFormat</code> objects should not be used as <code>static</code> fields. SimpleDateFormats are inherently unsafe for
multithreaded use. Sharing a single instance across thread boundaries without proper synchronization will result in
erratic behavior of the application. Under 1.4 problems seem to surface less often than under Java 5 where you will
probably see random <code>ArrayIndexOutOfBoundsException</code> or <code>IndexOutOfBoundsException</code> in
<code>sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()</code>. You may also experience
serialization problems. Using an instance field or a <code>ThreadLocal</code> is recommended.</p>
<p>For more information on this see Sun Bug #6231579 and Sun Bug #6178997.</p>
<p>Examples:</p>
<pre><code>    // Violations
    class MyClass {
        static SimpleDateFormat dateFormat1
        static java.text.SimpleDateFormat dateFormat2

        static final DATE1 = new SimpleDateFormat()
        static final DATE2 = new SimpleDateFormat('MM/dd')
        static final DATE3 = new SimpleDateFormat('MM/dd', DateFormatSymbols.instance)
        static date4 = new SimpleDateFormat('MM/dd', Locale.FRANCE)
        static date5 = new java.text.SimpleDateFormat('MM/dd')
    }

    // These usages are OK
    class MyCorrectClass {
        private SimpleDateFormat calendar1
        static ThreadLocal*SimpleDateFormat* calendar2
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized Method]]></name>
    <internalKey><![CDATA[SynchronizedMethod]]></internalKey>
    <description><![CDATA[<p>This rule reports uses of the <code>synchronized</code> keyword on methods. Synchronized methods
are the same as synchronizing on 'this', which effectively make your synchronization policy
public and modifiable by other objects. To avoid possibilities of deadlock, it is better to
synchronize on internal objects.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    synchronized def myMethod() {
        // do stuff ...
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnGetClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On Get Class]]></name>
    <internalKey><![CDATA[SynchronizedOnGetClass]]></internalKey>
    <description><![CDATA[<p>Checks for synchronization on <code>getClass()</code> rather than class literal. This instance method
synchronizes on <code>this.getClass()</code>. If this class is subclassed, subclasses will synchronize
on the class object for the subclass, which isn't likely what was intended.</p>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnBoxedPrimitiveRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On Boxed Primitive]]></name>
    <internalKey><![CDATA[SynchronizedOnBoxedPrimitive]]></internalKey>
    <description><![CDATA[<p>The code synchronizes on a boxed primitive constant, such as an Integer. Since Integer objects can be cached and shared,
this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness and possible
deadlock.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        Byte byte1 = 100
        Short short1 = 1
        Double double1 = 1
        Integer integer1 = 1
        Long long1 = 1
        Float float1 = 1
        Character char1 = 1

        byte byte2 = getValue()
        short short2 = getValue()
        double double2 = getValue()
        int integer2 = getValue()
        long long2 = getValue()
        float float2 = getValue()
        char char2 = getValue()

        def byte3 = new Byte((byte)100)
        def short3 = new Short((short)1)
        def double3 = new Double((double)1)
        def integer3 = new Integer(1)
        def long3 = new Long(1)
        def float3 = new Float(1)
        def char3 = new Character((char)'1')

        def byte4 = 1 as byte
        def short4 = 1 as short
        def double4 = 1 as double
        def integer4 = 1 as int
        def long4 = 1 as long
        def float4 = 1 as float
        def char4 = 1 as char

        def byte5 = 1 as Byte
        def short5 = 1 as Short
        def double5 = 1 as Double
        def integer5 = 1 as Integer
        def long5 = 1 as Long
        def float5 = 1 as Float
        def char5 = 1 as Character

        def byte6 = (byte)1
        def short6 = (short)1
        def double6 = (double)1
        def integer6 = (int)1
        def long6 = (long)1
        def float6 = (float)1
        def char6 = (char)1

        def method() {
            // all of these synchronization blocks produce violations
            synchronized(byte1) {}
            synchronized(short1) {}
            synchronized(double1) {}
            synchronized(integer1) {}
            synchronized(long1) {}
            synchronized(float1) {}
            synchronized(char1) {}

            synchronized(byte2) {}
            synchronized(short2) {}
            synchronized(double2) {}
            synchronized(integer2) {}
            synchronized(long2) {}
            synchronized(float2) {}
            synchronized(char2) {}

            synchronized(byte3) {}
            synchronized(short3) {}
            synchronized(double3) {}
            synchronized(integer3) {}
            synchronized(long3) {}
            synchronized(float3) {}
            synchronized(char3) {}

            synchronized(byte4) {}
            synchronized(short4) {}
            synchronized(double4) {}
            synchronized(integer4) {}
            synchronized(long4) {}
            synchronized(float4) {}
            synchronized(char4) {}

            synchronized(byte5) {}
            synchronized(short5) {}
            synchronized(double5) {}
            synchronized(integer5) {}
            synchronized(long5) {}
            synchronized(float5) {}
            synchronized(char5) {}

            synchronized(byte6) {}
            synchronized(short6) {}
            synchronized(double6) {}
            synchronized(integer6) {}
            synchronized(long6) {}
            synchronized(float6) {}
            synchronized(char6) {}
        }
    }
</code></pre>
<p>And here is an in-depth example of how it works within inner classes and such:</p>
<pre><code>    class MyClass {

        final String lock = false

        def method() {
            // violation
            synchronized(lock) { }
        }
    }

    class MyClass {

        final String lock = false

        class MyInnerClass {
            def method() {
                // violation
                synchronized(lock) { }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = true

        def method() {
            // violation
            synchronized(lock) { }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        def method() {
            return new Runnable() {
                final def lock = false // shadows parent from inner class
                public void run() {
                    // violation
                    synchronized(stringLock) { }
                }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        class MyInnerClass {

            final def lock = true // shadows parent from inner class
            def method() {
                // violation
                synchronized(stringLock) { }
            }
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On String]]></name>
    <internalKey><![CDATA[SynchronizedOnString]]></internalKey>
    <description><![CDATA[<p>Synchronization on a String field can lead to deadlock. Constant Strings are interned and shared across all other
classes loaded by the JVM. Thus, this could is locking on something that other code might also be locking. This could
result in very strange and hard to diagnose blocking and deadlock behavior.</p>
<p>See <a href="http://www.javalobby.org/java/forums/t96352.html">JETTY-352</a> and <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.</p>
<p>Examples:</p>
<pre><code>    class MyClass {

        final String stringLock = &quot;stringLock&quot;

        def method() {
            // violation
            synchronized(stringLock) { }
        }
    }

    class MyClass {

        final String stringLock = &quot;stringLock&quot;

        class MyInnerClass {
            def method() {
                synchronized(stringLock) { }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def stringLock = &quot;stringLock&quot;

        def method() {
            // violation
            synchronized(stringLock) { }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        def method() {
            return new Runnable() {
                final def lock = &quot;&quot; // shadows parent from inner class
                public void run() {
                    // violation
                    synchronized(stringLock) { }
                }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        class MyInnerClass {

            final def lock = &quot;&quot; // shadows parent from inner class
            def method() {
                // violation
                synchronized(stringLock) { }
            }
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnThisRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On This]]></name>
    <internalKey><![CDATA[SynchronizedOnThis]]></internalKey>
    <description><![CDATA[<p>This rule reports uses of the <code>synchronized</code> blocks where the synchronization reference
is 'this'. Doing this effectively makes your synchronization policy public and modifiable
by other objects. To avoid possibilities of deadlock, it is better to synchronize on internal objects.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def method3() {
        synchronized(this) {
            // do stuff ...
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedReadObjectMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized Read Object Method]]></name>
    <internalKey><![CDATA[SynchronizedReadObjectMethod]]></internalKey>
    <description><![CDATA[<p>Catches Serializable classes that define a synchronized readObject method. By definition, an object created by
deserialization is only reachable by one thread, and thus there is no need for readObject() to be synchronized. If
the readObject() method itself is causing the object to become visible to another thread, that is an example of very
dubious coding style.</p>
<p>Examples:</p>
<pre><code>    class MyClass implements Serializable {

        private synchronized void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            // violation, no need to synchronized
        }
    }

    class MyClass implements Serializable {

        private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            synchronized(lock) {
                // violation, no need to synchronized
            }
        }
    }

    // OK, class not Serializable
    class MyClass {

        private synchronized void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException { }
    }

    // OK, class not Serializable
    class MyClass {

        private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            synchronized(lock) { }
        }
    }

    class MyClass implements Serializable {

        private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            // OK, this block is more than just a simple sync statement
            synchronized(lock) { }
            doSomething()
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnReentrantLockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On Reentrant Lock]]></name>
    <internalKey><![CDATA[SynchronizedOnReentrantLock]]></internalKey>
    <description><![CDATA[<p>Synchronizing on a ReentrantLock field is almost never the intended usage. A ReentrantLock should be obtained using
the lock() method and released in a finally block using the unlock() method.</p>
<p>This rule take from Alex Miller's <a href="http://www.slideshare.net/alexmiller/java-concurrency-gotchas-3666977">Java Concurrency in Practice</a> slides.</p>
<p>Here is the proper usage of ReentrantLock:</p>
<pre><code>    import java.util.concurrent.locks.ReentrantLock;
    final lock = new ReentrantLock();
    def method()  {
       //Trying to enter the critical section
       lock.lock(); // will wait until this thread gets the lock
       try {
          // critical section
       } finally {
          //releasing the lock so that other threads can get notifies
          lock.unlock();
       }
    }
</code></pre>
<p>Example of violations:</p>
<pre><code>    class MyClass {

        final ReentrantLock lock = new ReentrantLock()

        def method() {
            // violation
            synchronized(lock) { }
        }
    }

    class MyClass {

        final ReentrantLock lock = new ReentrantLock()

        class MyInnerClass {
            def method() {
                synchronized(lock) { }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new ReentrantLock()

        def method() {
            // violation
            synchronized(lock) { }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        def method() {
            return new Runnable() {
                final def lock = new ReentrantLock() // shadows parent from inner class
                public void run() {
                    // violation
                    synchronized(lock) { }
                }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        class MyInnerClass {

            final def lock = new ReentrantLock() // shadows parent from inner class
            def method() {
                // violation
                synchronized(lock) { }
            }
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.SystemRunFinalizersOnExitRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Run Finalizers On Exit]]></name>
    <internalKey><![CDATA[SystemRunFinalizersOnExit]]></internalKey>
    <description><![CDATA[<p>This rule reports uses of the <code>System.runFinalizersOnExit()</code> method.</p>
<p>Method calls to <code>System.runFinalizersOnExit()</code> should not be allowed. This method is inherently
non-thread-safe, may result in data corruption, deadlock, and may affect parts of the program
far removed from it's call point. It is deprecated, and it's use strongly discouraged.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def method() {
        System.runFinalizersOnExit(true)
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.concurrency.ThisReferenceEscapesConstructorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[This Reference Escapes Constructor]]></name>
    <internalKey><![CDATA[ThisReferenceEscapesConstructor]]></internalKey>
    <description><![CDATA[<p>Reports constructors passing the 'this' reference to other methods.
This equals exposing a half-baked objects and can lead to race conditions during initialization.
For reference, see <a href="http://www.slideshare.net/alexmiller/java-concurrency-gotchas-3666977/38">Java Concurrency in Practice</a> by Alex Miller
and <a href="http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html">Java theory and practice: Safe construction techniques</a> by Brian Goetz.</p>
<p>Example of violations:</p>
<pre><code>    class EventListener {
        EventListener(EventPublisher publisher) {
            publisher.register(this)
            new WorkThread(publisher, this).start()
            new AnotherWorkThread(listener: this)
        }
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.ThreadGroupRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Thread Group]]></name>
    <internalKey><![CDATA[ThreadGroup]]></internalKey>
    <description><![CDATA[<p>Avoid using <code>ThreadGroup</code>; although it is intended to be used in a threaded environment it contains methods
that are not thread safe.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    new ThreadGroup(&quot;...&quot;)
    new ThreadGroup(tg, &quot;my thread group&quot;)
    Thread.currentThread().getThreadGroup()
    System.getSecurityManager().getThreadGroup()
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.ThreadLocalNotStaticFinalRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Thread Local Not Static Final]]></name>
    <internalKey><![CDATA[ThreadLocalNotStaticFinal]]></internalKey>
    <description><![CDATA[<p>This rule reports definition of the <code>ThreadLocal</code> fields that are not <code>static</code> and <code>final</code>.</p>
<p><em>ThreadLocal</em> fields should be <code>static</code> and <code>final</code>. In the most common case a
<code>java.lang.ThreadLocal</code> instance associates state with a thread. A non-<code>static</code>
non-<code>final</code> <code>java.lang.ThreadLocal</code> field associates state with an instance-thread combination.
This is seldom necessary and often a bug which can cause memory leaks and possibly incorrect behavior.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    private static ThreadLocal local1 = new ThreadLocal()
    private final ThreadLocal local2 = new ThreadLocal()
    protected ThreadLocal local3 = new ThreadLocal()
    ThreadLocal local4 = new ThreadLocal()
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.ThreadYieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Thread Yield]]></name>
    <internalKey><![CDATA[ThreadYield]]></internalKey>
    <description><![CDATA[<p>This rule reports uses of the <code>Thread.yield()</code> method.</p>
<p>Method calls to <code>Thread.yield()</code> should not be allowed. This method has no useful guaranteed
semantics, and is often used by inexperienced programmers to mask race conditions.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>     def method() {
         Thread.yield()
     }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.concurrency.UseOfNotifyMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Of Notify Method]]></name>
    <internalKey><![CDATA[UseOfNotifyMethod]]></internalKey>
    <description><![CDATA[<p>Checks for code that calls <code>notify()</code> rather than <code>notifyAll()</code>. Java monitors are often used
for multiple conditions. Calling <code>notify()</code> only wakes up one thread, meaning that the awakened
thread might not be the one waiting for the condition that the caller just satisfied.</p>
<p>Also see <a href="http://www.javaconcurrencyinpractice.com/"><strong>Java_Concurrency_in_Practice</strong></a>, Brian Goetz, p 303.</p>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.VolatileArrayFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Volatile Array Field]]></name>
    <internalKey><![CDATA[VolatileArrayField]]></internalKey>
    <description><![CDATA[<p>Volatile array fields are unsafe because the contents of the array are not treated as volatile. Changing the entire
array reference is visible to other threads, but changing an array element is not.</p>
<p>This rule take from Alex Miller's <em>Java Concurrency in Practice</em> slides, available at
<a href="http://www.slideshare.net/alexmiller/java-concurrency-gotchas-3666977">http://www.slideshare.net/alexmiller/java-concurrency-gotchas-3666977</a></p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        private volatile Object[] field1 = value()
        volatile field2 = value as Object[]
        volatile field3 = (Object[])foo
    }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.VolatileLongOrDoubleFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Volatile Long Or Double Field]]></name>
    <internalKey><![CDATA[VolatileLongOrDoubleField]]></internalKey>
    <description><![CDATA[<p>This rule reports on <code>long</code> or <code>double</code> fields that are declared <code>volatile</code>.</p>
<p>Long or double fields should not be declared as <code>volatile</code>. Java specifies that reads and
writes from such fields are atomic, but many JVM's have violated this specification. Unless you
are certain of your JVM, it is better to synchronize access to such fields rather than declare
them <code>volatile</code>. This rule flags fields marked <code>volatile</code> when their type is <code>double</code>
or <code>long</code> or the name of their type is &quot;Double&quot; or &quot;Long&quot;.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>     def method() {
         private volatile double d
         private volatile long f
     }
</code></pre>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.WaitOutsideOfWhileLoopRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Wait Outside Of While Loop]]></name>
    <internalKey><![CDATA[WaitOutsideOfWhileLoop]]></internalKey>
    <description><![CDATA[<p>Calls to <code>Object.wait()</code> must be within a <code>while</code> loop. This ensures that the awaited condition
has not already been satisfied by another thread before the <code>wait()</code> is invoked. It also ensures that
the proper thread was resumed and guards against incorrect notification. See [1] and [3].</p>
<p>As a more modern and flexible alternative, consider using the Java <em>concurrency utilities</em> instead of
<code>wait()</code> and <code>notify()</code>. See discussion in <em>Effective Java</em> [2].</p>
<p>Example of violation:</p>
<pre><code>    class MyClass {
        private data

        void processData()
            synchronized(data) {
                if (!data.isReady()) {
                    data.wait()
                }
                data.calculateStatistics()
            }
        }
    }
</code></pre>
<p>Example of correct usage:</p>
<pre><code>    class MyClass {
        private data

        void processData()
            synchronized(data) {
                while (!data.isReady()) {
                    data.wait()
                }
                data.calculateStatistics()
            }
        }
    }
</code></pre>
<h3>References</h3>
<ul>
<li>
<p>[1] <strong>Effective Java, Programming Language Guide</strong>, by Joshua Bloch. Addison Wesley (2001).
Chapter 50 (1st edition) is entitled &quot;Never invoke wait outside a loop.&quot;</p>
</li>
<li>
<p>[2] <strong>Effective Java</strong>, 2nd edition, by Joshua Bloch, Addison Wesley (2008).
Item #69: <em>Prefer concurrency utilities to wait and notify</em>.</p>
</li>
<li>
<p>[3] Software Engineering Institute - Secure Coding
<a href="https://www.securecoding.cert.org/confluence/display/java/THI03-J.+Always+invoke+wait()+and+await()+methods+inside+a+loop">discussion of this issue</a></p>
</li>
</ul>
]]></description>
    <tag>multi-threading</tag>
  </rule>

  <!-- convention rules -->

  <!-- since 1.4 -->
  <rule>
    <key>org.codenarc.rule.convention.CompileStaticRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Compile Static]]></name>
    <internalKey><![CDATA[CompileStatic]]></internalKey>
    <description><![CDATA[<p>Enforces classes are annotated either with one of the @CompileStatic, @GrailsCompileStatic or @CompileDynamic annotations.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.convention.ConfusingTernaryRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Confusing Ternary]]></name>
    <internalKey><![CDATA[ConfusingTernary]]></internalKey>
    <description><![CDATA[<p>In a ternary expression avoid negation in the test. For example, rephrase:
<code>(x != y) ? diff : same</code> as: <code>(x == y) ? same : diff</code>. Consistent use of this rule makes the code easier to read.
Also, this resolves trivial ordering problems, such as &quot;does the error case go first?&quot; or &quot;does the common case go first?&quot;.</p>
<p>Example:</p>
<pre><code>    (x != y) ? diff : same      // triggers violation
    (!x) ? diff : same          // triggers violation

    (x == y) ? same : diff      // OK
    (x) ? same : diff           // OK

    // this is OK, because of GroovyTruth there is no inverse of != null
    (x != null) ? diff : same

    // this is OK, because of GroovyTruth there is no inverse of != true
    (x != true) ? diff : same

    // this is OK, because of GroovyTruth there is no inverse of != false
    (x != false) ? diff : same
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.convention.CouldBeElvisRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Could Be Elvis]]></name>
    <internalKey><![CDATA[CouldBeElvis]]></internalKey>
    <description><![CDATA[<p>Catch an if block that could be written as an elvis expression.</p>
<p>Example of violations:</p>
<pre><code>    if (!x) {                   // violation
        x = 'some value'
    }

    if (!x)                     // violation
        x = &quot;some value&quot;

    if (!params.max) {          // violation
      params.max = 10
    }

    x ?: 'some value'           // OK
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.0 -->
  <rule>
    <key>org.codenarc.rule.convention.CouldBeSwitchStatementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Could Be Switch Statement]]></name>
    <internalKey><![CDATA[CouldBeSwitchStatement]]></internalKey>
    <description><![CDATA[<p>Checks for three of more if statements that could be converted to a switch. Only applies to equality and instanceof.</p>
<p>Example of violations:</p>
<pre><code>    if (x == 1) {                       // violation
       y = x
    } else if (x == 2) {
       y = x * 2
    } else if (x == 3) {
       y = x * 3
    } else {
       y = 0
    }

    if (y instanceof Integer) {         // violation
       x = y + 1
    }
    if (y instanceof String) {
       x = y + '1'
    } else if (y instanceof Boolean) {
       x = !y
    } else {
       x = null
    }

    if (x == 1) {                       // OK
        y = x
    }
    if (x == 2) {
        y = x * 2
    } else {
        y = 0
    }

    if (!x &amp;&amp; y) {                      // OK
        doSomething()
    } else if (!x &amp;&amp; z) {
        doSomethingElse()
    } else if (!x &amp;&amp; i) {
        doAnotherThing()
    }

</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.convention.FieldTypeRequiredRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Field Type Required]]></name>
    <internalKey><![CDATA[FieldTypeRequired]]></internalKey>
    <description><![CDATA[<p>Checks that field types are explicitly specified (and not using <code>def</code>).</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        public static final NAME = &quot;joe&quot;        // violation
        private static count = 0                // violation

        private def name = NAME                 // violation
        protected final date = new Date()       // violation

        def defaultName                         // violation
        def maxSoFar = -1L                      // violation
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.HashtableIsObsoleteRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Hashtable Is Obsolete]]></name>
    <internalKey><![CDATA[HashtableIsObsolete]]></internalKey>
    <description><![CDATA[<p>Checks for references to the (<em>effectively</em>) obsolete <code>java.util.Hashtable</code> class.
Use the <strong>Java Collections Framework</strong> classes instead, including <code>HashMap</code> or
<code>ConcurrentHashMap</code>. See the JDK javadoc.</p>
<p>Example of violations:</p>
<pre><code>    def myMap = new Hashtable()           // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.convention.IfStatementCouldBeTernaryRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[If Statement Could Be Ternary]]></name>
    <internalKey><![CDATA[IfStatementCouldBeTernary]]></internalKey>
    <description><![CDATA[<p>Checks for:</p>
<ul>
<li>
<p>An <code>if</code> statement where both the <code>if</code> and <code>else</code> blocks contain only a single <code>return</code>
statement returning a constant or literal value.</p>
</li>
<li>
<p>A block where the second-to-last statement in a block is an <code>if</code> statement with no <code>else</code>, where
the block contains a single <code>return</code> statement, and the last statement in the block is a <code>return</code>
statement, and both <code>return</code> statements return a constant or literal value.
This check is disabled by setting <code>checkLastStatementImplicitElse</code> to <code>false</code>.</p>
</li>
</ul>
<p>Example of violations:</p>
<pre><code>    if (condition) { return 44 } else { return 'yes' }                  // violation
    if (check()) { return [1, 2] } else { return &quot;count=$count&quot; }       // violation

    if (condition)                                                      // violation
        return null
    else return [a:1]

    def method1() {
        if (condition) {                                                // violation
            return 44
        }
        return 'yes'
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.5 -->
  <rule>
    <key>org.codenarc.rule.convention.ImplicitClosureParameterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Implicit Closure Parameter]]></name>
    <internalKey><![CDATA[ImplicitClosureParameter]]></internalKey>
    <description><![CDATA[<p>Checks for the implicit <code>it</code> closure parameter being used.
Also checks if an explicit <code>it</code> parameter has been specified.</p>
<p>Example of violations:</p>
<pre><code>    def closureWithViolation = { it * 10 }
    def closureWithViolationBecauseOfExplicitItParameter = { it -* it * 10}
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowUsingItAsParameterName</key>
      <description><![CDATA[To stop the rule reporting violations when an explicit closure parameter called "it" is used, set this property to "true".]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.convention.ImplicitReturnStatementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Implicit Return Statement]]></name>
    <internalKey><![CDATA[ImplicitReturnStatement]]></internalKey>
    <description><![CDATA[<p>&lt;Since CodeNarc 1.6&gt;</p>
<p>Checks for methods that are missing an explicit <code>return</code> statement.</p>
<p>This rule skips <code>void</code> methods and <code>def</code> (dynamic return type) methods, as well as methods whose last statement is a:</p>
<ul>
<li><code>throw</code></li>
<li><code>if</code></li>
<li><code>for</code></li>
<li><code>while</code></li>
<li><code>do .. while</code></li>
<li><code>switch</code></li>
<li><code>try/catch</code></li>
</ul>
<p>Example of violations:</p>
<pre><code>    boolean example() { true }          // violation
     
    protected int longerExample() {
        if (baseName == null) {
            return 0
        }
        99                              // violation
    }
</code></pre>
<p>Note: This rule is pretty much the opposite of the <a href="./codenarc-rules-unnecessary.html#unnecessaryreturnkeyword-rule">UnnecessaryReturnKeyword</a> rule.
Enabling both rules results in a paradox and may cause a rip in the fabric of <em>space-time</em>. Or at least unwanted violations.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.convention.InvertedConditionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Inverted Condition]]></name>
    <internalKey><![CDATA[InvertedCondition]]></internalKey>
    <description><![CDATA[<p>An inverted condition is one where a constant expression is used on the left hand side of the equals comparision.
Such conditions can be confusing especially when used in assertions where the expected value is by convention placed
on the right hand side of the comparision.</p>
<p>Example of violations:</p>
<pre><code>    boolean isTenCharactersLong(String value) {
        10 == value.size()  // violation
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.convention.InvertedIfElseRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Inverted If Else]]></name>
    <internalKey><![CDATA[InvertedIfElse]]></internalKey>
    <description><![CDATA[<p>An inverted <em>if-else</em> statement is one in which there is a single <code>if</code> statement with a single
<code>else</code> branch and the boolean test of the <code>if</code> is negated. For instance <code>if (!x) false else true</code>.
It is usually clearer to write this as <code>if (x) true else false</code>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.convention.LongLiteralWithLowerCaseLRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Long Literal With Lower Case L]]></name>
    <internalKey><![CDATA[LongLiteralWithLowerCaseL]]></internalKey>
    <description><![CDATA[<p>In Java and Groovy, you can specify long literals with the L or l character,
for instance 55L or 24l. It is best practice to always use an uppercase L and never
a lowercase l. This is because 11l rendered in some fonts may look like 111 instead of 11L.</p>
<p>Example of violations:</p>
<pre><code>    def x = 1l
    def y = 55l
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.convention.MethodParameterTypeRequired</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Method Parameter Type Required]]></name>
    <internalKey><![CDATA[MethodParameterTypeRequired]]></internalKey>
    <description><![CDATA[<p>Checks that method parameters are not dynamically typed, that is they are explicitly stated and different than def.</p>
<p>Example of violations:</p>
<pre><code>    void methodWithDynamicParameter(def parameter) {              // violation
    }

    void methodWithParameterWithoutTypeDeclaration(parameter) {   // violation
    }

    void methodWithObjectParameter(Object parameter)              // OK
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.convention.MethodReturnTypeRequiredRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Method Return Type Required]]></name>
    <internalKey><![CDATA[MethodReturnTypeRequired]]></internalKey>
    <description><![CDATA[<p>Checks that method return types are not dynamic, that is they are explicitly stated and different than def.</p>
<p>Example of violations:</p>
<pre><code>    def methodWithDynamicReturnType() {    // violation
    }

    private methodWithoutReturnType() {    // violation
    }

    Object objectReturningMethod() {       // OK
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.convention.NoDefRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[No Def]]></name>
    <internalKey><![CDATA[NoDef]]></internalKey>
    <description><![CDATA[<p>Do not allow using the <code>def</code> keyword in code. Use a specific type instead.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>excludeRegex</key>
      <description><![CDATA[Regular expression matching the names of fields, variables, parameters or methods that can be preceded by the "def" keyword.]]></description>
      <defaultValue>''</defaultValue>
    </param>
  </rule>

  <!-- since 1.5 -->
  <rule>
    <key>org.codenarc.rule.convention.NoDoubleRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[No Double]]></name>
    <internalKey><![CDATA[NoDouble]]></internalKey>
    <description><![CDATA[<p>Checks for use of the <code>double</code> or <code>java.lang.Double</code> types, in fields, variables, method parameters, constructor parameters and method return types.
Prefer using BigDecimal or int or long, when exact calculations are required. This is due to the limitations and gotchas of the floating point representation
of the <em>double</em> type. This is especially important for monetary calculations.</p>
<p>Some related discussions include:</p>
<ul>
<li><strong>Effective Java</strong>, 2nd edition, by Joshua Bloch, Addison Wesley (2008). Item #48: <em>Avoid float and double if exact answers are required</em>.</li>
<li><a href="https://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency">Why not use Double or Float to represent currency?</a></li>
<li><a href="https://dzone.com/articles/never-use-float-and-double-for-monetary-calculatio">Why You Should Never Use Float and Double for Monetary Calculations</a>.</li>
</ul>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        int count
        double doubleProperty                               // Violation: Property (field) type
        private Double doubleField = 1.2                    // Violation: Field type

        private double calculateAverage() { return 0 }      // Violation: Method return type

        protected void setAverage(Double average) { }       // Violation: Method parameter type

        MyClass(int count, double rating, double factor) {  // Violation: Constructor parameter
            String name = 'abc'
            Double doubleVar = calculateAverage()           // Violation: Variable
            double double1, double2 = 0                     // Violation: Variable
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.5 -->
  <rule>
    <key>org.codenarc.rule.convention.NoFloatRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[No Float]]></name>
    <internalKey><![CDATA[NoFloat]]></internalKey>
    <description><![CDATA[<p>Checks for use of the <code>float</code> or <code>java.lang.Float</code> types, in fields, variables, method parameters, constructor parameters and method return types.
Prefer using BigDecimal or int or long, when exact calculations are required. This is due to the limitations and gotchas of the floating point representation
of the <em>float</em> type. This is especially important for monetary calculations.</p>
<p>Some related discussions include:</p>
<ul>
<li><strong>Effective Java</strong>, 2nd edition, by Joshua Bloch, Addison Wesley (2008). Item #48: <em>Avoid float and double if exact answers are required</em>.</li>
<li><a href="https://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency">Why not use Double or Float to represent currency?</a></li>
<li><a href="https://dzone.com/articles/never-use-float-and-double-for-monetary-calculatio">Why You Should Never Use Float and Double for Monetary Calculations</a>.</li>
</ul>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        int count
        float floatProperty                                 // Violation: Property (field) type
        private Float floatField = 1.2                      // Violation: Field type

        private float calculateAverage() { return 0 }       // Violation: Method return type

        protected void setAverage(Float average) { }        // Violation: Method parameter type

        MyClass(int count, float rating, float factor) {    // Violation: Constructor parameter
            String name = 'abc'
            Float floatVar = calculateAverage()             // Violation: Variable
            float float1, float2 = 0                        // Violation: Variable
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.2 -->
  <rule>
    <key>org.codenarc.rule.convention.NoJavaUtilDateRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[No Java Util Date]]></name>
    <internalKey><![CDATA[NoJavaUtilDate]]></internalKey>
    <description><![CDATA[<p>Do not use the <code>java.util.Date</code> class. Prefer the classes in the java.time.* packages. This rule checks for
construction of new java.util.Date objects.</p>
<p>If the class imports another <code>Date</code> class, then references to <code>new Date()</code> will not cause a violation.</p>
<p>Example of violations:</p>
<pre><code>    def timestamp = new Date()              // violation
    Date myDate = new java.util.Date()      // violation
    Date startTime = new Date(123456789L)   // violation
</code></pre>
<p>Known limitations:</p>
<ul>
<li>Will cause an incorrect violation if the source code is referring to a different <code>Date</code> class from the current package. In that case, it may be better to just disable this rule (either per class or globally).</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.25 -->
  <rule>
    <key>org.codenarc.rule.convention.NoTabCharacterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[No Tab Character]]></name>
    <internalKey><![CDATA[NoTabCharacter]]></internalKey>
    <description><![CDATA[<p>Checks that all source files do not contain the tab character.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.
The <code>@SuppressWarnings</code> annotation-based disablement is also unavailable, but including a <code>// codenarc-disable NoTabCharacter</code> comment
somewhere above the violation will disable this rule. See
<a href="./codenarc-configuring-rules.html#disabling-rules-from-comments">Disabling Rules From Comments</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.ParameterReassignmentRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Parameter Reassignment]]></name>
    <internalKey><![CDATA[ParameterReassignment]]></internalKey>
    <description><![CDATA[<p>Checks for a method or closure parameter being reassigned to a new value within the body of the method/closure,
which is a confusing and questionable practice. Use a temporary variable instead.</p>
<p>Example of violations:</p>
<pre><code>    void myMethod(int a, String b) {
        println a
        b = 'new value'     // violation
    }

    def myClosure1 = { int a, b -*
        a = 123             // violation
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.2 -->
  <rule>
    <key>org.codenarc.rule.convention.PublicMethodsBeforeNonPublicMethodsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Public Methods Before Non Public Methods]]></name>
    <internalKey><![CDATA[PublicMethodsBeforeNonPublicMethods]]></internalKey>
    <description><![CDATA[<p>Enforce that all public methods are above protected and private methods.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        public static int staticMethod1() { }

        protected String method1() { }

        static final String staticMethod2() { }     // violation
        public String method2() { }                 // violation

        private int method3(int id) { }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.2 -->
  <rule>
    <key>org.codenarc.rule.convention.StaticFieldsBeforeInstanceFieldsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Static Fields Before Instance Fields]]></name>
    <internalKey><![CDATA[StaticFieldsBeforeInstanceFields]]></internalKey>
    <description><![CDATA[<p>Enforce that all static fields are above all instance fields within a class</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        public static final int COUNT = 99

        public String f1

        public static final String F1 = &quot;xxx&quot;       // violation
        private static String F4                    // violation
        static F5 = new Date()                      // violation

        protected String f2
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.2 -->
  <rule>
    <key>org.codenarc.rule.convention.StaticMethodsBeforeInstanceMethodsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Static Methods Before Instance Methods]]></name>
    <internalKey><![CDATA[StaticMethodsBeforeInstanceMethods]]></internalKey>
    <description><![CDATA[<p>Enforce that all static methods within each visibility level (public, protected, private) are above all
instance methods within that same visibility level. In other words, public static methods must be above
public instance methods, protected static methods must be above protected instance methods and private
static methods must be above private instance methods.</p>
<p>Example of violations:</p>
<pre><code>        class MyClass {
            // Public
            public static int staticMethod1() { }
            public String method1() { }
            int method2() { }
            static final String staticMethod2(int id) { }       // violation

            // Protected
            protected String method3() { }
            protected static staticMethod3() { }                // violation

            // Private
            private int method4() { }
            private int method5() { }
            private static staticMethod4() { }                  // violation
            private String method5() { }
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.TernaryCouldBeElvisRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Ternary Could Be Elvis]]></name>
    <internalKey><![CDATA[TernaryCouldBeElvis]]></internalKey>
    <description><![CDATA[<p>Checks for ternary expressions where the <em>boolean</em> and <em>true</em> expressions are the same.
These can be simplified to an <em>Elvis</em> expression.</p>
<p>Example of violations:</p>
<pre><code>    x ? x : false               // violation; can simplify to x ?: false

    foo() ? foo() : bar()       // violation; can simplify to foo() ?: bar()
    foo(1) ? foo(1) : 123       // violation; can simplify to foo(1) ?: 123

    (x == y) ? same : diff      // OK
    x ? y : z                   // OK
    x ? x + 1 : x + 2           // OK
    x ? 1 : 0                   // OK
    x ? !x : x                  // OK
    !x ? x : null               // OK

    foo() ? bar() : 123         // OK
    foo() ? foo(99) : 123       // OK
    foo(x) ? foo() : 123        // OK
    foo(1) ? foo(2) : 123       // OK
</code></pre>
<p>NOTE: If the <em>boolean</em> and <em>true</em> expressions are the same method call, and that method
call has <em>side-effects</em>, then converting it to a <em>Elvis</em> expression may produce <em>different</em>
behavior. The method will only be called <em>once</em>, rather than <em>twice</em>. But relying on those
<em>side-effects</em> as part of a ternary expression behavior is confusing, error-prone and just a
bad idea. In any case, that code should be refactored to move the reliance on the side-effects
out of the ternary expression.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.25 -->
  <rule>
    <key>org.codenarc.rule.convention.TrailingCommaRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Trailing Comma]]></name>
    <internalKey><![CDATA[TrailingComma]]></internalKey>
    <description><![CDATA[<p>Check whether list and map literals contain optional trailing comma.
Rationale: Putting this comma in make is easier
to change the order of the elements or add new elements on the end.</p>
<p>This is valid code:</p>
<pre><code>  int[] array1 = [] // one line declaration
  int[] array2 = [ // empty list
                 ]
  int[] array3 = [1,2,3] // one line declaration
  int[] array4 = [1,
                  2,
                  3, // contains trailing comma
                 ]
</code></pre>
<p>Example of violations:</p>
<pre><code>  int[] array2 = [1,
                  2 // there is no trailing comma
                 ]
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>checkList</key>
      <description><![CDATA[To disable checking List literals, set this property to "false"]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>checkMap</key>
      <description><![CDATA[To disable checking Map literals, set this property to "false"]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreSingleElementList</key>
      <description><![CDATA[If true, skip checking Lists that have only a single element.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreSingleElementMap</key>
      <description><![CDATA[If true, skip checking Maps that have only a single element.]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.convention.VariableTypeRequiredRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Variable Type Required]]></name>
    <internalKey><![CDATA[VariableTypeRequired]]></internalKey>
    <description><![CDATA[<p>Checks that variable types are explicitly specified in declarations (and not using <code>def</code>).</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        void doStuff() {
            final NAME = &quot;joe&quot;          // violation
            def count = 0, max = 99     // violation
            def defaultName             // violation
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreVariableNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) variable names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.VectorIsObsoleteRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Vector Is Obsolete]]></name>
    <internalKey><![CDATA[VectorIsObsolete]]></internalKey>
    <description><![CDATA[<p>Checks for references to the (<em>effectively</em>) obsolete <code>java.util.Vector</code> class.
Use the <strong>Java Collections Framework</strong> classes instead, including <code>ArrayList</code> or
<code>Collections.synchronizedList()</code>. See the JDK javadoc.</p>
<p>Example of violations:</p>
<pre><code>    def myList = new Vector()           // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- design rules -->

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.design.AbstractClassWithPublicConstructorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract Class With Public Constructor]]></name>
    <internalKey><![CDATA[AbstractClassWithPublicConstructor]]></internalKey>
    <description><![CDATA[<p>Checks for <code>abstract</code> classes that define a <code>public</code> constructor, which is useless and confusing.</p>
<p>The following code produces a violation:</p>
<pre><code>    abstract class MyClass {
        MyClass() { }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.AbstractClassWithoutAbstractMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract Class Without Abstract Method]]></name>
    <internalKey><![CDATA[AbstractClassWithoutAbstractMethod]]></internalKey>
    <description><![CDATA[<p>The abstract class does not contain any abstract methods. An abstract class suggests an incomplete implementation,
which is to be completed by subclasses implementing the abstract methods. If the class is intended to be used as a
base class only (not to be instantiated directly) a protected constructor can be provided prevent direct instantiation.</p>
<p>Example:</p>
<pre><code>    public abstract class MyBaseClass {
        void method1() {  }
        void method2() {  }
        // consider using abstract methods or removing
        // the abstract modifier and adding protected constructors
    }
</code></pre>
<p>The following examples all pass:</p>
<pre><code>    abstract class MyClass extends AbstractParent {
        // OK because parent is named Abstract.*
    }
    abstract class MyClass extends BaseParent{
        // OK because parent is named Base.*
    }
</code></pre>
<p>This rule has a single <code>enhancedMode</code> property which defaults to <code>false</code>. When set to <code>true</code>, this rule
will run in <a href="./codenarc-enhanced-classpath-rules.html">enhanced mode</a> and will not produce a violation when an
abstract class extends an abstract superclass.</p>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.24 -->
  <rule>
    <key>org.codenarc.rule.design.AssignmentToStaticFieldFromInstanceMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assignment To Static Field From Instance Method]]></name>
    <internalKey><![CDATA[AssignmentToStaticFieldFromInstanceMethod]]></internalKey>
    <description><![CDATA[<p>Checks for assignment to a static field from an instance method.</p>
<p>Influenced by the <strong>AssignmentToNonFinalStatic</strong> rule from <strong>PMD</strong>, and the
<strong>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</strong> rule from <strong>FindBugs</strong>.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        private static field1
        protected static String field2 = 'abc'
        public static int field3 = 123
        static String property1 = 'abc'
        private static final NAME = 'joe'

        private void doStuff() {
            field1 = new Object()       // violation
            field2 = 'xxx'              // violation
            field3 = 999                // violation
            property1 = 'xxx'           // violation

            final NAME = 'martin'       // no violation; local var hides static field
        }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.design.BooleanMethodReturnsNullRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Boolean Method Returns Null]]></name>
    <internalKey><![CDATA[BooleanMethodReturnsNull]]></internalKey>
    <description><![CDATA[<p>Checks for a method with <code>Boolean</code> return type that returns an explicit <code>null</code>. A method that
returns either <code>Boolean.TRUE</code>, <code>Boolean.FALSE</code> or <code>null</code> is an accident waiting to happen.
This method can be invoked as though it returned a value of type <code>boolean</code>, and the compiler will
insert automatic <em>unboxing</em> of the <code>Boolean</code> value. If a <code>null</code> value is returned, this will
result in a <code>NullPointerException</code>.</p>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.design.BuilderMethodWithSideEffectsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Builder Method With Side Effects]]></name>
    <internalKey><![CDATA[BuilderMethodWithSideEffects]]></internalKey>
    <description><![CDATA[<p>A builder method is defined as one that creates objects. As such, they should never be of void return type. If a method
is named build, create, or make, then it should always return a value.</p>
<p>This rule has one property: <code>methodNameRegex</code>. The default value is (make.<em>|create.</em>|build.*). Update this property
if you have some  other naming convention for your builder methods.</p>
<p>Example of violations:</p>
<pre><code>
    class MyClass {

            void make() { /* ... */ }
            void makeSomething() { /* ... */ }

            void create() { /* ... */ }
            void createSomething() { /* ... */ }

            void build() { /* ... */ }
            void buildSomething() { /* ... */ }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.design.CloneableWithoutCloneRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Cloneable Without Clone]]></name>
    <internalKey><![CDATA[CloneableWithoutClone]]></internalKey>
    <description><![CDATA[<p>Checks for classes that implement the <code>java.lang.Cloneable</code> interface without implementing
the <code>clone()</code> method.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    class BadClass implements Cloneable {
        def someMethod()
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.CloseWithoutCloseableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Close Without Closeable]]></name>
    <internalKey><![CDATA[CloseWithoutCloseable]]></internalKey>
    <description><![CDATA[<p>If a class defines a <code>void close()</code> method then that class should implement <code>java.io.Closeable</code>.</p>
<p>This rule has a single <code>enhancedMode</code> property which defaults to <code>false</code>. When set to <code>true</code>, this rule
will run in <a href="./codenarc-enhanced-classpath-rules.html">enhanced mode</a> and will not produce a violation when a class
implements <code>close</code> and extends a class that itself implements <code>Closeable</code>.</p>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.CompareToWithoutComparableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Compare To Without Comparable]]></name>
    <internalKey><![CDATA[CompareToWithoutComparable]]></internalKey>
    <description><![CDATA[<p>If you implement a compareTo method then you should also implement the <code>Comparable</code> interface. If you
don't then you could possibly get an exception if the Groovy == operator is invoked on your object.
This is an issue fixed in Groovy 1.8 but present in previous versions.</p>
<p>This rule has a single <code>enhancedMode</code> property which defaults to <code>false</code>. When set to <code>true</code>, this rule
will run in <a href="./codenarc-enhanced-classpath-rules.html">enhanced mode</a> and will not produce a violation when a class
implements <code>compareTo</code> and extends a class that itself implements <code>Comparable</code>.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    class BadClass {
        int compareTo(Object o) { ... }
    }
</code></pre>
<p>Known limitations:</p>
<ul>
<li>When not running in enhanced mode, this rule is not able to determine if the class extends a superclass that itself
implements <code>Comparable</code>, or if it implements an interface that extends <code>Comparable</code>. In those cases, this
rule produces a false violation.</li>
</ul>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.ConstantsOnlyInterfaceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constants Only Interface]]></name>
    <internalKey><![CDATA[ConstantsOnlyInterface]]></internalKey>
    <description><![CDATA[<p>An interface should be used only to model a behaviour of a class: using an interface as a container of constants is
a poor usage pattern. Example:</p>
<pre><code>    public interface ConstantsInterface {
        public static final int CONSTANT_1 = 0
        public static final String CONSTANT_2 = &quot;1&quot;
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.EmptyMethodInAbstractClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Method In Abstract Class]]></name>
    <internalKey><![CDATA[EmptyMethodInAbstractClass]]></internalKey>
    <description><![CDATA[<p>An empty method in an abstract class should be abstract instead, as developer may rely on this empty implementation
rather than code the appropriate one.</p>
<pre><code>    abstract class MyClass {
        def couldBeAbstract_1() {
            return null  // Should be abstract method
        }

        void couldBeAbstract_2() {
            // Should be abstract method
        }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.FinalClassWithProtectedMemberRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Final Class With Protected Member]]></name>
    <internalKey><![CDATA[FinalClassWithProtectedMember]]></internalKey>
    <description><![CDATA[<p>This rule finds classes marked final that contain <code>protected</code> members. If a class is <code>final</code> then it may not be
subclassed, and there is therefore no point in having a member with <code>protected</code> visibility. Either the class should
not be <code>final</code> or the member should be private or protected.</p>
]]></description>
    <tag>design</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.design.ImplementationAsTypeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Implementation As Type]]></name>
    <internalKey><![CDATA[ImplementationAsType]]></internalKey>
    <description><![CDATA[<p>Checks for use of the following concrete classes when specifying the type of a method
parameter, closure parameter, constructor parameter, method return type or field
type. The corresponding interfaces should be used to specify the type instead.</p>
<ul>
<li>java.util.ArrayList</li>
<li>java.util.GregorianCalendar</li>
<li>java.util.HashMap</li>
<li>java.util.HashSet</li>
<li>java.util.Hashtable</li>
<li>java.util.LinkedHashMap</li>
<li>java.util.LinkedHashSet</li>
<li>java.util.LinkedList</li>
<li>java.util.TreeMap</li>
<li>java.util.TreeSet</li>
<li>java.util.Vector</li>
<li>java.util.concurrent.ArrayBlockingQueue</li>
<li>java.util.concurrent.ConcurrentHashMap</li>
<li>java.util.concurrent.ConcurrentLinkedQueue</li>
<li>java.util.concurrent.CopyOnWriteArrayList</li>
<li>java.util.concurrent.CopyOnWriteArraySet</li>
<li>java.util.concurrent.DelayQueue</li>
<li>java.util.concurrent.LinkedBlockingQueue</li>
<li>java.util.concurrent.PriorityBlockingQueue</li>
<li>java.util.concurrent.PriorityQueue</li>
<li>java.util.concurrent.SynchronousQueue</li>
</ul>
<p>Here are examples of code that produces violations:</p>
<pre><code>    // Method parameter
    void myMethod(ArrayList list) {                   // violation
        ...
    }

    // Constructor parameter
    class MyClass {
        MyClass(java.util.HashSet set) {              // violation
            ...
        }
    }

    // Closure parameter
    def closure = { PriorityQueue queue -* ... }      // violation

    // Method return type
    GregorianCalendar calculateDate(int num) {        // violation
        ...
    }

    // Field type
    class MyClass {
        Hashtable map                                 // violation
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.design.InstanceofRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Instanceof]]></name>
    <internalKey><![CDATA[Instanceof]]></internalKey>
    <description><![CDATA[<p>Checks for use of the <code>instanceof</code> operator. Prefer using <em>polymorphism</em> instead.</p>
<p>Use the <code>ignoreTypeNames</code> property to configure ignored type names (the class name specified as the
right-hand expression of the <code>instanceof</code>). It defaults to ignoring <code>instanceof</code> checks against exception classes.</p>
<p>Here are a couple references that discuss the problems with using <code>instanceof</code> and the preference
for using <em>polymorphism</em> instead:</p>
<ul>
<li><a href="http://www.javapractices.com/topic/TopicAction.do?Id=31">Beware of instanceof operator</a></li>
<li><a href="http://stackoverflow.com/questions/4192837/how-does-one-use-polymorphism-instead-of-instanceof-and-why">How does one use polymorphism instead of instanceof? (And why?)</a></li>
</ul>
<p>By default, the rule does not analyze test files. This rule sets the default value of the
<em>doNotApplyToFilesMatching</em> property to ignore file names ending in 'Spec.groovy', 'Test.groovy', 'Tests.groovy'
or 'TestCase.groovy'.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        boolean isRunnable = this instanceof Runnable       // violation
    }
</code></pre>
]]></description>
    <tag>design</tag>
    <param>
      <key>ignoreTypeNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) class names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
      <defaultValue>*Exception</defaultValue>
    </param>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.design.LocaleSetDefaultRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Locale Set Default]]></name>
    <internalKey><![CDATA[LocaleSetDefault]]></internalKey>
    <description><![CDATA[<p>Checks for calls to <code>Locale.setDefault()</code>, or <code>Locale.default = Xxx</code>, which sets the Locale
across the entire JVM. That can impact other applications on the same web server, for instance.</p>
<p>From the java.util.Locale javadoc for <code>setDefault</code>:
<em>Since changing the default locale may affect many different areas of functionality, this method
should only be used if the caller is prepared to reinitialize locale-sensitive code running within
the same Java Virtual Machine.</em></p>
<p>Example of violations:</p>
<pre><code>    Locale.setDefault(Locale.UK)                                // violation
    java.util.Locale.setDefault(Locale.FRANCE)                  // violation
    Locale.setDefault(Locale.Category.DISPLAY, Locale.JAPAN)    // violation

    Locale.default = Locale.UK                                  // violation
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.23 -->
  <rule>
    <key>org.codenarc.rule.design.NestedForLoopRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Nested For Loop]]></name>
    <internalKey><![CDATA[NestedForLoop]]></internalKey>
    <description><![CDATA[<p>Reports classes with nested for loops.</p>
<p>Example of violations:</p>
<pre><code>for (int i = 0; i * 100; ++i) {
    for (int j = 0; j * 100; ++j) { // violation
        println i + j
    }
}

for (int i = 0; i * 100; ++i) {
    for (int j = 0; j * 100; ++j) { // violation
        println i + j
    }
    for (int j = 0; j * 100; ++j) { // violation
        println i + j
    }
}

for (int i = 0; i * 100; ++i) {
    for (int j = 0; j * 100; ++j) { // violation
        for (int k = 0; k * 100; ++k) { // violation
            println i + j + k
        }
    }
}
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 2.0.0 -->
  <rule>
    <key>org.codenarc.rule.design.OptionalCollectionReturnTypeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Optional Collection Return Type]]></name>
    <internalKey><![CDATA[OptionalCollectionReturnType]]></internalKey>
    <description><![CDATA[<p>Do not declare a method return type of <code>Optional&lt;List&gt;</code> (or <code>Collection</code>, <code>ArrayList</code>, <code>Set</code>, <code>Map</code>, <code>HashMap</code>, etc.). Return an empty collection instead.  See <a href="https://blogs.oracle.com/javamagazine/the-java-optional-class-11-more-recipes-for-preventing-null-pointer-exceptions">The Java Optional class: 11 more recipes for preventing null pointer exceptions</a>.</p>
<p>This rule checks for <code>Optional&lt;collection-type&gt;</code> return types, where <em>collection-type</em> is one of these common collection interfaces or implementation classes:</p>
<ul>
<li><code>Collection</code></li>
<li><code>List</code> (and <code>ArrayList</code>, <code>LinkedList</code>)</li>
<li><code>Set</code> (and <code>HashSet</code>, <code>LinkedHashSet</code>, <code>EnumSet</code>)</li>
<li><code>SortedSet</code> (and <code>TreeSet</code>)</li>
<li><code>Map</code> (and <code>HashMap</code>, <code>LinkedHashMap</code>, <code>EnumMap</code>)</li>
<li><code>SortedMap</code> (and <code>TreeMap</code>)</li>
</ul>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        Optional&lt;Collection&lt;Object&gt;&gt; getCollection() { }        // violation

        private Optional&lt;List&gt; getList() { }                    // violation
        Optional&lt;ArrayList&lt;String&gt;&gt; getArrayList() { }          // violation
        
        protected Optional&lt;Set&lt;BigDecimal&gt;&gt; getSet() { }        // violation
        Optional&lt;HashSet&lt;Boolean&gt;&gt; getHashSet() { }             // violation

        Optional&lt;Map&lt;Integer, String&gt;&gt; getMap() { }             // violation
        Optional&lt;TreeMap&lt;String, String&gt;&gt; getTreeMap() { }      // violation
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 2.0.0 -->
  <rule>
    <key>org.codenarc.rule.design.OptionalFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Optional Field]]></name>
    <internalKey><![CDATA[OptionalField]]></internalKey>
    <description><![CDATA[<p>Do not use an <code>Optional</code> as a field type. See <a href="https://blogs.oracle.com/javamagazine/the-java-optional-class-11-more-recipes-for-preventing-null-pointer-exceptions">The Java Optional class: 11 more recipes for preventing null pointer exceptions</a>.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        Optional&lt;Integer&gt; count;                            // violation
        public String name;
        public Optional&lt;String&gt; alias = Optional.of(&quot;x&quot;)    // violation
        protected static Optional&lt;Object&gt; lock              // violation
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 2.0.0 -->
  <rule>
    <key>org.codenarc.rule.design.OptionalMethodParameterRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Optional Method Parameter]]></name>
    <internalKey><![CDATA[OptionalMethodParameter]]></internalKey>
    <description><![CDATA[<p>Do not use an <code>Optional</code> as a parameter type for a method or constructor. See <a href="https://blogs.oracle.com/javamagazine/the-java-optional-class-11-more-recipes-for-preventing-null-pointer-exceptions">The Java Optional class: 11 more recipes for preventing null pointer exceptions</a>.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        protected MyClass(Optional&lt;Integer&gt; count) { }                  // violation
        MyClass(Optional&lt;String&gt; name, Optional&lt;Integer&gt; sum) { }       // 2 violations
        private MyClass(Optional something) { }                         // violation

        void doStuff(Optional&lt;Integer&gt; count) { }                       // violation
        public String getName() { return 'abc' }
        int count(Optional&lt;String&gt; alias, Optional&lt;Integer&gt; total) { }  // 2 violations
        private doSomething(Optional something) { }                     // violation
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.design.PrivateFieldCouldBeFinalRule.fixed</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Private Field Could Be Final]]></name>
    <internalKey><![CDATA[PrivateFieldCouldBeFinal]]></internalKey>
    <description><![CDATA[<p>This rule finds <code>private</code> fields that are only set within a <em>constructor</em> or <em>field initializer</em>.
Such fields can safely be made <code>final</code>.</p>
]]></description>
    <tag>design</tag>
    <param>
      <key>ignoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>ignoreJpaEntities</key>
      <description><![CDATA[Specifies whether fields defined inside classes annotated with @Entity or @MappedSuperclass JPA annotations should be ignored (i.e., that should not cause a rule violation).]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.design.PublicInstanceFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Public Instance Field]]></name>
    <internalKey><![CDATA[PublicInstanceField]]></internalKey>
    <description><![CDATA[<p>Using public fields is considered to be a bad design. Use properties instead.</p>
<p>Example of violations:</p>
<pre><code>    class Person {
        public String name
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.design.ReturnsNullInsteadOfEmptyArrayRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Returns Null Instead Of Empty Array]]></name>
    <internalKey><![CDATA[ReturnsNullInsteadOfEmptyArray]]></internalKey>
    <description><![CDATA[<p>If you have a method or closure that returns an array, then when there are no results return a zero-length
(empty) array rather than <code>null</code>. It is often a better design to return a zero-length array rather than a
<code>null</code> reference to indicate that there are no results (i.e., an <em>empty</em> list of results). This way,
no explicit check for <code>null</code> is needed by clients of the method.</p>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.design.ReturnsNullInsteadOfEmptyCollectionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Returns Null Instead Of Empty Collection]]></name>
    <internalKey><![CDATA[ReturnsNullInsteadOfEmptyCollection]]></internalKey>
    <description><![CDATA[<p>If you have a method or closure that returns a collection, then when there are no results return a zero-length
(empty) collection rather than <code>null</code>. It is often a better design to return a zero-length collection
rather than a <code>null</code> reference to indicate that there are no results (i.e., an <em>empty</em> list of results).
This way, no explicit check for <code>null</code> is needed by clients of the method.</p>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.SimpleDateFormatMissingLocaleRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Simple Date Format Missing Locale]]></name>
    <internalKey><![CDATA[SimpleDateFormatMissingLocale]]></internalKey>
    <description><![CDATA[<p>Be sure to specify a <code>Locale</code> when creating a new instance of <code>SimpleDateFormat</code>; the class is locale-sensitive. If you
instantiate <code>SimpleDateFormat</code> without a <code>Locale</code> parameter, it will format the date and time according to the default
<code>Locale</code>. Both the pattern and the <code>Locale</code> determine the format. For the same pattern, <code>SimpleDateFormat</code> may format a
date and time differently if the Locale varies.</p>
<pre><code>    // violation, missing locale
    new SimpleDateFormat('pattern')

    // OK, includes locale
    new SimpleDateFormat('pattern', Locale.US)

    // OK, includes a variable that perhaps is a locale
    new SimpleDateFormat('pattern', locale)
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.design.StatelessSingletonRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Stateless Singleton]]></name>
    <internalKey><![CDATA[StatelessSingleton]]></internalKey>
    <description><![CDATA[<p>There is no point in creating a stateless Singleton because there is nothing within the class that needs guarding and
no side effects to calling the constructor. Just create new instances of the object or write a Utility class with
static methods. In the long term, Singletons can cause strong coupling and hard to change systems.</p>
<p>If the class has any fields at all, other than a self reference, then it is not considered stateless. A self reference
is a field of the same type as the enclosing type, or a field named instance or _instance. The field name self reference
is a property named instanceRegex that defaults to the value 'instance|_instance'</p>
<p>Example of violations:</p>
<pre><code>    @groovy.lang.Singleton
    class Service {
       // violation: the class has no fields but is marked Singleton
        void processItem(item){
        }
    }

    class Service {
       // violation: the class has no fields other than 'instance' but is marked Singleton
        static instance
        void processItem(item){
        }
    }

    class Service {                                       // violation
        static Service service
        void processItem(item){
        }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.design.ToStringReturnsNullRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[To String Returns Null]]></name>
    <internalKey><![CDATA[ToStringReturnsNull]]></internalKey>
    <description><![CDATA[<p>Checks for <code>toString()</code> methods that return <code>null</code>. This is unconventional and could
cause unexpected <code>NullPointerExceptions</code> from normal or implicit use of <code>toString()</code>.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        String toString() {
            if (foo()) {
                return 'MyClass'
            } else {
                return null         // violation
            }
        }
    }

    class MyClass {
        String toString() {
            calculateStuff()
            null                    // violation
        }
    }

    class MyClass {
        String toString() {         // violation - implicit return of null
        }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- dry rules -->

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateListLiteralRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Duplicate List Literal]]></name>
    <internalKey><![CDATA[DuplicateListLiteral]]></internalKey>
    <description><![CDATA[<p>This rule checks for duplicate <em>List</em> literals within the current class. This rule only checks for <em>List</em>s
where values are all constants or literals.</p>
<p>List literals within annotations are ignored.</p>
<p>Code containing duplicate <em>List</em> literals can usually be improved by declaring the <em>List</em> as a constant field.</p>
<p>By default, the rule does not analyze test files. This rule sets the default value of the
<em>doNotApplyToFilesMatching</em> property to ignore file names ending in 'Spec.groovy', 'Test.groovy', 'Tests.groovy'
or 'TestCase.groovy'.</p>
<p>Examples of violations:</p>
<pre><code>      def var1 = [1, null, Boolean.FALSE, 'x', true]
      def var2 = [1, null, Boolean.FALSE, 'x', true]        // violation

      def var1 = [1, [3, 4]]
      def var2 = [1, [3,4]]     // violation

      def var1 = [123, [3, 4, [x:99], 5]]
      def var2 = [99, [3, 4, [x:99], 5]]        // violation [3, 4, [x:99], 5]
</code></pre>
<p>Examples of non-violations:</p>
<pre><code>    def name
    def var1 = [name, 'b', 'c']
    def var2 = [name, 'b', 'c']   // not a violation; name is a variable

    def var1 = [1, 7+5]
    def var2 = [1, 7+5]      // not a violation; contains a non-constant/literal expression
</code></pre>
<h3>Notes</h3>
<ul>
<li>
<p>This rule does not search across several files at once, only in the current file, and only
within the current class.</p>
</li>
<li>
<p>You can suppress the error by annotating a class or method with the <code>@SuppressWarnings('DuplicateListLiteral')</code>
annotation.</p>
</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateMapLiteralRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Duplicate Map Literal]]></name>
    <internalKey><![CDATA[DuplicateMapLiteral]]></internalKey>
    <description><![CDATA[<p>This rule checks for duplicate <em>Map</em> literals within the current class. This rule only checks for <em>Map</em>s
where the keys and values are all constants or literals.</p>
<p>Code containing duplicate <em>Map</em> literals can usually be improved by declaring the <em>Map</em> as a constant field.</p>
<p>By default, the rule does not analyze test files. This rule sets the default value of the
<em>doNotApplyToFilesMatching</em> property to ignore file names ending in 'Spec.groovy', 'Test.groovy', 'Tests.groovy'
or 'TestCase.groovy'.</p>
<p>Examples of violations:</p>
<pre><code>      def var1 = [a:1, b:null, c:Boolean.FALSE, d:'x', e:true]
      def var2 = [a:1, b:null, c:Boolean.FALSE, d:'x', e:true]      // violation

      def var1 = [a:1, b:[x:3,y:4]]
      def var2 = [a:1, b:[x:3,y:4]]     // violation

      def var1 = [a:1, b:[3,4]]
      def var2 = [a:1, b:[3,4]]     // violation

      def var1 = [null:1, 'b':2, (Boolean.FALSE):3, (4):4, (true):5]
      def var2 = [null:1, 'b':2, (Boolean.FALSE):3, (4):4, (true):5]    // violation
</code></pre>
<p>Examples of non-violations:</p>
<pre><code>    def name
    def var1 = [(name):1, b:1, c:1]
    def var2 = [(name):1, b:1, c:1]   // not a violation; name is a variable

    def var1 = [a:1, b:['x', name]]
    def var2 = [a:1, b:['x', name]]   // not a violation; name is a variable

    def var1 = [a:7+5]
    def var2 = [a:7+5]      // not a violation; contains a non-constant/literal expression
</code></pre>
<h3>Notes</h3>
<ul>
<li>
<p>This rule does not search across several files at once, only in the current file, and only
within the current class.</p>
</li>
<li>
<p>You can suppress the error by annotating a class or method with the <code>@SuppressWarnings('DuplicateMapLiteral')</code>
annotation.</p>
</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateNumberLiteralRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Number Literal]]></name>
    <internalKey><![CDATA[DuplicateNumberLiteral]]></internalKey>
    <description><![CDATA[<p>This rule checks for duplicate number literals within the current class.</p>
<p>Code containing duplicate <em>Number</em> literals can usually be improved by declaring the <em>Number</em> as a constant field.</p>
<p>By default, the rule does not analyze test files. This rule sets the default value of the
<em>doNotApplyToFilesMatching</em> property to ignore file names ending in 'Spec.groovy', 'Test.groovy', 'Tests.groovy'
or 'TestCase.groovy'.</p>
<h3>Notes</h3>
<ul>
<li>
<p>This rule ignores Long/long values within enums, because the generated code may include generated long id values
and produce false positive rule violations.</p>
</li>
<li>
<p>This rule does not search across several files at once, only in the current file, and only
within the current class.</p>
</li>
<li>
<p>You can suppress the error by annotating a class or method with the <code>@SuppressWarnings('DuplicateNumberLiteral')</code>
annotation.</p>
</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>duplicateNumberMinimumValue</key>
      <description><![CDATA[Ignore duplicate numbers less than this value]]></description>
    </param>
    <param>
      <key>ignoreNumbers</key>
      <description><![CDATA[The optional comma-separated list of numbers that should be ignored (i.e., not cause a violation).]]></description>
      <defaultValue>0,1</defaultValue>
    </param>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateStringLiteralRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate String Literal]]></name>
    <internalKey><![CDATA[DuplicateStringLiteral]]></internalKey>
    <description><![CDATA[<p>This rule checks for duplicate String literals within the current class.</p>
<p>Code containing duplicate <em>String</em> literals can usually be improved by declaring the <em>String</em> as a constant field.</p>
<p>This rule ignores (zero-length) empty strings.</p>
<p>By default, the rule does not analyze test files. This rule sets the default value of the
<em>doNotApplyToFilesMatching</em> property to ignore file names ending in 'Spec.groovy', 'Test.groovy', 'Tests.groovy'
or 'TestCase.groovy'.</p>
<h3>Notes</h3>
<ul>
<li>
<p>This rule does not search across several files at once, only in the current file, and only
within the current class.</p>
</li>
<li>
<p>You can suppress the error by annotating a class or method with the <code>@SuppressWarnings('DuplicateStringLiteral')</code>
annotation.</p>
</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>duplicateStringMinimumLength</key>
      <description><![CDATA[Ignore duplicate strings whose length is less than this value]]></description>
    </param>
    <param>
      <key>ignoreStrings</key>
      <description><![CDATA[The optional comma-separated list of Strings that should be ignored (i.e., not cause a violation).]]></description>
      <defaultValue>'' (empty string)</defaultValue>
    </param>
    <param>
      <key>ignoreStringsDelimiter</key>
      <description><![CDATA[The delimiter char for "ignoreStrings".]]></description>
      <defaultValue>, (comma)</defaultValue>
    </param>
  </rule>

  <!-- enhanced rules -->

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.design.CloneWithoutCloneableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Clone Without Cloneable]]></name>
    <internalKey><![CDATA[CloneWithoutCloneable]]></internalKey>
    <description><![CDATA[<p>The method clone() should only be declared if the class implements the Cloneable interface.</p>
<p>NOTE: This is a <a href="./codenarc-enhanced-classpath-rules.html">CodeNarc Enhanced Classpath Rule</a>.
It requires <strong>CodeNarc</strong> to have the application classes being analyzed, as well as any referenced classes, on the classpath.</p>
<p>Example of violations:</p>
<pre><code>    class ValueClass {
        ValueClass clone() {
        }
    }
</code></pre>
]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitAssertEqualsConstantActualValueRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Assert Equals Constant Actual Value]]></name>
    <internalKey><![CDATA[JUnitAssertEqualsConstantActualValue]]></internalKey>
    <description><![CDATA[<p>Reports usages of <code>org.junit.Assert.assertEquals([message,] expected, actual)</code> where the <code>actual</code> parameter
is a constant or a literal. Most likely it was intended to be the <code>expected</code> value.</p>
<p>NOTE: This is a <a href="./codenarc-enhanced-classpath-rules.html">CodeNarc Enhanced Classpath Rule</a>.
It requires <strong>CodeNarc</strong> to have the application classes being analyzed, as well as any referenced classes, on the classpath.</p>
<p>Example of violations:</p>
<pre><code>    assertEquals(result, 2)
    assertEquals(&quot;Message&quot;, result, 2)
    assertEquals(result, 2.3d, 0.5d)
    assertEquals(&quot;Message&quot;, result, 2.3d, 0.5d)
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.security.UnsafeImplementationAsMapRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unsafe Implementation As Map]]></name>
    <internalKey><![CDATA[UnsafeImplementationAsMap]]></internalKey>
    <description><![CDATA[<p>Reports incomplete interface implementations created by map-to-interface coercions.</p>
<p>By default, this rule does not apply to test files.</p>
<p>NOTE: This is a <a href="./codenarc-enhanced-classpath-rules.html">CodeNarc Enhanced Classpath Rule</a>.
It requires <strong>CodeNarc</strong> to have the application classes being analyzed, as well as any referenced classes, on the classpath.</p>
<p>Example of violations:</p>
<pre><code>    [mouseClicked: { ... }] as MouseListener
    //not all MouseListener methods are implemented which can lead to UnsupportedOperationException-s
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.enhanced.MissingOverrideAnnotationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Missing Override Annotation]]></name>
    <internalKey><![CDATA[MissingOverrideAnnotation]]></internalKey>
    <description><![CDATA[<p>Checks for methods that override a method in a superclass or implement a method in an interface but are not annotated
with <code>@Override</code>.</p>
<p>Consistent use of <code>@Override</code> annotation helps in spotting situations when the intent was to override a method but
because of a mistake in method signature that is not the case. Additionally, applying <code>@Override</code> annotation to
all overridden methods helps in spotting unnecessary methods which no longer override any methods after removing them
from superclasses or implemented interfaces because such annotated methods will cause compilation errors.</p>
<p>Example of violations:</p>
<pre><code>    class ClassOverridingToString {
        String toString() {
          &quot;ClassOverridingToString&quot;
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- exceptions rules -->

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.exceptions.CatchArrayIndexOutOfBoundsExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Array Index Out Of Bounds Exception]]></name>
    <internalKey><![CDATA[CatchArrayIndexOutOfBoundsException]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>ArrayIndexOutOfBoundsException</code>. Catching <code>ArrayIndexOutOfBoundsException</code> should
be avoided in the first place by checking the array size before accessing an array element. Catching the
exception may mask underlying errors.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchErrorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Error]]></name>
    <internalKey><![CDATA[CatchError]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>Error</code>. In most cases that is much too broad, and is also dangerous
because it can catch exceptions such as <code>ThreadDeath</code> and <code>OutOfMemoryError</code>.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Exception]]></name>
    <internalKey><![CDATA[CatchException]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>Exception</code>. In most cases that is too broad or general. It should usually
be restricted to framework or infrastructure code, rather than application code.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.exceptions.CatchIllegalMonitorStateExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Illegal Monitor State Exception]]></name>
    <internalKey><![CDATA[CatchIllegalMonitorStateException]]></internalKey>
    <description><![CDATA[<p>Dubious catching of IllegalMonitorStateException. IllegalMonitorStateException is generally only thrown in case of
a design flaw in your code (calling wait or notify on an object you do not hold a lock on).</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.exceptions.CatchIndexOutOfBoundsExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Index Out Of Bounds Exception]]></name>
    <internalKey><![CDATA[CatchIndexOutOfBoundsException]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>IndexOutOfBoundsException</code>. Catching <code>IndexOutOfBoundsException</code> should
be avoided in the first place by checking for a valid index before accessing an indexed element. Catching the
exception may mask underlying errors.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchNullPointerExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Null Pointer Exception]]></name>
    <internalKey><![CDATA[CatchNullPointerException]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>NullPointerException</code>. Catching <code>NullPointerException</code> is never
appropriate. It should be avoided in the first place with proper null checking, and it can mask underlying errors.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchRuntimeExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Runtime Exception]]></name>
    <internalKey><![CDATA[CatchRuntimeException]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>RuntimeException</code>. In most cases that is too broad or general. It should
usually be restricted to framework or infrastructure code, rather than application code.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchThrowableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Throwable]]></name>
    <internalKey><![CDATA[CatchThrowable]]></internalKey>
    <description><![CDATA[<p>Checks for catching a <code>Throwable</code>. In most cases that is much too broad, and is also dangerous
because it can catch exceptions such as <code>ThreadDeath</code> and <code>OutOfMemoryError</code>.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ConfusingClassNamedExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Confusing Class Named Exception]]></name>
    <internalKey><![CDATA[ConfusingClassNamedException]]></internalKey>
    <description><![CDATA[<p>This class is not derived from another exception, but ends with 'Exception'. This will be confusing to users of
this class.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ExceptionExtendsErrorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Exception Extends Error]]></name>
    <internalKey><![CDATA[ExceptionExtendsError]]></internalKey>
    <description><![CDATA[<p>Errors are system exceptions. Do not extend them.</p>
<p>Examples:</p>
<pre><code>    class MyError extends Error { }  // violation
    class MyError extends java.lang.Error { }  // violation

    class MyException extends Exception { }  // OK
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ExceptionExtendsThrowableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Exception Extends Throwable]]></name>
    <internalKey><![CDATA[ExceptionExtendsThrowable]]></internalKey>
    <description><![CDATA[<p>Checks for classes that extend <code>Throwable</code>. Custom exception classes should subclass <code>Exception</code>
or one of its descendants.</p>
<p>Example of violations:</p>
<pre><code>    class MyException extends Throwable { }   // violation
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ExceptionNotThrownRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Exception Not Thrown]]></name>
    <internalKey><![CDATA[ExceptionNotThrown]]></internalKey>
    <description><![CDATA[<p>Checks for an exception constructor call without a <code>throw</code> as the last statement within a catch block.
This rule treats any constructor call for a class named <em>xxx</em><strong>Exception</strong> as an exception constructor call.</p>
<p>Example of violations:</p>
<pre><code>    void execute() {
        try { } catch(Exception e) { new Exception(e) }     // violation
    }

    try {
        doStuff()
    } catch(DaoException e) {
        log.warning(&quot;Ooops&quot;, e)
        new ServiceException(e)                             // violation
    } catch(Exception e) {
        new SystemException(e)                              // violation
    }

    try {
        doStuff()
    } catch(Exception e) { throw new DaoException(e) }      // ok
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.exceptions.MissingNewInThrowStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Missing New In Throw Statement]]></name>
    <internalKey><![CDATA[MissingNewInThrowStatement]]></internalKey>
    <description><![CDATA[<p>A common Groovy mistake when throwing exceptions is to forget the new keyword. For instance, <code>throw RuntimeException()</code>
instead of <code>throw new RuntimeException()</code>. If the error path is not unit tested then the production system will
throw a Method Missing exception and hide the root cause. This rule finds constructs like <code>throw RuntimeException()</code> that
look like a new keyword was meant to be used but forgotten.</p>
<p>The following code will all cause violations:</p>
<pre><code>    throw RuntimeException()    // ends in Exceptions, first letter Capitalized
    throw RuntimeFailure()      // ends in Failure, first letter Capitalized
    throw RuntimeFault(foo)     // ends in Fault, first letter Capitalized
</code></pre>
<p>The following code will not cause any exceptions:</p>
<pre><code>    throw new RuntimeException()
    throw runtimeFailure()      // first letter lowercase, assumed to be method call
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ReturnNullFromCatchBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Return Null From Catch Block]]></name>
    <internalKey><![CDATA[ReturnNullFromCatchBlock]]></internalKey>
    <description><![CDATA[<p>Returning null from a catch block often masks errors and requires the client to handle error codes. In some coding
styles this is discouraged. This rule ignores methods with <code>void</code> return type.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.exceptions.SwallowThreadDeathRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Swallow Thread Death]]></name>
    <internalKey><![CDATA[SwallowThreadDeath]]></internalKey>
    <description><![CDATA[<p>Example of violations:</p>
<pre><code>    try {
        def a = 0
    } catch (ThreadDeath td) {
        td.printStackTrace()
    }
</code></pre>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowErrorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Error]]></name>
    <internalKey><![CDATA[ThrowError]]></internalKey>
    <description><![CDATA[<p>Checks for throwing an instance of <code>java.lang.Error</code>. This is not appropriate within
normal application code. Throw an instance of a more specific exception subclass instead.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Exception]]></name>
    <internalKey><![CDATA[ThrowException]]></internalKey>
    <description><![CDATA[<p>Checks for throwing an instance of <code>java.lang.Exception</code>. Throw an instance of a more
specific exception subclass instead.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowNullPointerExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Null Pointer Exception]]></name>
    <internalKey><![CDATA[ThrowNullPointerException]]></internalKey>
    <description><![CDATA[<p>Checks for throwing an instance of <code>java.lang.NullPointerException</code>. Applications should never
throw a <code>NullPointerException</code>.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowRuntimeExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Runtime Exception]]></name>
    <internalKey><![CDATA[ThrowRuntimeException]]></internalKey>
    <description><![CDATA[<p>Checks for throwing an instance of <code>java.lang.RuntimeException</code>. Throw an instance of a more
specific exception subclass instead.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowThrowableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Throwable]]></name>
    <internalKey><![CDATA[ThrowThrowable]]></internalKey>
    <description><![CDATA[<p>Checks for throwing an instance of <code>java.lang.Throwable</code>. Throw an instance of a more
specific exception subclass instead.</p>
]]></description>
    <tag>error-handling</tag>
  </rule>

  <!-- formatting rules -->

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.BlankLineBeforePackageRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Blank Line Before Package]]></name>
    <internalKey><![CDATA[BlankLineBeforePackage]]></internalKey>
    <description><![CDATA[<p>Makes sure there are no blank lines before the package declaration of a source code file.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.BlockEndsWithBlankLineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Block Ends With Blank Line]]></name>
    <internalKey><![CDATA[BlockEndsWithBlankLine]]></internalKey>
    <description><![CDATA[<p>Checks that code blocks such as method bodies, closures and control structure bodies do not end with an empty line.</p>
<p>Example of violations:</p>
<pre><code>    boolean not(boolean value) {
        !value
                                // violation
    }

    3.times {
        println 'hello!'
                                // violation
    }

    for (value in []) {
        println value
                                // violation
    }

    for (i = 0; i * 3; i++) {
        println i
                                // violation
    }

    int j = 0
    while (j * 3) {
      println j++
                                // violation
    }

    if (ready) {
        println 'ready'
                                // violation
    } else {
        println 'not ready'
                                // violation
    }

    try {
        throw new Exception()
                                // violation
    } catch (Exception e) {
        println 'exception'
                                // violation
    } finally {
        println 'finally'
                                // violation
    }

    switch (true) {
        default:
            println 'switch'
                                // violation
    }

    // Known Limitation: If a Closure is within another expression and the closing brace is not followed by anything else on the same line

    def list = [
        123,
        { id -*
                                // Known limitation: should be a violation, but is not
        }
    ]
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.BlockStartsWithBlankLineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Block Starts With Blank Line]]></name>
    <internalKey><![CDATA[BlockStartsWithBlankLine]]></internalKey>
    <description><![CDATA[<p>Checks that code blocks such as method bodies, closures and control structure bodies do not start with an empty line.</p>
<p>Example of violations:</p>
<pre><code>    boolean not(boolean value) {
                                // violation
        !value
    }

    3.times {
                                // violation
        println 'hello!'
    }

    for (value in []) {
                                // violation
        println value
    }

    for (i = 0; i * 3; i++) {
                                // violation
        println i
    }

    int j = 0
    while (j * 3) {
                                // violation
      println j++
    }

    if (ready) {
                                // violation
        println 'ready'
    } else {
                                // violation
        println 'not ready'
    }

    try {
                                // violation
        throw new Exception()
    } catch (Exception e) {
                                // violation
        println 'exception'
    } finally {
                                // violation
        println 'finally'
    }

    switch (true) {
                                // violation
        default:
            println 'switch'
    }

</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For Class]]></name>
    <internalKey><![CDATA[BracesForClass]]></internalKey>
    <description><![CDATA[<p>Checks the location of the opening brace ({) for classes. By default, requires them on the same
line, but the <code>sameLine</code> property can be set to false to override this.</p>
<p>NOTE: This rule ignores annotation types, e.g. <code>@interface MyAnnotation {}</code>.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForForLoopRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For For Loop]]></name>
    <internalKey><![CDATA[BracesForForLoop]]></internalKey>
    <description><![CDATA[<p>Checks the location of the opening brace ({) for for loops. By default, requires them on the same line, but the
<code>sameLine</code> property can be set to false to override this.</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForIfElseRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For If Else]]></name>
    <internalKey><![CDATA[BracesForIfElse]]></internalKey>
    <description><![CDATA[<p>Checks the location of the opening brace ({) for if statements. By default, requires them on the same
line, but the <code>sameLine</code> property can be set to false to override this.</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>elseOnSameLineAsClosingBrace</key>
      <description><![CDATA[If "true", then the else statement should be on the same line the same as sameLine as closing brace (})]]></description>
      <defaultValue>the same as sameline</defaultValue>
    </param>
    <param>
      <key>elseOnSameLineAsOpeningBrace</key>
      <description><![CDATA[If "true", then the else statement should be on the same line the same as sameLine as opening brace ({)]]></description>
      <defaultValue>the same as sameline</defaultValue>
    </param>
    <param>
      <key>sameLine</key>
      <description><![CDATA[If "true", then the opening brace ({) for if statement should be on the same line.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>validateElse</key>
      <description><![CDATA[To enable else checking, set the property to "true"]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For Method]]></name>
    <internalKey><![CDATA[BracesForMethod]]></internalKey>
    <description><![CDATA[<p>Checks the location of the opening brace ({) for constructors and methods. By default, requires them on the same
line, but the <code>sameLine</code> property can be set to false to override this.</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForTryCatchFinallyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For Try Catch Finally]]></name>
    <internalKey><![CDATA[BracesForTryCatchFinally]]></internalKey>
    <description><![CDATA[<p>Checks the location of the opening brace ({) for try statements. By default, requires them on the line, but the <code>sameLine</code> property can be set to false to override this.</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.formatting.ClassEndsWithBlankLineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Class Ends With Blank Line]]></name>
    <internalKey><![CDATA[ClassEndsWithBlankLine]]></internalKey>
    <description><![CDATA[<p>Check whether the class ends with a blank line. By default, it enforces that there must be a blank line before
the closing class brace, except:</p>
<ul>
<li>If the class is synthetic (generated)</li>
<li>If the class is empty and is written in a single line</li>
<li>If the class is a Script class</li>
</ul>
<p>A blank line is defined as any line that does not contain any visible characters.</p>
<p>This rule can be configured with the following properties:</p>
<p>Example of violations:</p>
<p>If <em>ignoreSingleLineClasses</em> is <code>true</code> and <em>blankLineRequired</em> is <code>true</code></p>
<pre><code>            class Foo {
                int a

                void hi() {
                }
            }
</code></pre>
<p>If <em>ignoreSingleLineClasses</em> is <code>false</code> and <em>blankLineRequired</em> is <code>true</code></p>
<pre><code>            class Foo extends Bar*String* { }
</code></pre>
<p>If <em>ignoreSingleLineClasses</em> is <code>true</code> and <em>blankLineRequired</em> is <code>false</code></p>
<pre><code>            class Foo {
                int a

                void hi() {
                }

            }
</code></pre>
<p>If <em>ignoreSingleLineClasses</em> is <code>false</code> and <em>blankLineRequired</em> is <code>false</code></p>
<pre><code>            class Foo {
                int a

                void hi() {
                }

            }
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>blankLineRequired</key>
      <description><![CDATA[a boolean property to define if there may be a blank line before the closing class brace. If it is false, the last line before the brace must not be blank. Otherwise, it must be blank.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreInnerClasses</key>
      <description><![CDATA[A boolean property to ignore inner classes. If it is false then inner classes can cause violations.]]></description>
      <defaultValue>false</defaultValue>
    </param>
    <param>
      <key>ignoreSingleLineClasses</key>
      <description><![CDATA[a boolean property to forbid single line classes.If it is false,then single line classes are considered a violation.]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.formatting.ClassStartsWithBlankLineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Class Starts With Blank Line]]></name>
    <internalKey><![CDATA[ClassStartsWithBlankLine]]></internalKey>
    <description><![CDATA[<p>Check whether the class starts with a blank line. By default, it enforces that there must be a blank line after
the opening class brace, except:</p>
<ul>
<li>
<p>If the class is synthetic (generated)</p>
</li>
<li>
<p>If the class is empty and is written in a single line</p>
</li>
<li>
<p>If the class is a Script class</p>
</li>
</ul>
<p>A blank line is defined as any line that does not contain any visible characters.</p>
<p>This rule can be configured with the following properties:</p>
<p>Example of violations:</p>
<p>If <em>ignoreSingleLineClasses</em> is <code>true</code> and <em>blankLineRequired</em> is <code>true</code></p>
<pre><code>            class Foo {
                int a

                void hi() {
                }
            }
</code></pre>
<p>If <em>ignoreSingleLineClasses</em> is <code>false</code> and <em>blankLineRequired</em> is <code>true</code></p>
<pre><code>            class Foo extends Bar*String* { }
</code></pre>
<p>If <em>ignoreSingleLineClasses</em> is <code>true</code> and <em>blankLineRequired</em> is <code>false</code></p>
<pre><code>            class Foo {

                int a

                void hi() {
                }

            }
</code></pre>
<p>If <em>ignoreSingleLineClasses</em> is <code>false</code> and <em>blankLineRequired</em> is <code>false</code></p>
<pre><code>            class Foo {
                int a

                void hi() {
                }

            }
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>blankLineRequired</key>
      <description><![CDATA[A boolean property to define if there may be a blank line after the opening class brace. If it is false, the first content after the brace must not be a blank line. Otherwise, it must be a blank line.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreInnerClasses</key>
      <description><![CDATA[A boolean property to ignore inner classes. If it is false then inner classes can cause violations.]]></description>
      <defaultValue>false</defaultValue>
    </param>
    <param>
      <key>ignoreSingleLineClasses</key>
      <description><![CDATA[A boolean property to ignore single line classes. If it is false, then single line classes are considered a violation.]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.formatting.ClosureStatementOnOpeningLineOfMultipleLineClosureRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Closure Statement On Opening Line Of Multiple Line Closure]]></name>
    <internalKey><![CDATA[ClosureStatementOnOpeningLineOfMultipleLineClosure]]></internalKey>
    <description><![CDATA[<p>Checks for closure logic on first line (after <code>-\</code>*) for a multi-line closure. That breaks the symmetry
of indentation (if the subsequent statements are indented normally), and that first statement can be easily
missed when reading the code.</p>
<p>Example of violations:</p>
<pre><code>    def closure = { name -* println name
        addToCounts()
        println â€œdoneâ€ }
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.ConsecutiveBlankLinesRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Consecutive Blank Lines]]></name>
    <internalKey><![CDATA[ConsecutiveBlankLines]]></internalKey>
    <description><![CDATA[<p>Makes sure there are no consecutive lines that are either blank or whitespace only. This reduces the need to scroll
further than necessary when reading code, and increases the likelihood that a logical block of code will fit on one
screen for easier comprehension.</p>
<p>Example of violation:</p>
<pre><code>    def name


    def value



    def id
</code></pre>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.FileEndsWithoutNewlineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[File Ends Without Newline]]></name>
    <internalKey><![CDATA[FileEndsWithoutNewline]]></internalKey>
    <description><![CDATA[<p>Makes sure each source file ends with a newline character.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 1.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.IndentationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Indentation]]></name>
    <internalKey><![CDATA[Indentation]]></internalKey>
    <description><![CDATA[<p>Check the indentation (spaces only; not tabs) for class, field and method declarations, and statements.</p>
<p>This rule is limited, and somewhat opinionated. The default is 4 spaces per indentation level.</p>
<p>Known Limitations include:</p>
<ul>
<li>Checks spaces only (not tabs)</li>
<li>Does not check comments</li>
<li>Does not check line-continuations (i.e., checks only the first line of a statement)</li>
<li>Does not check multiple statements/members on the same line (only checks the first one)</li>
<li>Does not check Map entry expressions</li>
<li>Does not check List expressions</li>
<li>Does not check calls to <code>this()</code> and <code>super()</code> within a constructor</li>
<li>When classes, methods or fields have annotations, the indentation of the annotation is checked, not the actual member. And only the first annotation is checked, if there is more than one.</li>
</ul>
<p>Example of violations:</p>
<pre><code>// Indent Levels:
0...1...2...3...4...5

class MyClass {                                 // CORRECT
    protected int count                         // CORRECT
  private static final NAME = &quot;Joe&quot;             // violation
           def max, min                         // violation on &quot;max&quot; only

 private String doStuff() {                     // violation
        def internalCounts = [1, 4, 2]          // CORRECT
            id.trim()                           // violation
    }

    private void executeOtherOne() {            // CORRECT
        try {
          executeWithArgs(args)                 // violation
        } catch(Throwable t) {
                       t.printStackTrace()      // violation
        }
        finally {
                closeResources()                // violation
        }
    }
}
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>spacesPerIndentLevel</key>
      <description><![CDATA[The number of spaces that make up a single level of indentation.]]></description>
      <defaultValue>4</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.LineLengthRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Line Length]]></name>
    <internalKey><![CDATA[LineLength]]></internalKey>
    <description><![CDATA[<p>Checks the maximum length for each line of source code. It checks for number of characters, so lines that
include tabs may appear longer than the allowed number when viewing the file. The maximum line length can
be configured by setting the length property, which defaults to 120.</p>
<p>NOTE: This rule does not support the @SuppressAnnotations annotation or the classname-based rule properties
(applyToClassNames, doNotApplyToClassNames) to enable/disable the rule. If you want to specify or restrict
where this rule is applied, you must use the file-based rule properties: applyToFileNames, doNotApplyToFileNames,
applyToFilesMatching and doNotApplyToFilesMatching.</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>ignoreImportStatements</key>
      <description><![CDATA[If "true", then do not apply this rule to import statements.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreLineRegex</key>
      <description><![CDATA[If specified, then ignore lines matching this regular expression.]]></description>
    </param>
    <param>
      <key>ignorePackageStatements</key>
      <description><![CDATA[If "true", then do not apply this rule to package statements.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>length</key>
      <description><![CDATA[The maximum line length allowed.]]></description>
      <defaultValue>120</defaultValue>
    </param>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.MissingBlankLineAfterImportsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Missing Blank Line After Imports]]></name>
    <internalKey><![CDATA[MissingBlankLineAfterImports]]></internalKey>
    <description><![CDATA[<p>Makes sure there is a blank line after the imports of a source code file.</p>
<p>Example of violation:</p>
<pre><code>    import org.apache.commons.lang.StringUtils
    class MyClass { }                       // violation
</code></pre>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.MissingBlankLineAfterPackageRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Missing Blank Line After Package]]></name>
    <internalKey><![CDATA[MissingBlankLineAfterPackage]]></internalKey>
    <description><![CDATA[<p>Makes sure there is a blank line after the package statement of a source code file.</p>
<p>Example of violation:</p>
<pre><code>  package org.codenarc
  import java.util.Date                     // violation

  class MyClass {
      void go() { /* ... */ }
  }
</code></pre>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 2.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.MissingBlankLineBeforeAnnotatedFieldRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Missing Blank Line Before Annotated Field]]></name>
    <internalKey><![CDATA[MissingBlankLineBeforeAnnotatedField]]></internalKey>
    <description><![CDATA[<p>Checks that there is a blank line before a field declaration that uses annotations.</p>
<p>Ignore field declarations where:</p>
<ul>
<li>The previous line contains a comment</li>
<li>The declaration (annotations) start on the first line of the class</li>
<li>All annotations are on the same line as the field declaration.</li>
</ul>
<p>Examples of violations:</p>
<pre><code>    class MyClass {
        // No violations for field declarations preceded by a comment
        @Delegate
        AutoCloseable stream
        
        String publicField                  // violation
        @PackageScope
        String packageScopedField
    }
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 2.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterMethodDeclarationNameRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Method Declaration Name]]></name>
    <internalKey><![CDATA[SpaceAfterMethodDeclarationName]]></internalKey>
    <description><![CDATA[<p>Check whether method declarations do not contain unnecessary whitespace between method name and the opening parenthesis
for parameter list.</p>
<p>Examples of violations:</p>
<pre><code>    class ClassWithWhitespaceInConstructorDeclaration {
        
        ClassWithWhitespaceInConstructorDeclaration () { //violation
        }
        
        void methodWithWhitespaceInDeclaration () { //violation
        }
    }
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 2.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterMethodCallNameRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Method Call Name]]></name>
    <internalKey><![CDATA[SpaceAfterMethodCallName]]></internalKey>
    <description><![CDATA[<p>Checks that there is no whitespace after the method name when a method call contains parenthesis or that there
is at most one space after the method name if the call does not contain parenthesis.</p>
<p>Examples of violations:</p>
<pre><code>    aMethod (&quot;arg&quot;) //violation
    
    aMethod  &quot;arg&quot; //violation
    
    throw new Exception () //violation
    
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterCatchRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Catch]]></name>
    <internalKey><![CDATA[SpaceAfterCatch]]></internalKey>
    <description><![CDATA[<p>Check that there is exactly one space (blank) after the <code>catch</code> keyword and before the opening parenthesis.</p>
<p>Examples of violations:</p>
<pre><code>    try { } catch(Exception e) { }          // violation
    try { } catch  (Exception e) { }        // violation
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterCommaRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Comma]]></name>
    <internalKey><![CDATA[SpaceAfterComma]]></internalKey>
    <description><![CDATA[<p>Checks that there is at least one space or whitespace following each comma. That includes checks for method
and closure declaration parameter lists, method call parameter lists, Map literals and List literals.</p>
<p>Known limitations:</p>
<ul>
<li>May not catch actual violations if the source line contains unicode character literals, e.g. <code>'\\u00A0'</code></li>
</ul>
<p>Examples of violations:</p>
<pre><code>    def value = calculate(1,399, 'abc')         // violation on parameter 399

    def method1(int a,String b) { }             // violation on parameter b

    def closure1 = { int a,String b -* }        // violation on parameter b

    def list1 = [a,b, c]                        // violation on list element b

    def map1 = [a:1,b:2, c:3]                   // violation on map element b:2
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterClosingBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Closing Brace]]></name>
    <internalKey><![CDATA[SpaceAfterClosingBrace]]></internalKey>
    <description><![CDATA[<p>Check that there is at least one space (blank) or whitespace after each closing brace (&quot;{&quot;) for
method/class/interface declarations, closure expressions and block statements.</p>
<p>A closure expression followed by a dot operator (.), a comma, an opening parenthesis, a closing parenthesis, an
opening square brace, a closing square brace (]), the spread-dot operator (*.), a semicolon or the
null-safe operator (?.) does not cause a violation.</p>
<p>Known limitations:</p>
<ul>
<li>May not catch actual violations if the source line contains unicode character literals, e.g. <code>'\\u00A0'</code></li>
</ul>
<p>Examples of violations and exceptions:</p>
<pre><code>    if (ready) { return 9 }else { }             // violation
    try { doStuff() }finally { }                // violation

    def matching = list.find { it.isReady() }.filter()  // no violation for dot operator
    assert list.every { it.isReady() }, &quot;Error&quot;         // no violation for comma
    def m = [a:123, b:{ println 7 },c:99]               // no violation for comma
    closures.find { c -* c }()                          // no violation for opening parenthesis
    processItems(list.select { it.isReady() })          // no violation for closing parenthesis
    maps.find { m -* m[index] }[index]                  // no violation for opening square bracket
    processItems([{ named(&quot;a&quot;) }, { named(&quot;b&quot;)}])       // no violation for closing square bracket
    def names = records.findAll { it.age * 1 }*.name    // no violation for spread operator
    list?.collect { it?.type }?.join(',')               // no violation for null-safe operator
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>checkClosureMapEntryValue</key>
      <description><![CDATA[DEPRECATED. Ignored.]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterForRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After For]]></name>
    <internalKey><![CDATA[SpaceAfterFor]]></internalKey>
    <description><![CDATA[<p>Check that there is exactly one space (blank) after the <code>for</code> keyword and before the opening parenthesis.</p>
<p>Examples of violations:</p>
<pre><code>    for(name in names) { }                  // violation
    for  (int i=0; i * 10; i++) { }         // violation
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterIfRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After If]]></name>
    <internalKey><![CDATA[SpaceAfterIf]]></internalKey>
    <description><![CDATA[<p>Check that there is exactly one space (blank) after the <code>if</code> keyword and before the opening parenthesis.</p>
<p>Examples of violations:</p>
<pre><code>    if(true) { }                            // violation
    if  (true) { }                          // violation
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 2.1 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterNotOperatorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Not Operator]]></name>
    <internalKey><![CDATA[SpaceAfterNotOperator]]></internalKey>
    <description><![CDATA[<p>Check that there are no whitespace characters directly after the not (!) operator.</p>
<p>Examples of violations:</p>
<pre><code>    def negatedValue = ! value //violation
    
    if (! items.empty()) { println &quot;not empty&quot; } //violataion
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterOpeningBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Opening Brace]]></name>
    <internalKey><![CDATA[SpaceAfterOpeningBrace]]></internalKey>
    <description><![CDATA[<p>Check that there is at least one space (blank) or whitespace after each opening brace (&quot;{&quot;) for
method/class/interface declarations, closure expressions and block statements.</p>
<p>Examples of violations:</p>
<pre><code>    class MyClass{int count }                   // violation

    interface MyInterface {static final OK = 1 }// violation

    enum MyEnum {OK, BAD }                      // violation

    def myMethod() {int count }                 // violation

    if (ready) {println 9 }                     // violation

    if (ready) {
    } else {println 99}                         // violation

    for (int i=0; i*10; i++) {println i }       // violation

    for (String name in names) {println name }  // violation

    for (String name: names) {println name }    // violation

    while (ready) {println time }               // violation

    try {doStuff()                              // violation
    } catch(Exception e) {x=77 }                // violation
    } finally {println 'error' }                // violation

    list.each {name -* }                        // violation

    shouldFail(Exception) {doStuff() }          // violation
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>checkClosureMapEntryValue</key>
      <description><![CDATA[If "false", then do not check for whitespace after opening braces for closure expressions that are literal Map values, e.g. "[abc:\{doStuff()\}]".]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreEmptyBlock</key>
      <description><![CDATA[If "true", then allow for "\{\}" in code]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterSemicolonRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Semicolon]]></name>
    <internalKey><![CDATA[SpaceAfterSemicolon]]></internalKey>
    <description><![CDATA[<p>Check that there is at least one space (blank) or whitespace following a semicolon that separates:</p>
<ul>
<li>multiple statements on a single line</li>
<li>the clauses within a classic for loop, e.g. for (i=0;i*10;i++)</li>
</ul>
<p>Examples of violations:</p>
<pre><code>    def myMethod() {
        println 1;println 2                         // violation
        def closure = { x -* doStuff();x = 23; }    // violation

        for (int i=0;i * 10;i++) {                  // violations (2)
            for (int j=0; j * 10;j++) { }           // violation
        }
    }
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterSwitchRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Switch]]></name>
    <internalKey><![CDATA[SpaceAfterSwitch]]></internalKey>
    <description><![CDATA[<p>Check that there is exactly one space (blank) after the <code>switch</code> keyword and before the opening parenthesis.</p>
<p>Examples of violations:</p>
<pre><code>    switch(x) {                                 // violation
        case 1: println 'one'
    }
    switch  (x) {                               // violation
        case 1: println 'one'
    }
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterWhileRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After While]]></name>
    <internalKey><![CDATA[SpaceAfterWhile]]></internalKey>
    <description><![CDATA[<p>Check that there is exactly one space (blank) after the <code>while</code> keyword and before the opening parenthesis.</p>
<p>Examples of violations:</p>
<pre><code>    while(true) { }             // violation
    while  (true) { }           // violation
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAroundClosureArrowRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Around Closure Arrow]]></name>
    <internalKey><![CDATA[SpaceAroundClosureArrow]]></internalKey>
    <description><![CDATA[<p>Checks that there is at least one space (blank) or whitespace around each closure arrow (-*) symbol.</p>
<p>Known limitations:</p>
<ul>
<li>Does not catch violations if the closure arrow (-*) is on a separate line from the start of the closure.</li>
</ul>
<p>Example of violations:</p>
<pre><code>    def closure1 = {-*}                             // violation
    def closure2 = { -*}                            // violation
    def closure3 = {-* }                            // violation
    def closure4 = { count-* println 123 }          // violation
    def closure5 = { count, name -*println 123 }    // violation
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAroundMapEntryColonRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Around Map Entry Colon]]></name>
    <internalKey><![CDATA[SpaceAroundMapEntryColon]]></internalKey>
    <description><![CDATA[<p>Check for proper formatting of whitespace around colons for literal Map entries. By default, no whitespace
is allowed either before or after the Map entry colon, but you can change that through the configuration
properties below.</p>
<p>Does not check <em>spread map</em> operator, e.g. <code>def binding = [*: map]</code></p>
<p>Example of violations:</p>
<pre><code>    Map m1 = [myKey : 12345]            // violation (both before and after the colon)
    println [a :[1:11, 2:22],           // violation on a (before colon)
                b:[(Integer): 33]]      // violation on Integer (after colon)
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>characterAfterColonRegex</key>
      <description><![CDATA[The regular expression that must match the character after the colon (:) for a literal Map entry. For example, "/\S/" matches any non-whitespace character and "/\s/" matches any whitespace character (thus requiring a space or whitespace).]]></description>
      <defaultValue>/\S/ (i.e., no space allowed after the colon)</defaultValue>
    </param>
    <param>
      <key>characterBeforeColonRegex</key>
      <description><![CDATA[The regular expression that must match the character before the colon (:) for a literal Map entry. For example, "/\S/" matches any non-whitespace character and "/\s/" matches any whitespace character (thus requiring a space or whitespace).]]></description>
      <defaultValue>/\S/ (i.e., no space allowed before the colon)</defaultValue>
    </param>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAroundOperatorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Around Operator]]></name>
    <internalKey><![CDATA[SpaceAroundOperator]]></internalKey>
    <description><![CDATA[<p>Check that there is at least one space (blank) or whitespace around each binary operator,
including: +, -, *, /, **, **, &amp;&amp;, ||, &amp;, |, ?:, =, &quot;as&quot;.</p>
<p>Do not check dot ('.') operator. Do not check unary operators (!, +, -, ++, --, ?.).
Do not check array ('[') operator.</p>
<p>Known limitations:</p>
<ul>
<li>Does not catch violations of certain ternary expressions and standalone elvis operator (?:) expressions.</li>
<li>Does not catch violations of missing space around the equals operator (=) for fields initialization if the field is annotated.</li>
</ul>
<p>Examples of violations:</p>
<pre><code>    def myMethod() {
        3+ 5-x*23/ 100              // violation
        list \*\*123                // violation
        other\*\* writer            // violation
        x=99                        // violation
        x&amp;&amp; y                       // violation
        x ||y                       // violation
        x &amp;y                        // violation
        x| y                        // violation
        [1,2]as String              // violation
    }
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>ignoreParameterDefaultValueAssignments</key>
      <description><![CDATA[If "true", then do not check for whitespace around the '=' operator within method/constructor default parameter assignments.]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceBeforeClosingBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Before Closing Brace]]></name>
    <internalKey><![CDATA[SpaceBeforeClosingBrace]]></internalKey>
    <description><![CDATA[<p>Check that there is at least one space (blank) or whitespace before each closing brace (&quot;}&quot;) for
method/class/interface declarations, closure expressions and block statements.</p>
<p>Known limitations:</p>
<ul>
<li>May not catch actual violations if the source line contains unicode character literals, e.g. <code>'\\u00A0'</code></li>
</ul>
<p>Examples of violations:</p>
<pre><code>    class MyClass { int count}                  // violation

    interface MyInterface { void doStuff()}     // violation

    enum MyEnum { OK, BAD}                      // violation

    def myMethod() { return 9}                  // violation

    if (ready) { doStuff()}                     // violation

    if (ready) {
    } else { return 9}                          // violation

    for (int i=0; i*10; i++) { println i}       // violation

    for (String name in names) { println name}  // violation

    for (String name: names) { println name}    // violation

    while (ready) { doStuff()}                  // violation

    try { doStuff()}                            // violation
    catch(Exception e) { logError(e)}           // violation
    finally { cleanUp()}                        // violation

    list.each { name -* println name}           // violation

    shouldFail(Exception) { doStuff()}          // violation
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>checkClosureMapEntryValue</key>
      <description><![CDATA[If "false", then do not check for whitespace before closing braces for closure expressions that are literal Map values, e.g. "[abc:\{doStuff()\}]".]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreEmptyBlock</key>
      <description><![CDATA[If "true", then allow for "\{\}" in code]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceBeforeOpeningBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Before Opening Brace]]></name>
    <internalKey><![CDATA[SpaceBeforeOpeningBrace]]></internalKey>
    <description><![CDATA[<p>Check that there is at least one space (blank) or whitespace before each opening brace (&quot;{&quot;) for
method/class/interface declarations, closure expressions and block statements.</p>
<p>A closure expression a preceded by an opening parenthesis, an opening square
brace ([), or a dollar sign ($) within a GString does not cause a violation.</p>
<p>Known limitations:</p>
<ul>
<li>May not catch actual violations if the source line contains unicode character literals, e.g. <code>'\\u00A0'</code></li>
</ul>
<p>Examples of violations:</p>
<pre><code>    class MyClass{ }                            // violation
    class MyOtherClass extends AbstractClass{ } // violation

    interface MyInterface{ }                    // violation

    enum MyEnum{ OK, BAD }                      // violation

    def myMethod(){ }                           // violation

    if (ready){ }                               // violation

    if (ready) {
    } else{}                                    // violation

    for (int i=0; i*10; i++){ }                 // violation

    for (String name in names){ }               // violation

    for (String name: names){ }                 // violation

    while (ready){ }                            // violation

    try{
    } finally { }                               // violation

    try {
    } catch(Exception e){ }                     // violation

    try {
    } finally{ }                                // violation

    list.each{ name -* }                        // violation

    shouldFail(Exception){ doStuff() }          // violation
</code></pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>checkClosureMapEntryValue</key>
      <description><![CDATA[If "false", then do not check for whitespace before opening braces for closure expressions that are literal Map values, e.g. "[abc:\{doStuff()\}]".]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 2.1.0 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceInsideParenthesesRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Inside Parentheses]]></name>
    <internalKey><![CDATA[SpaceInsideParentheses]]></internalKey>
    <description><![CDATA[<p>Check for whitespace after opening parentheses and before closing parentheses</p>
<p>Example of violations:</p>
<pre><code>    if( running) { }                        // violation
    if(running ) { }                        // violation
    if(      x &lt; calculateLastIndex(        // violation
            'name') + 1    ) { }            // violation
            
    for(    String name: filterNames(       // violation
            names)   ) { }                  // violation

    println( 123 )                          // violations

    println (3 + ( 4 * 7 )+7) + (   5 * 1 ) // violations
    def v =  (y - 7 )*( x + (z - 3))        // violations
    def v2 =  (y - 7 ) *                    // violation
        (x + 
        ( z - 3)                            // violation
        )
    def v3 = calc(a) + calc( a + ( b - 1) * 2) + calc(7)  // violation
    def v4 = (a ) ? (17) : (19 )            // violation
    
    void doStuff( int n) { }                // violation
</code></pre>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.TrailingWhitespaceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Trailing Whitespace]]></name>
    <internalKey><![CDATA[TrailingWhitespace]]></internalKey>
    <description><![CDATA[<p>Checks that no lines of source code end with whitespace characters.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>convention</tag>
  </rule>

  <!-- generic rules -->

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalClassMemberRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Class Member]]></name>
    <internalKey><![CDATA[IllegalClassMember]]></internalKey>
    <description><![CDATA[<p>Checks for classes containing fields/properties/methods matching configured illegal member
modifiers or not matching any of the configured allowed member modifiers.</p>
<p>Modifiers for fields and methods include:</p>
<ul>
<li>public</li>
<li>protected</li>
<li>private</li>
<li>static</li>
<li>final</li>
<li>volatile (fields only)</li>
<li>transient (fields only)</li>
</ul>
<p>Modifiers for properties are only:</p>
<ul>
<li>static</li>
<li>final</li>
</ul>
<p>Note that you must use the standard rule properties, such as <code>applyToClassNames</code>, <code>doNotApplyToFileNames</code>
and <code>applyToFilesMatching</code> to apply this rule to a subset of all classes/files. These rule properties
are described in
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>Example of violations for methods:</p>
<pre><code>    // IllegalClassMember.allowedMethodModifiers = 'public final, private, protected static'

    class MyClass {
        public method1() { }            // violation
        protected method2() { }         // violation
        protected static method3() { }
    }
</code></pre>
<p>Example of violations for properties:</p>
<pre><code>    // IllegalClassMember.illegalPropertyModifiers = 'final'

    class MyClass {
        def property1
        final property2         // violation
        static property3
    }
</code></pre>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>classNames</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
<h3>Notes</h3>
<ol>
<li>
<p>At least one the <code>illegalFieldModifiers</code>, <code>allowedFieldModifiers</code>, <code>illegalPropertyModifiers</code>,
<code>allowedPropertyModifiers</code>, <code>illegalMethodModifiers</code> or <code>allowedMethodModifiers</code>
properties must be set (i.e., not null or empty) or else this rule does nothing. In other words, you must configure
this rule with at least one kind of illegal or allowed class member.</p>
</li>
<li>
<p>At least one of the (standard) <code>applyToClassNames</code>, <code>applyToFileNames</code> or <code>applyToFilesMatching</code>
properties must be set (i.e., not null or empty) or else this rule does nothing. In other words, you must configure
this rule to apply to a specific set of classes or files.</p>
</li>
</ol>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowedFieldModifiers</key>
      <description><![CDATA[Specifies one or more groups of whitespace-delimited modifier names (e.g. "public static" or "protected"). Multiple groups are separated by commas (e.g. "private final, protected"). If a field does not match all of the modifiers in any group, then trigger a violation. If "null" or empty, skip this check.]]></description>
    </param>
    <param>
      <key>allowedMethodModifiers</key>
      <description><![CDATA[Specifies one or more groups of whitespace-delimited modifier names (e.g. "public static" or "protected"). Multiple groups are separated by commas (e.g. "private final, protected"). If a method does not match all of the modifiers in any group, then trigger a violation. If "null" or empty, skip this check.]]></description>
    </param>
    <param>
      <key>allowedPropertyModifiers</key>
      <description><![CDATA[Specifies one or more groups of whitespace-delimited modifier names (e.g. "public static" or "protected"). Multiple groups are separated by commas (e.g. "private final, protected"). If a property does not match all of the modifiers in any group, then trigger a violation. If "null" or empty, skip this check.]]></description>
    </param>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>ignoreMethodsWithAnnotationNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) annotation names that should be ignored (i.e., methods with those annotations should not cause a rule violation). The names may optionally contain wildcards (*,?). (Do not include the "@" in the annotation name.]]></description>
    </param>
    <param>
      <key>illegalFieldModifiers</key>
      <description><![CDATA[Specifies one or more groups of whitespace-delimited modifier names (e.g. "public static" or "protected"). Multiple groups are separated by commas (e.g. "private final, protected"). If a field matches all of the modifiers in any group, then trigger a violation. If "null" or empty, skip this check.]]></description>
    </param>
    <param>
      <key>illegalMethodModifiers</key>
      <description><![CDATA[Specifies one or more groups of whitespace-delimited modifier names (e.g. "public static" or "protected"). Multiple groups are separated by commas (e.g. "private final, protected"). If a method matches all of the modifiers in any group, then trigger a violation. If "null" or empty, skip this check.]]></description>
    </param>
    <param>
      <key>illegalPropertyModifiers</key>
      <description><![CDATA[Specifies one or more groups of whitespace-delimited modifier names (e.g. "public static" or "protected"). Multiple groups are separated by commas (e.g. "private final, protected"). If a property matches all of the modifiers in any group, then trigger a violation. If "null" or empty, skip this check.]]></description>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalClassReferenceRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Class Reference]]></name>
    <internalKey><![CDATA[IllegalClassReference]]></internalKey>
    <description><![CDATA[<p>Checks for reference to any of the classes configured in <code>classNames</code>.</p>
<p>Note that you can use the standard rule properties, such as <code>applyToClassNames</code>, <code>doNotApplyToFileNames</code>
and <code>applyToFilesMatching</code> to only apply this rule to a subset of all classes/files. These rule properties
are described in
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>This rule can be useful for governance and enforcement of <em>architectural layering</em>. For instance,
making sure that view or model classes, for instance, do not contain references to DAO classes (e.g., *Dao).</p>
<p>Here is an example configuration of this rule used to ensure that DAO classes are not referenced from
within model classes:</p>
<pre><code>    ruleset {
        description &quot;Example CodeNarc Ruleset&quot;

        // ...

        IllegalClassReference {
            name = 'DoNotReferenceDaoFromModelClasses'
            priority = 2
            classNames = '*Dao'
            applyToClassNames = 'com.example.model.*'
            description = 'Do not reference DAOs from model classes.'
        }
    }
</code></pre>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>classNames</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>classNames</key>
      <description><![CDATA[Specifies the comma-separated list of (fully-qualified) class names. The class name(s) may optionally include wildcard characters ('' or '?'). Note that the '' wildcard matches any sequence of zero or more characters in the class/package name, e.g. 'a.*.MyClass' matches "a.b.MyClass" as well as "a.b.c.d.MyClass". If "classNames" is null or empty, do nothing.]]></description>
    </param>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalPackageReferenceRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Package Reference]]></name>
    <internalKey><![CDATA[IllegalPackageReference]]></internalKey>
    <description><![CDATA[<p>Checks for reference to any of the packages configured in <code>packageNames</code>.</p>
<p>Note that you can use the standard rule properties, such as <code>applyToClassNames</code>, <code>doNotApplyToFileNames</code>
and <code>applyToFilesMatching</code> to only apply this rule to a subset of all classes/files. These rule properties
are described in
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
<p>This rule can be useful for governance and enforcement of <em>architectural layering</em>. For instance,
making sure that view or model classes, for instance, do not contain references to JDBC-specific packages
(e.g. java.sql and javax.sql).</p>
<p>Here is an example configuration of this rule used to ensure that JDBC packages/classes are only
referenced within DAO classes:</p>
<pre><code>    ruleset {
        description &quot;Example CodeNarc Ruleset&quot;

        // ...

        IllegalPackageReference {
            name = 'UseJdbcOnlyInDaoClasses'
            priority = 2
            packageNames = 'groovy.sql, java.sql, javax.sql'
            doNotApplyToClassNames = 'com.example.framework.dao.*, *Dao, *DaoImpl'
            description = 'Reference to JDBC packages should be restricted to DAO classes.'
        }
    }
</code></pre>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>packageNames</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>packageNames</key>
      <description><![CDATA[Specifies the comma-separated list of package names. The package name(s) may optionally include wildcard characters ('' or '?'). Note that the '' wildcard matches any sequence of zero or more characters in the package name, e.g. 'a.*' matches 'a.b' as well as 'a.b.c.d'. If "packageNames" is null or empty, do nothing.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.IllegalRegexRule.fixed</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Illegal Regex]]></name>
    <internalKey><![CDATA[IllegalRegex]]></internalKey>
    <description><![CDATA[<p>Checks for a specified illegal regular expression within the source code.</p>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>regex</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>regex</key>
      <description><![CDATA[The regular expression to check for. If null or empty then do nothing.]]></description>
    </param>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalStringRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal String]]></name>
    <internalKey><![CDATA[IllegalString]]></internalKey>
    <description><![CDATA[<p>Checks for a specified illegal string within the source code.</p>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>string</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.
The <code>@SuppressWarnings</code> annotation-based disablement is also unavailable, but including a <code>// codenarc-disable IllegalString</code> comment
somewhere above the violation will disable this rule. See
<a href="./codenarc-configuring-rules.html#disabling-rules-from-comments">Disabling Rules From Comments</a>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>string</key>
      <description><![CDATA[The String to check for. If null or empty then do nothing.]]></description>
    </param>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalSubclassRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Subclass]]></name>
    <internalKey><![CDATA[IllegalSubclass]]></internalKey>
    <description><![CDATA[<p>Checks for classes that extend one of the specified set of illegal superclasses.</p>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>string</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>superclassNames</key>
      <description><![CDATA[Specifies the comma-separated list of (fully-qualified) class names. The class name(s) may optionally include wildcard characters ('' or '?'). Note that the '' wildcard matches any sequence of zero or more characters in the class/package name, e.g. 'a.*.MyClass' matches "a.b.MyClass" as well as "a.b.c.d.MyClass". If "classNames" is null or empty, do nothing.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.RequiredRegexRule.fixed</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Required Regex]]></name>
    <internalKey><![CDATA[RequiredRegex]]></internalKey>
    <description><![CDATA[<p>Checks for a specified regular expression that must exist within the source code.</p>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>regex</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>regex</key>
      <description><![CDATA[The regular expression to check for. If null or empty then do nothing.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.RequiredStringRule.fixed</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Required String]]></name>
    <internalKey><![CDATA[RequiredString]]></internalKey>
    <description><![CDATA[<p>Checks for a specified text string that must exist within the source code.</p>
<p>A RuleSet can contain any number of instances of this rule, but each should be configured
with a unique rule <em>name</em> and <em>string</em>, and (optionally) customized <em>violationMessage</em> and <em>priority</em>.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>string</key>
      <description><![CDATA[The String to check for. If null or empty then do nothing.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.StatelessClassRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Stateless Class]]></name>
    <internalKey><![CDATA[StatelessClass]]></internalKey>
    <description><![CDATA[<p>Checks for non-<code>final</code> fields on a class. The intent of this rule is to check a configured set
of classes that should remain &quot;stateless&quot; and reentrant. One example might be Grails
service classes which are singletons, by default, and so they should be reentrant.</p>
<p>This rule ignores <code>final</code> fields (either instance or static). Fields that are
<code>static</code> and non-<code>final</code>, however, do cause a violation.</p>
<p>This rule also ignores all classes annotated with the <code>@Immutable</code> transformation.
See <a href="http://groovy.codehaus.org/Immutable+transformation">http://groovy.codehaus.org/Immutable+transformation</a>.</p>
<p>This rule also ignores all fields annotated with the <code>@Inject</code> or <code>@Value</code> annotations.</p>
<p>You can configure this rule to ignore certain fields either by name or by type. This can be
useful to ignore fields that hold references to (static) dependencies (such as DAOs or
Service objects) or static configuration.</p>
<p>Note that you can use the standard rule properties, such as <code>applyToClassNames</code>, <code>doNotApplyToFileNames</code>
and <code>applyToFilesMatching</code> to only apply this rule to a subset of all classes/files. These rule properties
are described in zzz./codenarc-configuring-rules.html#standard-properties-for-configuring-rules}
Standard Properties for Configuring Rulesyy.</p>
<h3>Notes</h3>
<ol>
<li>
<p>The <code>ignoreFieldTypes</code> property matches the field type name as indicated
in the field declaration, only including a full package specification IF it is included in
the source code. For example, the field declaration <code>BigDecimal value</code> matches
an <code>ignoreFieldTypes</code> value of <code>BigDecimal</code>, but not
<code>java.lang.BigDecimal</code>.</p>
</li>
<li>
<p>There is one exception for the <code>ignoreFieldTypes</code> property: if the field is declared
with a modifier/type of <code>def</code>, then the type resolves to <code>java.lang.Object</code>.</p>
</li>
<li>
<p>At least one of the (standard) <code>applyToClassNames</code>, <code>applyToFileNames</code> or <code>applyToFilesMatching</code>
properties must be set (i.e., not null or empty) or else this rule does nothing. In other words, you must configure
this rule to apply to a specific set of classes or files.</p>
</li>
<li>
<p>This rule will not catch violations of true <em>statelessness</em>/<em>reentrancy</em> if you define a <code>final</code>
field whose value is itself mutable, e.g. a <code>final HashMap</code>.</p>
</li>
</ol>
]]></description>
    <tag>bug</tag>
    <param>
      <key>addToIgnoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names to be added to the "ignoreFieldNames" property value. This is a special write-only property, and each call to "setAddIgnoreFieldNames()" adds to (rather than overwrites) the list of field names to be ignored.]]></description>
    </param>
    <param>
      <key>ignoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>ignoreFieldTypes</key>
      <description><![CDATA[Specifies one or more (comma-separated) field types that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- grails rules -->

  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainGormMethodsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Grails Domain Gorm Methods]]></name>
    <internalKey><![CDATA[GrailsDomainGormMethods]]></internalKey>
    <description><![CDATA[<p>&lt;Since CodeNarc 1.6&gt;</p>
<p>Database operation should be performed by Data Services instead of calling GORM static and instance methods.</p>
<p>Using the GORM static and instance methods may lead to spreading the persistence logic across the whole
application instead of concentrating it into services. It makes difficult to find all the code working
with the database in case of upgrades to the newer versions of Grails which require all persistence code
running inside transactions.</p>
<p>Data Services are available since Grails 3.3 and GORM 6.1.</p>
<p>NOTE: This is a <a href="./codenarc-enhanced-classpath-rules.html">CodeNarc Enhanced Classpath Rule</a>.
It requires <strong>CodeNarc</strong> to have the application classes being analyzed, as well as any referenced classes, on the classpath.</p>
<p>Example of violations:</p>
<pre><code>    class Person {
        String firstName
        String lastName
    }

    class PersonService {
        
        Person createPerson(String firstName, String lastName) {
            Person person = new Person(firstName: firstName, lastName: lastName)
            return person.save()
        }
    
    }
</code></pre>
<p>Example of valid configuration:</p>
<pre><code>    class Person {
        String firstName
        String lastName
    }

    @Service(Person)
    class PersonDataService {
        Person save(Person person)
    }

    class PersonService {

        PersonDataService personDataService
        
        Person createPerson(String firstName, String lastName) {
            Person person = new Person(firstName: firstName, lastName: lastName)
            return personDataService.save(person)
        }
    
    }
</code></pre>
<p>See <a href="https://gorm.grails.org/latest/hibernate/manual/index.html#dataServices">GORM Data Services</a></p>
<p>See <a href="https://guides.grails.org/grails-gorm-data-services/guide/index.html">Grails GORM Data Services Guide</a></p>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainHasEqualsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain Has Equals]]></name>
    <internalKey><![CDATA[GrailsDomainHasEquals]]></internalKey>
    <description><![CDATA[<p>Checks that Grails domain classes redefine <code>equals()</code>.</p>
<p>Ignores classes annotated with <code>@EqualsAndHashCode</code> or <code>@Canonical</code>.</p>
<p>This rule sets the default value of <code>applyToFilesMatching</code> to only match files
under the 'grails-app/domain' folder. You can override this with a different regular
expression value if appropriate.</p>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainHasToStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain Has To String]]></name>
    <internalKey><![CDATA[GrailsDomainHasToString]]></internalKey>
    <description><![CDATA[<p>Checks that Grails domain classes redefine <code>toString()</code>.</p>
<p>Ignores classes annotated with <code>@ToString</code> or <code>@Canonical</code>.</p>
<p>This rule sets the default value of <code>applyToFilesMatching</code> to only match files
under the 'grails-app/domain' folder. You can override this with a different regular
expression value if appropriate.</p>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainReservedSqlKeywordNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain Reserved Sql Keyword Name]]></name>
    <internalKey><![CDATA[GrailsDomainReservedSqlKeywordName]]></internalKey>
    <description><![CDATA[<p>Forbids usage of SQL reserved keywords as class or field names in Grails domain classes.
Naming a domain class (or its field) with such a keyword causes SQL schema creation errors and/or redundant
table/column name mappings.</p>
<p>Note: due to limited type information available during CodeNarc's operation, this rule will report fields
of type <code>java.io.Serializable</code>, but not of its implementations. Please specify any implementations
used as domain properties in <code>additionalHibernateBasicTypes</code>.</p>
]]></description>
    <tag>grails</tag>
    <param>
      <key>additionalHibernateBasicTypes</key>
      <description><![CDATA[Comma-separated list of simple class names of additional classes that Hibernate maps as basic types (creates a column for a field of such class). Add your custom basic types here.]]></description>
      <defaultValue>''</defaultValue>
    </param>
    <param>
      <key>additionalReservedSqlKeywords</key>
      <description><![CDATA[Comma-separated list of additional reserved SQL keywords (just in case the 337 keywords of nowadays SQL-* standards weren't enough)]]></description>
      <defaultValue>''</defaultValue>
    </param>
  </rule>

  <!-- since 1.2 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainStringPropertyMaxSizeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain String Property Max Size]]></name>
    <internalKey><![CDATA[GrailsDomainStringPropertyMaxSize]]></internalKey>
    <description><![CDATA[<p>String properties in Grails domain classes have to define maximum size otherwise the property is mapped to VARCHAR(255) causing runtime exceptions to occur.
To fix this issue either declare <code>size</code>* or <code>maxSize</code> constraint for the property inside <code>constraints</code> DSL closure of your Grails domain class or
declare the <code>type</code> of the property inside <code>mapping</code> DSL closure. If you use the second option inside <strong>mapping</strong> DSL closure then please pay attention that the value of  <code>type</code> is
not checked so using for example <code>VARCHAR(50)</code> would still cause runtime exceptions.</p>
<p>Example of violations:</p>
<pre><code>    // both firstName and lastName will probably have database limit of 255 characters
    // which is not validated by Grails validation causing runtime JDBC exception
    class Person {

        String firstName
        String lastName

        static constraints = {
            firstName nullable:true
            lastName nullable:true
        }
    }
</code></pre>
<p>Example of valid configuration:</p>
<pre><code>    class Person {

        String firstName
        String lastName

        static constraints = {
            firstName nullable:true, maxSize: 255
            lastName nullable:true
        }

        static mapping = {
            lastName type: 'text'
        }
    }
</code></pre>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainWithServiceReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain With Service Reference]]></name>
    <internalKey><![CDATA[GrailsDomainWithServiceReference]]></internalKey>
    <description><![CDATA[<p>Checks that Grails Domain classes do not have Service classes injected.</p>
<p>This rule sets the default value of <code>applyToFilesMatching</code> to only match files
under the 'grails-app/domain' folder. You can override this with a different regular
expression value if appropriate.</p>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDuplicateConstraintRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Duplicate Constraint]]></name>
    <internalKey><![CDATA[GrailsDuplicateConstraint]]></internalKey>
    <description><![CDATA[<p>Check for duplicate name in a Grails domain class constraints. Duplicate names/entries are legal,
but can be confusing and error-prone.</p>
<p>NOTE: This rule does not check that the values of the entries are duplicated, only that there are two entries with the same name.</p>
<p>Example of violations:</p>
<pre><code>    class Person {
        String firstName
        String lastName

        static constraints = {
            firstName nullable:true
            lastName nullable:true, maxSize:30
            firstName nullable:false                // violation
        }
    }
</code></pre>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDuplicateMappingRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Duplicate Mapping]]></name>
    <internalKey><![CDATA[GrailsDuplicateMapping]]></internalKey>
    <description><![CDATA[<p>Check for duplicate name in a Grails domain class mapping. Duplicate names/entries are legal, but can be
confusing and error-prone.</p>
<p>NOTE: This rule does not check that the values of the entries are duplicated, only that there are two entries with the same name.</p>
<p>Example of violations:</p>
<pre><code>    class Person {
        String firstName
        String lastName

        static mapping = {
            table 'people'
            firstName column: 'First_Name'
            lastName column: 'Last_Name'
            firstName column: 'First_Name'      // violation
            table 'people2'                     // violation
        }
    }
</code></pre>
]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsMassAssignmentRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Mass Assignment]]></name>
    <internalKey><![CDATA[GrailsMassAssignment]]></internalKey>
    <description><![CDATA[<p>Untrusted input should not be allowed to set arbitrary object fields without restriction.</p>
<p>Example of violations:</p>
<pre><code>   // Person would be a grails domain object
   def person = new Person(params)
   person.save()

   // or using .properties
   def person = Person.get(1)
   person.properties = params
   person.save()
</code></pre>
]]></description>
    <tag>grails</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.grails.GrailsPublicControllerMethodRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Public Controller Method]]></name>
    <internalKey><![CDATA[GrailsPublicControllerMethod]]></internalKey>
    <description><![CDATA[<p><strong>NOTE:</strong> This rule has been disabled by default (i.e., by setting its <em>enabled</em> property to
<em>false</em>). Given that Grails 2.x allows and encourages controller actions to be defined as methods
instead of closures, this rule makes no sense for Grails 2.x projects.</p>
<p>Rule that checks for public methods on Grails controller classes. Static methods are ignored.</p>
<p>Grails controller actions and interceptors are defined as properties on the controller class.
Public methods on a controller class are unnecessary. They break encapsulation and can
be confusing.</p>
<p>This rule sets the default value of <code>applyToFilesMatching</code> to only match files
under the 'grails-app/controllers' folder. You can override this with a different regular
expression value if appropriate.</p>
<p>This rule also sets the default value of <code>applyToClassNames</code> to only match class names
ending in 'Controller'. You can override this with a different class name pattern
(String with wildcards) if appropriate.</p>
]]></description>
    <tag>grails</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.grails.GrailsServletContextReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Servlet Context Reference]]></name>
    <internalKey><![CDATA[GrailsServletContextReference]]></internalKey>
    <description><![CDATA[<p>Rule that checks for references to the <code>servletContext</code> object from within Grails controller and
taglib classes.</p>
<p>This rule is intended as a &quot;governance&quot; rule to enable monitoring and controlling access to the
<code>servletContext</code> from within application source code. Storing objects in the <code>servletContext</code>
may inhibit scalability and/or performance and should be carefully considered. Furthermore, access to
the <code>servletContext</code> is not synchronized, so reading/writing objects from the <code>servletContext</code>
must be manually synchronized, as described in
<a href="http://www.amazon.com/Definitive-Grails-Second-Experts-Development/dp/1590599950">The Definitive Guide to Grails (2nd edition)</a>.</p>
<p>Note that this rule does not check for direct access to the <code>servletContext</code> from within GSP
(Groovy Server Pages) files.</p>
<p>Enabling this rule may make most sense in a team environment where team members exhibit a broad
range of skill and experience levels. Appropriate <code>servletContext</code> access can be configured as exceptions
to this rule by configuring either the <code>doNotApplyToFilenames</code> or
<code>doNotApplyToFilesMatching</code> property of the rule. And, as always, it is easy to
just <a href="./codenarc-configuring-rules.html#Turning_Off_A_Rule">turn off the rule</a> if it does not
make sense it your environment.</p>
<p>This rule sets the default value of <code>applyToFilesMatching</code> to only match files
under the 'grails-app/controllers' or 'grails-app/taglib' folders. You can override this
with a different regular expression value if appropriate.</p>
]]></description>
    <tag>grails</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.grails.GrailsStatelessServiceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Stateless Service]]></name>
    <internalKey><![CDATA[GrailsStatelessService]]></internalKey>
    <description><![CDATA[<p>Checks for non-<code>final</code> fields on a Grails service class. Grails service classes are singletons by
default, and so they should be reentrant. In most cases, this implies (or at least encourages)
that they should be stateless.</p>
<p>This rule ignores (i.e., does not cause violations for) the following:</p>
<ul>
<li>All <code>final</code> fields (either instance or static). Note that fields that are <code>static</code> and non-<code>final</code>, however, do cause a violation.</li>
<li>Non-<code>static</code> properties (i.e., no visibility modifier specified) declared with <code>def</code>.</li>
<li>All classes annotated with the <code>@Immutable</code> transformation. See <a href="http://groovy.codehaus.org/Immutable+transformation">http://groovy.codehaus.org/Immutable+transformation</a>.</li>
<li>All fields annotated with the <code>@Inject</code> annotation.</li>
<li>All fields with names matching the <em>ignoreFieldNames</em> property.</li>
<li>All fields with types matching the <em>ignoreFieldTypes</em> property.</li>
</ul>
<p>The <code>ignoreFieldNames</code> property of this rule is preconfigured to ignore the standard Grails
service configuration field names ('scope', 'transactional') and the standard injected bean names
('dataSource', 'sessionFactory'), as well as all other field names ending with 'Service'.</p>
<p>This rule sets the default value of <code>applyToFilesMatching</code> to only match files under the
'grails-app/services' folder. You can override this with a different regular expression value if appropriate.</p>
<p>This rule also sets the default value of <code>applyToClassNames</code> to only match class names
ending in 'Service'. You can override this with a different class name pattern (String with wildcards)
if appropriate.</p>
<h3>Notes</h3>
<ol>
<li>
<p>The <code>ignoreFieldTypes</code> property matches the field type name as indicated
in the field declaration, only including a full package specification IF it is included in
the source code. For example, the field declaration <code>BigDecimal value</code> matches
an <code>ignoreFieldTypes</code> value of <code>BigDecimal</code>, but not
<code>java.lang.BigDecimal</code>.</p>
</li>
<li>
<p>There is one exception for the <code>ignoreFieldTypes</code> property: if the field is declared
with a modifier/type of <code>def</code>, then the type resolves to <code>java.lang.Object</code>.</p>
</li>
</ol>
]]></description>
    <tag>grails</tag>
    <param>
      <key>addToIgnoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names to be added to the "ignoreFieldNames" property value. This is a special write-only property, and each call to "setAddIgnoreFieldNames()" adds to (rather than overwrites) the list of field names to be ignored.]]></description>
    </param>
    <param>
      <key>ignoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
      <defaultValue>'dataSource,scope,sessionFactory,transactional,*Service'</defaultValue>
    </param>
    <param>
      <key>ignoreFieldTypes</key>
      <description><![CDATA[Specifies one or more (comma-separated) field types that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- groovyism rules -->

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.groovyism.AssignCollectionSortRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assign Collection Sort]]></name>
    <internalKey><![CDATA[AssignCollectionSort]]></internalKey>
    <description><![CDATA[<p>The Collections.sort() method mutates the list and returns the list as a value. If you are assigning the result of sort() to a
variable, then you probably don't realize that you're also modifying the original list as well. This is frequently the cause of subtle bugs.
This violation is triggered when a sort() method call appears as the right hand side of an assignment, or when it appears
as the first method call in a series of chained method calls.</p>
<p>Example of violations:</p>
<pre><code>  def a = myList.sort()
  def b = myList.sort() { it }
  def c = myList.sort().findAll { x * 1 }
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.groovyism.AssignCollectionUniqueRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assign Collection Unique]]></name>
    <internalKey><![CDATA[AssignCollectionUnique]]></internalKey>
    <description><![CDATA[<p>The Collections.unique() method mutates the list and returns the list as a value. If you are assigning the result of unique() to a
variable, then you probably don't realize that you're also modifying the original list as well. This is frequently the cause of subtle bugs.</p>
<p>This violation is triggered when a <code>unique()</code> method call that mutates the target collection appears as the right hand side of an assignment,
or when it appears as the first method call in a series of chained method calls.</p>
<p>Example of violations:</p>
<pre><code>  def a = myList.unique()                   // No-argument

  def x = myList.unique() { it }            // Single-argument: Closure
  def y = myList.unique { it % 2 }

  def c = myList.unique().findAll { x * 1 } // Chained method call

  def comparator = { o1, o2 -* o1 *=* o2 }
  def x = myList.unique(comparator)         // Single-argument: Comparator

  def x = myList.unique(true)               // Single-argument: boolean true

  def x = myList.unique(true, comparator)   // Two arguments: boolean true and Comparator
  def y = myList.unique(true) { it }        // Two arguments: boolean true and Closure
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ClosureAsLastMethodParameterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Closure As Last Method Parameter]]></name>
    <internalKey><![CDATA[ClosureAsLastMethodParameter]]></internalKey>
    <description><![CDATA[<p>If the last parameter of a method call is an inline closure then it can be declared outside the method call parentheses.</p>
<p>Example of violations:</p>
<pre><code>    // creates violation: poor Groovy style
    [1,2,3].each({ println it })

    // no violation
    [1,2,3].each { println it }
</code></pre>
]]></description>
    <tag>groovyism</tag>
    <param>
      <key>ignoreCallsToMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names; method calls on the named methods are ignored (i.e., do not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.CollectAllIsDeprecatedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Collect All Is Deprecated]]></name>
    <internalKey><![CDATA[CollectAllIsDeprecated]]></internalKey>
    <description><![CDATA[<p>The <code>collectAll</code> method is deprecated since Groovy 1.8.1. Use <code>collectNested</code> instead.</p>
<p>Example of violations:</p>
<pre><code>    def list = [1, 2, [3, 4, [5, 6]], 7]

    list.collectAll { it * 2 }      // deprecated

    list.collectNested { it * 2 }   // replacement
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ConfusingMultipleReturnsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Confusing Multiple Returns]]></name>
    <internalKey><![CDATA[ConfusingMultipleReturns]]></internalKey>
    <description><![CDATA[<p>Multiple return values can be used to set several variables at once. To use multiple return values, the left
hand side of the assignment must be enclosed in parenthesis. If not, then you are not using multiple return values,
you're only assigning the last element.</p>
<p>Example of violations:</p>
<pre><code>    def a, b = [1, 2] // bad, b is null
    def c, d, e = [1, 2, 3] // bad, c and d are null
    class MyClass {
        def a, b, c = [1, 2, 3]  // bad, a and b are null
    }
    
    def x = 1              // ok
    def (f, g) = [1, 2]    // ok
    (a, b, c) = [1, 2, 3]  // ok
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitArrayListInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Array List Instantiation]]></name>
    <internalKey><![CDATA[ExplicitArrayListInstantiation]]></internalKey>
    <description><![CDATA[<p>This rule checks for explicit calls to the no-argument constructor of <code>ArrayList</code>. In Groovy, it is best to write
<code>new ArrayList() as []</code>, which creates the same object.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToAndMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To And Method]]></name>
    <internalKey><![CDATA[ExplicitCallToAndMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>and(Object)</code> method is called directly in code instead of using the <code>&amp;</code>
operator. A groovier way to express this: <code>a.and(b)</code> is this: <code>a &amp; b</code>. This rule can be
configured to ignore <code>this.and(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>true</em>, so
even <code>and(x)</code> will not trigger a violation. The default is <em>true</em> because <code>and</code> appears commonly in Grails
criteria.</p>
<p>This rule also ignores all calls to <code>super.and(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToCompareToMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Compare To Method]]></name>
    <internalKey><![CDATA[ExplicitCallToCompareToMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>compareTo(Object)</code> method is called directly in code instead of using the
*=*, *, *=, *, and *= operators. A groovier way to express this: <code>a.compareTo(b)</code> is this:
<code>a \*\=\* b</code>, or using the other operators. Here are some other ways to write groovier code:</p>
<pre><code>    a.compareTo(b) == 0               // can be replaced by: a == b
    a.compareTo(b)                    // can be replaced by: a *=* b
    a.compareTo(b) * 0                // can be replaced by: a * b
    a.compareTo(b) *= 0               // can be replaced by: a *= b
    a.compareTo(b) * 0                // can be replaced by: a * b
    a.compareTo(b) *= 0               // can be replaced by: a *= b
</code></pre>
<p>This rule can be  configured to ignore <code>this.compareTo(Object)</code> using the <em>ignoreThisReference</em>
property. It defaults to <code>false</code>, so even <code>compareTo(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.compareTo(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToDivMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Div Method]]></name>
    <internalKey><![CDATA[ExplicitCallToDivMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>div(Object)</code> method is called directly in code instead of using the
<code>/</code> operator. A groovier way to express this: <code>a.div(b)</code> is this: <code>a / b</code>. This rule can be
configured to ignore <code>div.xor(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>false</em>,
so even <code>div(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.div(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToEqualsMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Equals Method]]></name>
    <internalKey><![CDATA[ExplicitCallToEqualsMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>equals(Object)</code> method is called directly in code instead of using the
<code>==</code> or <code>!=</code> operator. A groovier way to express this: <code>a.equals(b)</code> is this: <code>a == b</code>
and a groovier way to express : <code>!a.equals(b)</code> is: <code>a != b</code>. This rule can be
configured to ignore <code>this.equals(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to
<em>false</em>, so even <code>equals(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.equals(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToGetAtMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Get At Method]]></name>
    <internalKey><![CDATA[ExplicitCallToGetAtMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>getAt(Object)</code> method is called directly in code instead of using the
<code>[]</code> index operator. A groovier way to express this: <code>a.getAt(b)</code> is this: <code>a[b]</code>. This rule can be
configured to ignore <code>this.getAt(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>false</em>,
so even <code>getAt(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.getAt(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToLeftShiftMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Left Shift Method]]></name>
    <internalKey><![CDATA[ExplicitCallToLeftShiftMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>leftShift(Object)</code> method is called directly in code instead of using the
** operator. A groovier way to express this: <code>a.leftShift(b)</code> is this: <code>a \*\* b</code>. This rule can be
configured to ignore <code>this.leftShift(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to
<em>false</em>, so even <code>leftShift(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.leftShift(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToMinusMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Minus Method]]></name>
    <internalKey><![CDATA[ExplicitCallToMinusMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>minus(Object)</code> method is called directly in code instead of using the
<code>-</code> operator. A groovier way to express this: <code>a.minus(b)</code> is this: <code>a - b</code>. This rule can be
configured to ignore <code>minus.xor(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to
<em>false</em>, so even <code>minus(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.minus(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToMultiplyMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Multiply Method]]></name>
    <internalKey><![CDATA[ExplicitCallToMultiplyMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>multiply(Object)</code> method is called directly in code instead of using the
<code>*</code> operator. A groovier  way to express this: <code>a.multiply(b)</code> is this: <code>a * b</code>. This rule can be
configured to ignore <code>this.multiply(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to
<em>false</em>, so even <code>multiply(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.multiply(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToModMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Mod Method]]></name>
    <internalKey><![CDATA[ExplicitCallToModMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>mod(Object)</code> method is called directly in code instead of using the
<code>%</code> operator. A groovier way to express this: <code>a.mod(b)</code> is this: <code>a % b</code>. This rule can be
configured to ignore <code>this.mod(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>false</em>, so
even <code>mod(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.mod(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToOrMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Or Method]]></name>
    <internalKey><![CDATA[ExplicitCallToOrMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>or(Object)</code> method is called directly in code instead of using the <code>|</code>
operator. A groovier way to express this: <code>a.or(b)</code> is this: <code>a | b</code>. This rule can be
configured to ignore <code>this.or(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>true</em>, so
even <code>or(x)</code> will not trigger a violation. This is the default because it is commonly used in Grails criteria.</p>
<p>This rule also ignores all calls to <code>super.or(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToPlusMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Plus Method]]></name>
    <internalKey><![CDATA[ExplicitCallToPlusMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>plus(Object)</code> method is called directly in code instead of using the
<code>+</code> operator. A groovier way to express this: <code>a.plus(b)</code> is this: <code>a + b</code>. This rule can be
configured to ignore <code>this.plus(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>false</em>, so
even <code>plus(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.plus(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToPowerMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Power Method]]></name>
    <internalKey><![CDATA[ExplicitCallToPowerMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>power(Object)</code> method is called directly in code instead of using the
<code>**</code> operator. A groovier way to express this: <code>a.power(b)</code> is this: <code>a ** b</code>. This rule can be
configured to ignore <code>this.power(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>false</em>, so
even <code>power(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.power(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 1.3 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToPutAtMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Put At Method]]></name>
    <internalKey><![CDATA[ExplicitCallToPutAtMethod]]></internalKey>
    <description><![CDATA[<p>Detects when the <code>map.putAt(k, v)</code> method is called directly rather than using <code>map[k] = v</code>.</p>
<p>This rule can be configured to ignore <code>this.putAt(k, v)</code> using the <em>ignoreThisReference</em> property. It defaults
to <em>false</em>, so even <code>putAt(k, v)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.putAt(k, v)</code>.</p>
<p>Example of violations:</p>
<pre><code>        map.putAt(k, v)         // violation
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToRightShiftMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Right Shift Method]]></name>
    <internalKey><![CDATA[ExplicitCallToRightShiftMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>rightShift(Object)</code> method is called directly in code instead of using the
** operator. A groovier way to express this: <code>a.rightShift(b)</code> is this: <code>a \*\* b</code>. This rule can be
configured to ignore <code>this.rightShift(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to
<em>false</em>, so even <code>rightShift(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.rightShift(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToXorMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Xor Method]]></name>
    <internalKey><![CDATA[ExplicitCallToXorMethod]]></internalKey>
    <description><![CDATA[<p>This rule detects when the <code>xor(Object)</code> method is called directly in code instead of using the
<code>^</code> operator. A groovier way to express this: <code>a.xor(b)</code> is this: <code>a ^ b</code>. This rule can be
configured to ignore <code>this.xor(Object)</code> using the <em>ignoreThisReference</em> property. It defaults to <em>false</em>, so
even <code>xor(x)</code> will trigger a violation.</p>
<p>This rule also ignores all calls to <code>super.xor(Object)</code>.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitHashMapInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Hash Map Instantiation]]></name>
    <internalKey><![CDATA[ExplicitHashMapInstantiation]]></internalKey>
    <description><![CDATA[<p>This rule checks for explicit calls to the no-argument constructor of <code>HashMap</code>. In Groovy, it is best to replace
<code>new HashMap()</code> with <code>[:]</code>, which creates (mostly) the same object. <code>[:]</code> is technically a LinkedHashMap but it
is very rare that someone absolutely needs an instance of <code>HashMap</code> and not a subclass.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitLinkedHashMapInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Linked Hash Map Instantiation]]></name>
    <internalKey><![CDATA[ExplicitLinkedHashMapInstantiation]]></internalKey>
    <description><![CDATA[<p><em>Since in CodeNarc 0.14</em></p>
<p>This rule checks for the explicit instantiation of a <code>LinkedHashMap</code> using the no-arg constructor. In Groovy, it
is best to replace <code>new LinkedHashMap()</code> with <code>[:]</code>, which creates the same object.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitHashSetInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Hash Set Instantiation]]></name>
    <internalKey><![CDATA[ExplicitHashSetInstantiation]]></internalKey>
    <description><![CDATA[<p>This rule checks for explicit calls to the no-argument constructor of <code>HashSet</code>. In Groovy, it is best to replace
<code>new HashSet()</code> with <code>[] as Set</code>, which creates the same object.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitLinkedListInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Linked List Instantiation]]></name>
    <internalKey><![CDATA[ExplicitLinkedListInstantiation]]></internalKey>
    <description><![CDATA[<p>This rule checks for explicit calls to the no-argument constructor of <code>LinkedList</code>. In Groovy, it is best to replace
<code>new LinkedList()</code> with <code>[] as Queue</code>, which creates the same object.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitStackInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Stack Instantiation]]></name>
    <internalKey><![CDATA[ExplicitStackInstantiation]]></internalKey>
    <description><![CDATA[<p>This rule checks for explicit calls to the no-argument constructor of <code>Stack</code>. In Groovy, it is best to replace
<code>new Stack()</code> with <code>[] as Stack</code>, which creates the same object.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitTreeSetInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Tree Set Instantiation]]></name>
    <internalKey><![CDATA[ExplicitTreeSetInstantiation]]></internalKey>
    <description><![CDATA[<p>This rule checks for explicit calls to the no-argument constructor of <code>TreeSet</code>. In Groovy, it is best to replace
<code>new TreeSet()</code> with <code>[] as SortedSet</code>, which creates the same object.</p>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GetterMethodCouldBePropertyRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Getter Method Could Be Property]]></name>
    <internalKey><![CDATA[GetterMethodCouldBeProperty]]></internalKey>
    <description><![CDATA[<p>If a class defines a <code>public</code> method that follows the Java getter notation and that returns a constant, literal
or static final field value, then it is cleaner to provide a Groovy property for the value rather than a Groovy method.</p>
<p>Example of violations:</p>
<pre><code>    interface Parent {
        String getSomething()
        String getSomethingElse()
    }

    class Child extends Parent {
        static final VALUE = 'value'

        String getSomething() {         // violation
            'something'         
        }

        @Override
        String getSomethingElse() {     // violation
            VALUE       
        }

        int getOtherValue() {           // violation
            123
        }

        Class getTheClass() {           // violation
            return Integer
        }

        static String getName() {       // violation
            'MyName'
        }
    }

    class Child2 extends Parent {
        static final VALUE = 'value'
        final String something = 'something'    // this is cleaner
        final String somethingElse = VALUE      // this is cleaner
        final int otherValue = 123              // this is cleaner
        static final String name = 'MyName'     // this is cleaner
    }
</code></pre>
]]></description>
    <tag>groovyism</tag>
    <param>
      <key>ignoreMethodsWithOverrideAnnotation</key>
      <description><![CDATA[If "true", then do not check methods annotated with @Override.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GroovyLangImmutableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Groovy Lang Immutable]]></name>
    <internalKey><![CDATA[GroovyLangImmutable]]></internalKey>
    <description><![CDATA[<p>The <code>groovy.lang.Immutable</code> annotation has been deprecated and replaced by <code>groovy.transform.Immutable</code>. Do
not use the <code>Immutable</code> in <code>groovy.lang</code>.</p>
<p>Example of violations:</p>
<pre><code>    @Immutable                          // Violation (no import means groovy.lang.Immutable)
    class Person { }

    @groovy.lang.Immutable              // Violation
    class Person { }

    import groovy.lang.Immutable as Imtl
    @Imtl                               // Violation
    class Person { }

</code></pre>
<p>Example of valid use of @Immutable:</p>
<pre><code>    @groovy.transform.Immutable                 // OK
    class Person { }

    import groovy.transform.Immutable           // OK
    @Immutable
    class Person { }

    import groovy.transform.*
    @Immutable                                  // OK
    class Person { }

    import groovy.transform.Immutable as Imtl
    @Imtl                                       // OK
    class Person { }

    @javax.annotation.concurrent.Immutable      // OK
    class MyClass { }

</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GStringAsMapKeyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[G String As Map Key]]></name>
    <internalKey><![CDATA[GStringAsMapKey]]></internalKey>
    <description><![CDATA[<p>A GString should not be used as a map key since its <em>hashcode</em> is not guaranteed to be stable.
Consider calling <code>key.toString()</code>.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    Map map = [&quot;${someRef}&quot; : 'invalid' ]       // violation
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GStringExpressionWithinStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[G String Expression Within String]]></name>
    <internalKey><![CDATA[GStringExpressionWithinString]]></internalKey>
    <description><![CDATA[<p>Check for regular (single quote) strings containing a GString-type expression (${..}).</p>
<p>Example of violations:</p>
<pre><code>    def str1 = 'total: ${count}'                // violation
    def str2 = 'average: ${total / count}'      // violation

    def str3 = &quot;abc ${count}&quot;                   // ok; GString
    def str4 = '$123'                           // ok
    def str5 = 'abc {123}'                      // ok
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.UseCollectManyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Collect Many]]></name>
    <internalKey><![CDATA[UseCollectMany]]></internalKey>
    <description><![CDATA[<p>In many case <code>collectMany()</code> yields the same result as <code>collect{}.flatten()</code>.
It is easier to understand and more clearly conveys the intent.</p>
<p>Example of violations:</p>
<pre><code>def l = [1, 2, 3, 4]

l.collect{ [it, it*2] }.flatten() // suboptimal

l.collectMany{ [it, it*2] }       // same functionality, better readability
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.UseCollectNestedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Collect Nested]]></name>
    <internalKey><![CDATA[UseCollectNested]]></internalKey>
    <description><![CDATA[<p>Instead of nested <code>collect{}</code> calls use <code>collectNested{}</code>.</p>
<p>Example of violations:</p>
<pre><code>def list = [1, 2, [3, 4, 5, 6], [7]]

println list.collect { elem -*
    if (elem instanceof List)
        elem.collect {it *2} // violation
    else elem * 2
}

println list.collect([8]) {
    if (it instanceof List)
        it.collect {it *2} // violation
    else it * 2
}

println list.collectNested { it * 2 } // same functionality, better readability
</code></pre>
]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- imports rules -->

  <rule>
    <key>org.codenarc.rule.imports.DuplicateImportRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Duplicate Import]]></name>
    <internalKey><![CDATA[DuplicateImport]]></internalKey>
    <description><![CDATA[<p>Checks for a duplicate <em>import</em> statements.</p>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.imports.ImportFromSamePackageRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Import From Same Package]]></name>
    <internalKey><![CDATA[ImportFromSamePackage]]></internalKey>
    <description><![CDATA[<p>Checks for an <em>import</em> of a class that is within the same package as the importing class.</p>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.imports.ImportFromSunPackagesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Import From Sun Packages]]></name>
    <internalKey><![CDATA[ImportFromSunPackages]]></internalKey>
    <description><![CDATA[<p>Example of violations:</p>
<pre><code>    import sun.misc.foo
    import sun.misc.foo as Foo

    public class MyClass{}
</code></pre>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.imports.MisorderedStaticImportsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Misordered Static Imports]]></name>
    <internalKey><![CDATA[MisorderedStaticImports]]></internalKey>
    <description><![CDATA[<p>This rule has one property <code>comesBefore</code>, which defaults to true. If you like your
static imports to come after the others, then set this property to false.</p>
<p>Examples of violations:</p>
<pre><code>    import my.something.another
    import static foo.bar

    public class MyClass{}
</code></pre>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.imports.NoWildcardImportsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[No Wildcard Imports]]></name>
    <internalKey><![CDATA[NoWildcardImports]]></internalKey>
    <description><![CDATA[<p>Checks for wildcard (star) imports. If the <em>ignoreStaticImports</em> property is <em>true</em>, then do not check static imports.
Similarly, do not check the standard imports if ignoreImports is <em>true</em>.</p>
<p>Example of violations:</p>
<pre><code>    import static foo.bar.*         // violation (unless ignoreStaticImports is true)
    import my.something.*           // violation (unless ignoreImports is true)

    public class MyClass{}
</code></pre>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreImports</key>
      <description><![CDATA[If true, then do not check imports.]]></description>
      <defaultValue>false</defaultValue>
    </param>
    <param>
      <key>ignoreStaticImports</key>
      <description><![CDATA[If true, then do not check static imports.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.imports.UnnecessaryGroovyImportRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Groovy Import]]></name>
    <internalKey><![CDATA[UnnecessaryGroovyImport]]></internalKey>
    <description><![CDATA[<p>Checks for an <em>import</em> from any package that is already automatically imported for
Groovy files. A Groovy file does not need to include an import for classes from
<em>java.lang</em>, <em>java.util</em>, <em>java.io</em>, <em>java.net</em>, <em>groovy.lang</em> and <em>groovy.util</em>, as well as the
classes <em>java.math.BigDecimal</em> and <em>java.math.BigInteger</em>.</p>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.imports.UnusedImportRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unused Import]]></name>
    <internalKey><![CDATA[UnusedImport]]></internalKey>
    <description><![CDATA[<p>Checks for <em>import</em> statements for classes that are never referenced within the source file. Also
checks static imports.</p>
<p>Known limitations:</p>
<ul>
<li>Does not check for unused imports containing wildcards (e.g. <code>import org.codenarc.*</code>)</li>
<li>Misses unused imports if the class/alias name is contained within strings, comments or other (longer)
names (i.e., if that string shows up almost anywhere within the source code).</li>
</ul>
<p>NOTE: This is a file-based rule, rather than a typical AST-based rule, so the <em>applyToClassNames</em>
and <em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- jdbc rules -->

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.jdbc.DirectConnectionManagementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Direct Connection Management]]></name>
    <internalKey><![CDATA[DirectConnectionManagement]]></internalKey>
    <description><![CDATA[<p>The J2EE standard requires that applications use the container's resource management facilities to obtain connections
to resources. Every major web application container provides pooled database connection management as part of its
resource management framework. Duplicating this functionality in an application is difficult and error prone, which
is part of the reason it is forbidden under the J2EE standard.</p>
<p>For more information see: <a href="https://vulncat.fortify.com/en/detail?id=desc.semantic.java.j2ee_badpractices_getconnection">https://vulncat.fortify.com/en/detail?id=desc.semantic.java.j2ee_badpractices_getconnection</a>.</p>
<p>Example of violations:</p>
<pre><code>    DriverManager.getConnection()
    java.sql.DriverManager.getConnection()
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.jdbc.JdbcConnectionReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Jdbc Connection Reference]]></name>
    <internalKey><![CDATA[JdbcConnectionReference]]></internalKey>
    <description><![CDATA[<p>Checks for direct use of <code>java.sql.Connection</code>, which is discouraged and almost never necessary
in application code.</p>
<p>For a more <em>Groovy</em> alternative, see <a href="http://groovy-lang.org/databases.html">http://groovy-lang.org/databases.html</a> for information on the
<strong>Groovy Sql</strong> abstraction layer for JDBC/SQL.</p>
<p>Note: If a violation is triggered from an <strong>import</strong> statement, then you may get multiple violations per
import if there are multiple classes in the source file. In that case, the imports are processed once per class.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.jdbc.JdbcResultSetReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Jdbc Result Set Reference]]></name>
    <internalKey><![CDATA[JdbcResultSetReference]]></internalKey>
    <description><![CDATA[<p>Checks for direct use of <code>java.sql.ResultSet</code>, which is not necessary if using the Groovy <strong>Sql</strong> facility or an
ORM framework such as <em>Hibernate</em>.</p>
<p>See <a href="http://groovy-lang.org/databases.html">http://groovy-lang.org/databases.html</a> for information on the <strong>Groovy Sql</strong> abstraction
layer for JDBC/SQL.</p>
<p>Note: If a violation is triggered from an <strong>import</strong> statement, then you may get multiple violations per
import if there are multiple classes in the source file. In that case, the imports are processed once per class.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.jdbc.JdbcStatementReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Jdbc Statement Reference]]></name>
    <internalKey><![CDATA[JdbcStatementReference]]></internalKey>
    <description><![CDATA[<p>Checks for direct use of <code>java.sql.Statement</code>, <code>java.sql.PreparedStatement</code>, or
<code>java.sql.CallableStatement</code>, which is not necessary if using the Groovy <strong>Sql</strong> facility or an
ORM framework such as <em>Hibernate</em>.</p>
<p>See <a href="http://groovy-lang.org/databases.html">http://groovy-lang.org/databases.html</a> for information on the <strong>Groovy Sql</strong> abstraction
layer for JDBC/SQL.</p>
<p>Note: If a violation is triggered from an <strong>import</strong> statement, then you may get multiple violations per
import if there are multiple classes in the source file. In that case, the imports are processed once per class.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- junit rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.junit.ChainedTestRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Chained Test]]></name>
    <internalKey><![CDATA[ChainedTest]]></internalKey>
    <description><![CDATA[<p>A test method that invokes another test method is a chained test; the methods are dependent on one another.
Tests should be isolated, and not be dependent on one another.</p>
<p>Example of violations:</p>
<pre><code>    class MyTest extends GroovyTestCase {
        public void testFoo() {

            // violations, calls test method on self
            5.times { testBar() }
            5.times { this.testBar() }

            // OK, no violation: one arg method is not actually a test method
            5.times { testBar(it) }
        }

        private static void assertSomething() {
            testBar() // violation, even if in helper method
            this.testBar() // violation, even if in helper method
        }

        public void testBar() {
            // ...
        }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.junit.CoupledTestCaseRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Coupled Test Case]]></name>
    <internalKey><![CDATA[CoupledTestCase]]></internalKey>
    <description><![CDATA[<p>This rule finds test cases that are coupled to other test cases, either by invoking static methods on another test case
or by creating instances of another test case. If you require shared logic in test cases then extract that logic to a
new class where it can properly be reused. Static references to methods on the current test class are ignored.</p>
<p>Example of violations:</p>
<pre><code>    class MyTest extends GroovyTestCase {
        public void testMethod() {
            // violation, static method call to other test
            MyOtherTest.helperMethod()

            // violation, instantiation of another test class
            new MyOtherTest()

            // no violation; same class
            def input = MyTest.getResourceAsStream('sample.txt')
        }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitAssertAlwaysFailsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Assert Always Fails]]></name>
    <internalKey><![CDATA[JUnitAssertAlwaysFails]]></internalKey>
    <description><![CDATA[<p>Rule that checks for JUnit <code>assert()</code> method calls with constant or literal arguments such that the
assertion always fails. This includes:</p>
<ul>
<li><code>assertTrue(false)</code></li>
<li><code>assertTrue(0)</code></li>
<li><code>assertTrue('')</code></li>
<li><code>assertTrue([])</code></li>
<li><code>assertTrue([:])</code></li>
<li><code>assertFalse(true)</code></li>
<li><code>assertFalse('abc')</code></li>
<li><code>assertFalse(99)</code></li>
<li><code>assertFalse([123])</code></li>
<li><code>assertFalse([a:123)</code></li>
<li><code>assertNull(CONSTANT)</code>.</li>
<li><code>assertNull([])</code>.</li>
<li><code>assertNull([123])</code>.</li>
<li><code>assertNull([:])</code>.</li>
<li><code>assertNull([a:123])</code>.</li>
</ul>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitAssertAlwaysSucceedsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Assert Always Succeeds]]></name>
    <internalKey><![CDATA[JUnitAssertAlwaysSucceeds]]></internalKey>
    <description><![CDATA[<p>Rule that checks for JUnit <code>assert()</code> method calls with constant arguments such that the
assertion always succeeds. This includes:</p>
<ul>
<li><code>assertTrue(true)</code></li>
<li><code>assertTrue(99)</code></li>
<li><code>assertTrue('abc')</code></li>
<li><code>assertTrue([123])</code></li>
<li><code>assertTrue([a:123])</code></li>
<li><code>assertFalse(false)</code></li>
<li><code>assertFalse('')</code></li>
<li><code>assertFalse(0)</code></li>
<li><code>assertFalse([])</code></li>
<li><code>assertFalse([:)</code></li>
<li><code>assertNull(null)</code></li>
</ul>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitFailWithoutMessageRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Fail Without Message]]></name>
    <internalKey><![CDATA[JUnitFailWithoutMessage]]></internalKey>
    <description><![CDATA[<p>This rule detects JUnit calling the <code>fail()</code> method without an argument. For better error reporting you
should always provide a message.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitLostTestRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Lost Test]]></name>
    <internalKey><![CDATA[JUnitLostTest]]></internalKey>
    <description><![CDATA[<p>This rule checks for classes that import JUnit 4 classes and contain a <code>public</code>, instance, <code>void</code>,
no-arg method named <em>test</em>* that is not abstract and not annotated with the JUnit 4 <code>@Test</code> annotation.</p>
<p>Note: This rule should be disabled for Grails 2.x projects, since the Grails test framework can use
AST Transformations to automatically annotate test methods.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Example of violations:</p>
<pre><code>    import org.junit.Test

    class MyTestCase {
        void testMe() { }           // missing @Test annotation
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitPublicFieldRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[JUnit Public Field]]></name>
    <internalKey><![CDATA[JUnitPublicField]]></internalKey>
    <description><![CDATA[<p>Checks for public fields on a JUnit test class.  There is usually no reason to have a public
field (even a constant) on a test class.</p>
<p>Fields within interfaces and fields annotated with @Rule are ignored.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Example of violations:</p>
<pre><code>    import org.junit.Test
    class MyTestCase {
        public int count                        // violation
        public static final MAX_VALUE = 1000    // violation

        @Test
        void testMe() { }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitPublicNonTestMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Public Non Test Method]]></name>
    <internalKey><![CDATA[JUnitPublicNonTestMethod]]></internalKey>
    <description><![CDATA[<p>Rule that checks if a JUnit test class contains public methods other than standard test methods,
JUnit framework methods or methods with JUnit annotations.</p>
<p>The following public methods are ignored by this rule:</p>
<ul>
<li>Zero-argument methods with names starting with &quot;test&quot;</li>
<li>The <code>setUp()</code> and <code>tearDown()</code> methods</li>
<li>Methods annotated with <code>@Test</code></li>
<li>Methods annotated with <code>@Before</code>, <code>@BeforeAll</code>, <code>@BeforeClass</code> and <code>@BeforeEach</code></li>
<li>Methods annotated with <code>@After</code>, <code>@AfterAll</code>, <code>@AfterClass</code> and <code>@AfterEach</code></li>
<li>Methods annotated with <code>@Disabled</code> and <code>@Ignore</code></li>
<li>Methods annotated with <code>@Override</code></li>
</ul>
<p>Public, non-test methods on a test class violate conventional usage of test classes,
and they typically break encapsulation unnecessarily.</p>
<p>Public, non-test methods may also hide unintentional <em>'Lost Tests'</em>. For instance, the test method
declaration may (unintentionally) include methods parameters, and thus be ignored by JUnit. Or the
method may (unintentionally) not follow the &quot;test..&quot; naming convention and not have the @Test annotation,
and thus be ignored by JUnit.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
    <param>
      <key>ignoreMethodsWithAnnotations</key>
      <description><![CDATA[Specifies one or more (comma-separated) annotation names. Methods annotated with the annotations are ignored by this rule.]]></description>
      <defaultValue>After,AfterAll,AfterClass, AfterEach,Before,BeforeAll, BeforeClass,BeforeEach, Disabled,Ignore, Override,Test</defaultValue>
    </param>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitPublicPropertyRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Public Property]]></name>
    <internalKey><![CDATA[JUnitPublicProperty]]></internalKey>
    <description><![CDATA[<p>Checks for public properties defined on JUnit test classes. There is typically no need to
expose a public property (with public <em>getter</em> and <em>setter</em> methods) on a test class.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Example of violations:</p>
<pre><code>    import org.junit.Test
    class MyTestCase {
        static String id    // violation
        def helper          // violation
        String name         // violation

        @Test
        void testMe() { }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
    <param>
      <key>ignorePropertyNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) property names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitSetUpCallsSuperRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Set Up Calls Super]]></name>
    <internalKey><![CDATA[JUnitSetUpCallsSuper]]></internalKey>
    <description><![CDATA[<p>Rule that checks that if the JUnit <code>setUp</code> method is defined, that it includes a call to
<code>super.setUp()</code>.</p>
<p>This rule ignored methods annotated with <code>@Before</code> or <code>@BeforeClass</code>.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitStyleAssertionsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[JUnit Style Assertions]]></name>
    <internalKey><![CDATA[JUnitStyleAssertions]]></internalKey>
    <description><![CDATA[<p>This rule detects calling JUnit style assertions like <code>assertEquals</code>, <code>assertTrue</code>,
<code>assertFalse</code>, <code>assertNull</code>, <code>assertNotNull</code>. Groovy 1.7 ships with a feature called the
&quot;power assert&quot;, which is an assert statement with better error reporting. This is preferable to the
JUnit assertions.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitTearDownCallsSuperRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Tear Down Calls Super]]></name>
    <internalKey><![CDATA[JUnitTearDownCallsSuper]]></internalKey>
    <description><![CDATA[<p>Rule that checks that if the JUnit <code>tearDown</code> method is defined, that it includes a call to
<code>super.tearDown()</code>.</p>
<p>This rule ignored methods annotated with <code>@After</code> or <code>@AfterClass</code>.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitTestMethodWithoutAssertRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[JUnit Test Method Without Assert]]></name>
    <internalKey><![CDATA[JUnitTestMethodWithoutAssert]]></internalKey>
    <description><![CDATA[<p>This rule searches for test methods that do not contain assert statements. Either the test method is missing assert
statements, which is an error, or the test method contains custom assert statements that do not follow a proper assert
naming convention. Test methods are defined as public void methods that begin with the work test or have a @Test
annotation. By default this rule applies to the default test class names, but this can be changed using the rule's
applyToClassNames property. An assertion is defined as either using the <code>assert</code> keyword or invoking a method that
starts with the work assert, like assertEquals, assertNull, or assertMyClassIsSimilar. Also, any method named
<code>should.*</code> also counts as an assertion so that <code>shouldFail</code> methods do not trigger an assertion, any method
that starts with <code>fail** counts as an assertion, and any method that starts with </code>verify` counts as an assertion.
Since version 0.23 CodeNarc has support for JUnit's ExpectedException.</p>
<p>What counts as an assertion method can be overridden using the assertMethodPatterns property of the rule. The
default value is this comma separated list of regular expressions:</p>
<pre><code>    String assertMethodPatterns = 'assert.*,should.*,fail.*,verify.*,expect.*'
</code></pre>
<p>If you'd like to add any method starting with 'ensure' to the ignores then you would set the value to this:</p>
<pre><code>    'assert.*,should.*,fail.*,verify.*,ensure.*'
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitUnnecessarySetUpRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[JUnit Unnecessary Set Up]]></name>
    <internalKey><![CDATA[JUnitUnnecessarySetUp]]></internalKey>
    <description><![CDATA[<p>Rule that checks checks for JUnit <code>setUp()</code> methods that contain only a call to
<code>super.setUp()</code>. The method is then unnecessary.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Here is an example of a violation:</p>
<pre><code>    class MyTest extends TestCase {
        void setUp() {              // violation
            super.setUp()
        }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitUnnecessaryTearDownRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[JUnit Unnecessary Tear Down]]></name>
    <internalKey><![CDATA[JUnitUnnecessaryTearDown]]></internalKey>
    <description><![CDATA[<p>Rule that checks checks for JUnit <code>tearDown()</code> methods that contain only a call to
<code>super.tearDown()</code>. The method is then unnecessary.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Here is an example of a violation:</p>
<pre><code>    class MyTest extends TestCase {
        void tearDown() {               // violation
            super.tearDown()
        }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitUnnecessaryThrowsExceptionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[JUnit Unnecessary Throws Exception]]></name>
    <internalKey><![CDATA[JUnitUnnecessaryThrowsException]]></internalKey>
    <description><![CDATA[<p>Check for <code>throws</code> clauses on JUnit test methods. That is not necessary in Groovy.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Example of violations:</p>
<pre><code>    @Test
    void shouldDoStuff() throws Exception { }           // violation

    @BeforeClass void initialize() throws Exception { } // violation
    @Before void setUp() throws RuntimeException { }    // violation
    @After void tearDown() throws Exception { }         // violation
    @AfterClass void cleanUp() throws Exception { }     // violation
    @Ignore void ignored() throws Exception { }         // violation

    class MyTest extends GroovyTestCase {
        void test1() throws Exception { }               // violation
        public void test2() throws IOException { }      // violation
    }

</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.junit.SpockIgnoreRestUsedRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Spock Ignore Rest Used]]></name>
    <internalKey><![CDATA[SpockIgnoreRestUsed]]></internalKey>
    <description><![CDATA[<p>If Spock's <code>@IgnoreRest</code> annotation appears on any method, all non-annotated test methods are not executed.
This behaviour is almost always unintended. It's fine to use @IgnoreRest locally during development, but when
committing code, it should be removed.</p>
<p>The <em>specificationClassNames</em> and <em>specificationSuperclassNames</em> properties determine which classes are considered
Spock <em>Specification</em> classes.</p>
<p>Example of violations:</p>
<pre><code>    public class MySpec extends spock.lang.Specification {
        @spock.lang.IgnoreRest
        def &quot;my first feature&quot;() {
            expect: false
        }

        def &quot;my second feature&quot;() {
            given: def a = 2

            when: a *= 2

            then: a == 4
        }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
    <param>
      <key>specificationClassNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) class names that should be treated as Spock Specification classes. The class names may optionally contain wildcards (*,?), e.g. "*Spec".]]></description>
    </param>
    <param>
      <key>specificationSuperclassNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) class names that should be treated as Spock Specification superclasses. In other words, a class that extends a matching class name is considered a Spock Specification . The class names may optionally contain wildcards (*,?), e.g. "*Spec".]]></description>
      <defaultValue>*Specification</defaultValue>
    </param>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.junit.UnnecessaryFailRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unnecessary Fail]]></name>
    <internalKey><![CDATA[UnnecessaryFail]]></internalKey>
    <description><![CDATA[<p>In a unit test, catching an exception and immediately calling Assert.fail() is pointless and hides the stack trace.
It is better to rethrow the exception or not catch the exception at all.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>Example of violations:</p>
<pre><code>    public void testSomething() {
        try {
            something()
        } catch (Exception e) {
            fail(e.message)
        }

        try {
            something()
        } catch (Exception e) {
            fail()
        }
    }
</code></pre>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertEqualsInsteadOfAssertTrueRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert Equals Instead Of Assert True]]></name>
    <internalKey><![CDATA[UseAssertEqualsInsteadOfAssertTrue]]></internalKey>
    <description><![CDATA[<p>This rule detects JUnit assertions in object equality. These assertions should be made by more specific methods,
like <code>assertEquals</code>.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertFalseInsteadOfNegationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Assert False Instead Of Negation]]></name>
    <internalKey><![CDATA[UseAssertFalseInsteadOfNegation]]></internalKey>
    <description><![CDATA[<p>In unit tests, if a condition is expected to be false then there is no sense using <code>assertTrue</code> with the negation operator.
For instance, <code>assertTrue(!condition)</code> can always be simplified to <code>assertFalse(condition)</code>.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertTrueInsteadOfAssertEqualsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert True Instead Of Assert Equals]]></name>
    <internalKey><![CDATA[UseAssertTrueInsteadOfAssertEquals]]></internalKey>
    <description><![CDATA[<p>This rule detects JUnit calling <code>assertEquals</code> where the first parameter is a boolean. These assertions
should be made by more specific methods, like <code>assertTrue</code> or <code>assertFalse</code>.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
<p>All of the following examples can be simplified to assertTrue or remove the true literal:</p>
<pre><code>    assertEquals(true, foo())
    assertEquals(&quot;message&quot;, true, foo())
    assertEquals(foo(), true)
    assertEquals(&quot;message&quot;, foo(), true)
    assertEquals(false, foo())
    assertEquals(&quot;message&quot;, false, foo())
    assertEquals(foo(), false)
    assertEquals(&quot;message&quot;, foo(), false)

    assert true == foo()                    // violation only if checkAssertStatements == true
    assert foo() == true : &quot;message&quot;        // violation only if checkAssertStatements == true
    assert false == foo()                   // violation only if checkAssertStatements == true
    assert foo() == false : &quot;message&quot;       // violation only if checkAssertStatements == true
</code></pre>
]]></description>
    <tag>junit</tag>
    <param>
      <key>checkAssertStatements</key>
      <description><![CDATA[If "true", then also check assert statements, e.g. "assert x == true".]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertTrueInsteadOfNegationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Assert True Instead Of Negation]]></name>
    <internalKey><![CDATA[UseAssertTrueInsteadOfNegation]]></internalKey>
    <description><![CDATA[<p>In unit tests, if a condition is expected to be true then there is no sense using <code>assertFalse</code> with the negation operator.
For instance, <code>assertFalse(!condition)</code> can always be simplified to <code>assertTrue(condition)</code>.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertNullInsteadOfAssertEqualsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert Null Instead Of Assert Equals]]></name>
    <internalKey><![CDATA[UseAssertNullInsteadOfAssertEquals]]></internalKey>
    <description><![CDATA[<p>This rule detects JUnit calling <code>assertEquals</code> where the first or second parameter is <code>null</code>.
These assertion should be made against the <code>assertNull</code> method instead.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertSameInsteadOfAssertTrueRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert Same Instead Of Assert True]]></name>
    <internalKey><![CDATA[UseAssertSameInsteadOfAssertTrue]]></internalKey>
    <description><![CDATA[<p>This rule detects JUnit calling <code>assertTrue</code> or <code>assertFalse</code> where the first or second parameter
is an <code>Object#is()</code> call testing for reference equality. These assertion should be made against the
<code>assertSame</code> or <code>assertNotSame</code> method instead.</p>
<p>This rule sets the default value of the <em>applyToClassNames</em> property to only match class names
ending in 'Spec', 'Test', 'Tests' or 'TestCase'.</p>
]]></description>
    <tag>junit</tag>
  </rule>

  <!-- logging rules -->

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.LoggerForDifferentClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Logger For Different Class]]></name>
    <internalKey><![CDATA[LoggerForDifferentClass]]></internalKey>
    <description><![CDATA[<p>Checks for instantiating a logger for a class other than the current class. Checks for logger
instantiations for <strong>Log4J</strong>, <strong>SLF4J</strong>, <strong>Logback</strong>, <strong>Apache Commons Logging</strong> and <strong>Java Logging API
(java.util.logging)</strong>.</p>
<p>This rule contains a parameter <code>allowDerivedClasses</code>. When set, a logger may be created about this.getClass().</p>
<p>Limitations:</p>
<ul>
<li>Only checks Loggers instantiated within a class field or property (not variables or expressions within a method)</li>
<li>For <strong>Log4J</strong>: Does not catch Logger instantiations if you specify the full package name for the <code>Logger</code>
class: e.g.  <code>org.apache.log4.Logger.getLogger(..)</code></li>
<li>For <strong>SLF4J</strong> and <strong>Logback</strong>: Does not catch Log instantiations if you specify the full package name for the
<code>LoggerFactory</code> class: e.g. <code>org.slf4j.LoggerFactory.getLogger(..)</code></li>
<li>For <strong>Commons Logging</strong>: Does not catch Log instantiations if you specify the full package name for the
<code>LogFactory</code> class: e.g.  <code>org.apache.commons.logging.LogFactory.getLog(..)</code></li>
<li>For <strong>Java Logging API</strong>: Does not catch Logger instantiations if you specify the full package name for the
<code>Logger</code> class: e.g.  <code>java.util.logging.Logger.getLogger(..)</code></li>
</ul>
<p>Here are examples of <strong>Log4J</strong> or <strong>Java Logging API</strong> code that cause violations:</p>
<pre><code>    class MyClass {
        private static final LOG = LoggerFactory.getLogger(SomeOtherClass)  // violation
        def log1 = LoggerFactory.getLogger(SomeOtherClass.class)            // violation
        def log2 = LoggerFactory.getLogger(SomeOtherClass.class.name)       // violation
    }
</code></pre>
<p>Here are examples of <strong>Commons Logging</strong> code that cause violations:</p>
<pre><code>    class MyClass {
        private static final LOG = LogFactory.getLog(SomeOtherClass)    // violation
        Log log1 = LogFactory.getLog(SomeOtherClass.class)              // violation
        def log2 = LogFactory.getLog(SomeOtherClass.class.getName())    // violation
    }
</code></pre>
<p>Here are examples of code that does NOT cause violations:</p>
<pre><code>    // Log4J or Java Logging API

    class MyClass {
        private static final LOG = LoggerFactory.getLogger(MyClass)                    // ok
        def log2 = LoggerFactory.getLogger(MyClass.class)                              // ok
        private static log3 = LoggerFactory.getLogger(MyClass.getClass().getName())    // ok
        private static log4 = LoggerFactory.getLogger(MyClass.getClass().name)         // ok
        private static log5 = LoggerFactory.getLogger(MyClass.class.getName())         // ok
        private static log6 = LoggerFactory.getLogger(MyClass.class.name)              // ok
    }

    // Commons Logging

    class MyClass {
        private static final LOG = LogFactory.getLog(MyClass)                   // ok
        def log2 = LogFactory.getLog(MyClass.class)                             // ok
        private static log3 = LogFactory.getLog(MyClass.getClass().getName())   // ok
        private static log4 = LogFactory.getLog(MyClass.getClass().name)        // ok
        private static log5 = LogFactory.getLog(MyClass.class.getName())        // ok
        private static log6 = LogFactory.getLog(MyClass.class.name)             // ok
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.LoggingSwallowsStacktraceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Logging Swallows Stacktrace]]></name>
    <internalKey><![CDATA[LoggingSwallowsStacktrace]]></internalKey>
    <description><![CDATA[<p>If you are logging an exception then the proper API is to call error(Object, Throwable), which will log the message and the exception stack trace. If you call error(Object) then the stacktrace may not be logged.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.LoggerWithWrongModifiersRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Logger With Wrong Modifiers]]></name>
    <internalKey><![CDATA[LoggerWithWrongModifiers]]></internalKey>
    <description><![CDATA[<p>Logger objects should be declared private, static and final.</p>
<p>This rule has a property: <code>allowProtectedLogger</code>, which defaults to false. Set it to true if you believe
subclasses should have access to a Logger in a parent class and that Logger should be declared protected or public.</p>
<p>This rule has a property: <code>allowNonStaticLogger</code>, which defaults to false. Set it to true if you believe
a logger should be allowed to be non-static.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.MultipleLoggersRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Multiple Loggers]]></name>
    <internalKey><![CDATA[MultipleLoggers]]></internalKey>
    <description><![CDATA[<p>This rule catches classes that have more than one logger object defined. Typically, a class has zero or one logger objects.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.PrintlnRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Println]]></name>
    <internalKey><![CDATA[Println]]></internalKey>
    <description><![CDATA[<p>Checks for calls to <code>this.print()</code>, <code>this.println()</code> or <code>this.printf()</code>. Consider using
a standard logging facility instead.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.PrintStackTraceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Print Stack Trace]]></name>
    <internalKey><![CDATA[PrintStackTrace]]></internalKey>
    <description><![CDATA[<p>Checks for calls to <code>Throwable.printStackTrace()</code> or <code>StackTraceUtils.printSanitizedStackTrace(Throwable)</code>.
Consider using a standard logging facility instead.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.SystemErrPrintRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Err Print]]></name>
    <internalKey><![CDATA[SystemErrPrint]]></internalKey>
    <description><![CDATA[<p>Checks for calls to <code>System.err.print()</code>, <code>System.err.println()</code> or <code>System.err.printf()</code>.
Consider using a standard logging facility instead.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.SystemOutPrintRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Out Print]]></name>
    <internalKey><![CDATA[SystemOutPrint]]></internalKey>
    <description><![CDATA[<p>Checks for calls to <code>System.out.print()</code>, <code>System.out.println()</code> or <code>System.out.printf()</code>.
Consider using a standard logging facility instead.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- naming rules -->

  <rule>
    <key>org.codenarc.rule.naming.AbstractClassNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract Class Name]]></name>
    <internalKey><![CDATA[AbstractClassName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of an abstract class matches the regular expression specified in the
<strong>regex</strong> property. If that property is null or empty, then this rule is not applied
(i.e., it does nothing). It defaults to null, so this rule must be explicitly configured to be
active. This rule ignores interfaces and is applied only to abstract classes.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the abstract class name. If null or empty, then this rule does nothing.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.ClassNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Name]]></name>
    <internalKey><![CDATA[ClassName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of a class matches a regular expression. By default it checks that the
class name starts with an uppercase letter and is followed by zero or more word characters
(letters, numbers or underscores) or dollar signs ($).</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the class name. It is required and cannot be null or empty.]]></description>
      <defaultValue>([A-Z]\w*\$?)*</defaultValue>
    </param>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.naming.ClassNameSameAsFilenameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Name Same As Filename]]></name>
    <internalKey><![CDATA[ClassNameSameAsFilename]]></internalKey>
    <description><![CDATA[<p>Reports files containing only one top level class / enum / interface which is named differently than the file.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.24 -->
  <rule>
    <key>org.codenarc.rule.naming.ClassNameSameAsSuperclassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Name Same As Superclass]]></name>
    <internalKey><![CDATA[ClassNameSameAsSuperclass]]></internalKey>
    <description><![CDATA[<p>Checks for any class that has an identical name to its superclass, other than the package. This can be very confusing.</p>
<p>Also see FindBugs NM_SAME_SIMPLE_NAME_AS_SUPERCLASS rule.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass extends other.MyClass         // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.naming.ConfusingMethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Confusing Method Name]]></name>
    <internalKey><![CDATA[ConfusingMethodName]]></internalKey>
    <description><![CDATA[<p>Checks for very confusing method names. The referenced methods have names that differ only by capitalization.
This is very confusing because if the capitalization were identical then one of the methods would override
the other.</p>
<p>Also, violations are triggered when methods and fields have very similar names.</p>
<pre><code>    class MyClass {
        int total
        int total() {
            1
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.naming.FactoryMethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Factory Method Name]]></name>
    <internalKey><![CDATA[FactoryMethodName]]></internalKey>
    <description><![CDATA[<p>A factory method is a method that creates objects, and they are typically named either buildFoo(), makeFoo(), or
createFoo(). This rule enforces that only one naming convention is used. It defaults to allowing makeFoo(), but that
can be changed using the property <code>regex</code>. The regex is a negative expression; it specifically bans
methods named build* or create*. However, methods named <code>build</code> or <code>build*</code> receive some special treatment because of the
popular Builder Pattern. If the 'build' method is in a class named *Builder then it does not cause a violation.</p>
<p>Builder methods are slightly different than factory methods.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {

        // violation. Factory methods should be named make()
        def create() {
        }

        // violation. Factory methods should be named make()
        def createSomething() {
        }

        // violation. Builder method not in class named *Builder
        def build() {
        }

        // violation. Builder method not in class named *Builder
        def buildSomething() {
        }

        // this is OK because it is called make
        def make() {
        }

        // this is also OK
        def makeSomething() {
        }

        // OK, overriding a parent
        @Override
        build() { }

    }

    class WidgetBuilder {

        // OK, the class name ends in Builder
        def build() {
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the default regular expression used to validate the method name. It is required and cannot be null or empty.]]></description>
      <defaultValue>(build.|create.)</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.FieldNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Field Name]]></name>
    <internalKey><![CDATA[FieldName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of each field matches a regular expression. By default it checks that
fields that are not <em>static final</em> have field names that start with a lowercase letter and contains
only letters or numbers. By default, <em>static final</em> field names start with an uppercase letter and
contain only uppercase letters, numbers and underscores.</p>
<p><strong>NOTE:</strong> This rule checks only regular <em>fields</em> of a class, not <em>properties</em>. In Groovy,
<em>properties</em> are fields declared with no access modifier (public, protected, private). Thus,
this rule only checks fields that specify an access modifier. For naming of <em>properties</em>,
see <code>PropertyNameRule</code>.</p>
<p>The order of precedence for the regular expression properties is: <strong>staticFinalRegex</strong>,
<strong>finalRegex</strong>, <strong>staticRegex</strong> and finally <strong>regex</strong>. In other words, the first
regex in that list matching the modifiers for the field is the one that is applied for the field name validation.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>finalRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "final" field names. It is optional. If not set, then "final" fields that are non-"static" are validated using regex.]]></description>
    </param>
    <param>
      <key>ignoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
      <defaultValue>serialVersionUID</defaultValue>
    </param>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the default regular expression used to validate the field name. It is required and cannot be null or empty.]]></description>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
    <param>
      <key>staticFinalRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "static final" field names. It is optional. If not set, then "static final" fields are validated using finalRegex, staticRegex or regex.]]></description>
      <defaultValue>[A-Z][A-Z0-9_]*</defaultValue>
    </param>
    <param>
      <key>staticRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "static" field names. It is optional. If not set, then "static" fields that are non-"final" are validated using regex.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.InterfaceNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Interface Name]]></name>
    <internalKey><![CDATA[InterfaceName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of an interface matches the regular expression specified in the
<strong>regex</strong> property. If that property is null or empty, then this rule is not applied
(i.e., it does nothing). It defaults to null, so this rule must be explicitly configured to be
active.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the name of an interface. If null or empty, then this rule does nothing.]]></description>
    </param>
  </rule>

  <!-- since 0.24 -->
  <rule>
    <key>org.codenarc.rule.naming.InterfaceNameSameAsSuperInterfaceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Interface Name Same As Super Interface]]></name>
    <internalKey><![CDATA[InterfaceNameSameAsSuperInterface]]></internalKey>
    <description><![CDATA[<p>Checks for any interface that has an identical name to its super-interface, other than the package. This can be very confusing.</p>
<p>Example of violations:</p>
<pre><code>    interface MyInterface extends other.MyInterface { }     // violation
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.MethodNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method Name]]></name>
    <internalKey><![CDATA[MethodName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of each method matches a regular expression. By default it checks that the
method name starts with a lowercase letter. Implicit method names are ignored (i.e., 'main' and 'run'
methods automatically created for Groovy scripts).</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the method name. It is required and cannot be null or empty.]]></description>
      <defaultValue>[a-z]\w*</defaultValue>
    </param>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.naming.ObjectOverrideMisspelledMethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Object Override Misspelled Method Name]]></name>
    <internalKey><![CDATA[ObjectOverrideMisspelledMethodName]]></internalKey>
    <description><![CDATA[<p>Verifies that the names of the most commonly overridden methods of <code>Object</code>: <code>equals</code>,
<code>hashCode</code> and <code>toString</code>, are correct.</p>
<p>Here are some examples of code that produces violations:</p>
<pre><code>    boolean equal(Object o) {}                  // violation
    boolean equal(int other) {}                 // ok; wrong param type
    boolean equal(Object o, int other) {}       // ok; too many params

    boolean equaLS(Object o) {}                 // violation

    int hashcode() {}                           // violation
    int hashCOde() {}                           // violation
    int hashcode(int value) {}                  // ok; not empty params

    String tostring() {}                        // violation
    String toSTring() {}                        // violation
    String tostring(int value) {}               // ok; not empty params
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.PackageNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Package Name]]></name>
    <internalKey><![CDATA[PackageName]]></internalKey>
    <description><![CDATA[<p>Verifies that the package name of a class matches a regular expression. By default it checks that the
package name consists of only lowercase letters and numbers, separated by periods.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>packageNameRequired</key>
      <description><![CDATA[Indicates whether a package name declaration is required for all classes.]]></description>
      <defaultValue>false</defaultValue>
    </param>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the package name. It is required and cannot be null or empty.]]></description>
      <defaultValue>[a-z]+[a-z0-9](\.[a-z0-9]+)</defaultValue>
    </param>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.naming.PackageNameMatchesFilePathRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Package Name Matches File Path]]></name>
    <internalKey><![CDATA[PackageNameMatchesFilePath]]></internalKey>
    <description><![CDATA[<p>A package source file's path should match the package declaration.</p>
<p>NOTE: This is a file-based rule, rather than an AST-based rule, so the <em>applyToClassNames</em> and
<em>doNotApplyToClassNames</em> rule configuration properties are not available. See
<a href="./codenarc-configuring-rules.html#standard-properties-for-configuring-rules">Standard Properties for Configuring Rules</a>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>groupId</key>
      <description><![CDATA[Specifies the common group id part of a package name, that will appear within all checked package names. It must also map to the file path for the corresponding source file. <br/><br/> For instance, a groupId of "org.sample" means that for all classes that specify a package, that package name must include "org.sample", and the source file must exist under an "org/sample" directory. Then, a "MyClass" class in a "org.sample.util" package must be defined in a "MyClass.groovy" file within a "org/sample/util" directory. That directory can be the child of any arbitrary root path, e.g. "src/main/groovy".<br/><br/> To find the sub-path relevant for the package the rule searches for the first appearance of groupId in the file path. It's required to configure this. <br/><br/> If "groupId" is null or empty, this rule does nothing.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.ParameterNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Parameter Name]]></name>
    <internalKey><![CDATA[ParameterName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of each parameter matches a regular expression. This rule applies to method parameters,
constructor parameters and closure parameters. By default it checks that parameter names start with a
lowercase letter and contains only letters or numbers.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreParameterNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) parameter names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the parameter name. It is required and cannot be null or empty.]]></description>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.PropertyNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Property Name]]></name>
    <internalKey><![CDATA[PropertyName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of each property matches a regular expression. By default it checks that
property names (other than <em>static final</em>) start with a lowercase letter and contains only letters or numbers.
By default, <em>static final</em> property names start with an uppercase letter and contain only uppercase
letters, numbers and underscores.</p>
<p><strong>NOTE:</strong> This rule checks only <em>properties</em> of a class, not regular <em>fields</em>. In Groovy,
<em>properties</em> are fields declared with no access modifier (public, protected, private).
For naming of regular <em>fields</em>, see <code>FieldNameRule</code>.</p>
<p>The order of precedence for the regular expression properties is: <strong>staticFinalRegex</strong>, <strong>finalRegex</strong>,
<strong>staticRegex</strong> and finally <strong>regex</strong>. In other words, the first regex in that list matching the
modifiers for the property is the one that is applied for the field name validation.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>finalRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "final" property names. It is optional. If not set, then "final" properties that are non-"static" are validated using regex.]]></description>
    </param>
    <param>
      <key>ignorePropertyNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) property names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the default regular expression used to validate the property name. It is required and cannot be null or empty.]]></description>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
    <param>
      <key>staticFinalRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "static final" property names. It is optional. If not set, then "static final" property are validated using finalRegex, staticRegex or regex.]]></description>
      <defaultValue>[A-Z][A-Z0-9_]*</defaultValue>
    </param>
    <param>
      <key>staticRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "static" property names. It is optional. If not set, then "static" properties that are non-"final" are validated using regex.]]></description>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.VariableNameRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Variable Name]]></name>
    <internalKey><![CDATA[VariableName]]></internalKey>
    <description><![CDATA[<p>Verifies that the name of each variable matches a regular expression. By default, this rule checks that
variable names start with a lowercase letter and contain only letters or numbers.</p>
<p>Variables annotated with @Field are ignored.</p>
<p>NOTE: Until CodeNarc 2.0, the default naming pattern for <code>final</code> variable names was that they start with an uppercase letter and contain only
uppercase letters, numbers and underscores (i.e., like <em>constants</em>). Starting with CodeNarc 2.0, that has been changed so that <code>finalRegex</code>
defaults to <code>null</code> and thus <code>final</code> variable names are treated like regular variables. See <a href="https://github.com/CodeNarc/CodeNarc/issues/467">#467</a>.
To restore that previous behavior, set <code>finalRegex</code> to <code>[A-Z][A-Z0-9_]*</code>.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>finalRegex</key>
      <description><![CDATA[Specifies the regular expression used to validate "final" variable names. It is optional. If not set, then regex is used to validate "final" variable names.]]></description>
    </param>
    <param>
      <key>ignoreVariableNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) variable names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>regex</key>
      <description><![CDATA[Specifies the regular expression used to validate the variable name. It is required and cannot be null or empty.]]></description>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
  </rule>

  <!-- security rules -->

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.FileCreateTempFileRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[File Create Temp File]]></name>
    <internalKey><![CDATA[FileCreateTempFile]]></internalKey>
    <description><![CDATA[<p>The File.createTempFile() method is insecure, and has been deprecated by the ESAPI secure coding library.
It has been replaced by the ESAPI Randomizer.getRandomFilename(String) method.</p>
<p>For more information see the ESAPI website: http://code.google.com/p/owasp-esapi-java/
and the Randomizer Javadoc: <a href="http://owasp-esapi-java.googlecode.com/svn/trunk_doc/latest/org/owasp/esapi/Randomizer.html">http://owasp-esapi-java.googlecode.com/svn/trunk_doc/latest/org/owasp/esapi/Randomizer.html</a></p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.InsecureRandomRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Insecure Random]]></name>
    <internalKey><![CDATA[InsecureRandom]]></internalKey>
    <description><![CDATA[<p>Reports usages of <code>java.util.Random</code>, which can produce very predictable results. If two instances of Random are created with the same seed and sequence of method calls, they will generate the exact same results.
Use <code>java.security.SecureRandom</code> instead, which provides a cryptographically strong random number generator. SecureRandom uses PRNG, which means they are using a deterministic algorithm to produce a pseudo-random number from a true random seed. SecureRandom produces non-deterministic output.</p>
<p>By default, this rule ignores test classes are ignored.</p>
<p>For more information see: <a href="http://www.klocwork.com/products/documentation/current/Checkers:SV.RANDOM">http://www.klocwork.com/products/documentation/current/Checkers:SV.RANDOM</a></p>
<p>Example of violations:</p>
<pre><code>     def r1 = new Random()
     def r2 = new java.util.Random()
     Math.random()
     java.lang.Math.random()

     // this is OK
     new java.security.SecureRandom()
     new SecureRandom()
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.JavaIoPackageAccessRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Java Io Package Access]]></name>
    <internalKey><![CDATA[JavaIoPackageAccess]]></internalKey>
    <description><![CDATA[<p>This rule reports violations of the Enterprise JavaBeans specification by using the java.io package to access files or the file system.</p>
<p>The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that
the bean will be portable and behave consistently in any EJB container [1].</p>
<p>In this case, the program violates the following EJB guideline: &quot;An enterprise bean must not use the java.io package to attempt to access files and directories in the file system.&quot;</p>
<p>A requirement that the specification justifies in the following way: &quot;The file system APIs are not well-suited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.&quot;</p>
<p>REFERENCES</p>
<ul>
<li>[1] Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 576</li>
<li>[2] The Enterprise JavaBeans 2.1 Specification Sun Microsystems</li>
</ul>
<p>By default, this rule is not applied to tests and test cases.</p>
<p>Example of violations:</p>
<pre><code>    FileSystem.getFileSystem()          // any method on FileSystem
    FileSystem.fileSystem.delete(aFile) // property access of FileSystem

    // shouldn't create files
    new File(name)
    new File(name, parent)

    // don't create file readers
    new FileReader(name)

    // don't create file output streams
    new FileOutputStream(name)
    new FileOutputStream(name, true)

    // don't create random access file
    new RandomAccessFile(name, parent)
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.NonFinalPublicFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Non Final Public Field]]></name>
    <internalKey><![CDATA[NonFinalPublicField]]></internalKey>
    <description><![CDATA[<p>Finds code that violates secure coding principles for mobile code by declaring a member variable public but not final.</p>
<p>All public member variables in an Applet and in classes used by an Applet should be declared final to prevent an attacker
from manipulating or gaining unauthorized access to the internal state of the Applet.</p>
<p>References:</p>
<ul>
<li>Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 493</li>
<li>G. McGraw Securing Java. Chapter 7: Java Security Guidelines</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.NonFinalSubclassOfSensitiveInterfaceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Non Final Subclass Of Sensitive Interface]]></name>
    <internalKey><![CDATA[NonFinalSubclassOfSensitiveInterface]]></internalKey>
    <description><![CDATA[<p>The permissions classes such as <code>java.security.Permission</code> and <code>java.security.BasicPermission</code> are designed to be extended.
Classes that derive from these permissions classes, however, must prohibit extension. This prohibition ensures that
malicious subclasses cannot change the properties of the derived class. Classes that implement sensitive interfaces
such as <code>java.security.PrivilegedAction</code> and <code>java.security.PrivilegedActionException</code> must also be declared <code>final</code> for analogous reasons.</p>
<p>For more information see: <a href="https://www.securecoding.cert.org/confluence/display/java/SEC07-J.+Classes+that+derive+from+a+sensitive+class+or+implement+a+sensitive+interface+must+be+declared+final">https://www.securecoding.cert.org/confluence/display/java/SEC07-J.+Classes+that+derive+from+a+sensitive+class+or+implement+a+sensitive+interface+must+be+declared+final</a></p>
<p>Example of violations:</p>
<pre><code>    class MyPermission extends java.security.Permission {
        MyPermission(String name) { super(name) }
        boolean implies(Permission permission) { true }
        boolean equals(Object obj) { true }
        int hashCode() { 0 }
        String getActions() { &quot;action&quot; }
    }

    class MyBasicPermission extends BasicPermission {
        MyBasicPermission(String name) { super(name) }
    }

    class MyPrivilegedAction implements PrivilegedAction {
        Object run() { 0 }
    }

    class MyPrivilegedActionException extends PrivilegedActionException {
        MyPrivilegedActionException(Exception exception) { super(exception) }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.PublicFinalizeMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Public Finalize Method]]></name>
    <internalKey><![CDATA[PublicFinalizeMethod]]></internalKey>
    <description><![CDATA[<p>Creates a violation when the program violates secure coding principles by declaring a <code>finalize()</code> method public.</p>
<p>A program should never call finalize explicitly, except to call super.finalize() inside an implementation of <code>finalize()</code>.
In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat
if an attacker can maliciously invoke one of your finalize() methods because it is declared with public access. If
you are using <code>finalize()</code> as it was designed, there is no reason to declare <code>finalize()</code> with anything other than protected
access.</p>
<p>References:</p>
<ul>
<li>Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 583</li>
<li>G. McGraw Securing Java. Chapter 7: Java Security Guidelines</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.ObjectFinalizeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Object Finalize]]></name>
    <internalKey><![CDATA[ObjectFinalize]]></internalKey>
    <description><![CDATA[<p>The finalize() method should only be called by the JVM after the object has been garbage collected.</p>
<p>While the Java Language Specification allows an object's finalize() method to be called from outside the
finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be
called more than once: the first time will be the explicit call and the last time will be the call that is made
after the object is garbage collected.</p>
<p>References: Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 586</p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.SystemExitRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Exit]]></name>
    <internalKey><![CDATA[SystemExit]]></internalKey>
    <description><![CDATA[<p>Web applications should never call System.exit(). A call to System.exit() is probably part of leftover debug
code or code imported from a non-J2EE application.</p>
<ul>
<li>
<p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) A9 Application Denial of Service</p>
</li>
<li>
<p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) APP6080 CAT II</p>
</li>
<li>
<p>[3] Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 382</p>
</li>
<li>
<p>[4] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) Requirement 6.5.9</p>
</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.UnsafeArrayDeclarationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unsafe Array Declaration]]></name>
    <internalKey><![CDATA[UnsafeArrayDeclaration]]></internalKey>
    <description><![CDATA[<p>Triggers a violation when an array is declared public, final, and static.</p>
<p>In most cases an array declared public, final and static is a bug. Because arrays are mutable objects, the
final constraint requires that the array object itself be assigned only once, but makes no guarantees
about the values of the array elements. Since the array is public, a malicious program can change the
values stored in the array. In most situations the array should be made private.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        public static final String[] myArray = init()
        public static final def myArray = [] as String[]
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- serialization rules -->

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.serialization.EnumCustomSerializationIgnoredRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Enum Custom Serialization Ignored]]></name>
    <internalKey><![CDATA[EnumCustomSerializationIgnored]]></internalKey>
    <description><![CDATA[<p>Checks for enums that define <code>writeObject()</code> or <code>writeReplace()</code> methods, or declare
<code>serialPersistentFields</code> or <code>serialVersionUID</code> fields, all of which are ignored for enums.</p>
<p>From the javadoc for <code>ObjectOutputStream</code>:</p>
<p><em>The process by which enum constants are serialized cannot be customized; any class-specific writeObject
and writeReplace methods defined by enum types are ignored during serialization. Similarly, any
serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a
fixed serialVersionUID of 0L.</em></p>
<p>Example of violations:</p>
<pre><code>    enum MyEnum {
        ONE, TWO, THREE
        private static final long serialVersionUID = 1234567L               // violation
        private static final ObjectStreamField[] serialPersistentFields =   // violation
            { new ObjectStreamField(&quot;name&quot;, String.class) }
        String name;

        Object writeReplace() throws ObjectStreamException { .. }      // violation
        private void writeObject(ObjectOutputStream stream) { .. }     // violation
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.serialization.SerialPersistentFieldsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Serial Persistent Fields]]></name>
    <internalKey><![CDATA[SerialPersistentFields]]></internalKey>
    <description><![CDATA[<p>To use a <strong>Serializable</strong> object's <code>serialPersistentFields</code> correctly, it must be declared <code>private</code>, <code>static</code>,
and <code>final</code>.</p>
<p>The Java Object Serialization Specification allows developers to manually define <code>Serializable</code> fields for a
class by specifying them in the <code>serialPersistentFields</code> array. This feature will only work if
<code>serialPersistentFields</code> is declared as <code>private</code>, <code>static</code>, and <code>final</code>. Also, specific to Groovy,
the field must be of type <code>ObjectStreamField[]</code>, and cannot be <code>Object</code>.</p>
<p>References:</p>
<pre><code>* Standards Mapping - Common Weakness Enumeration - (CWE) CWE ID 485

* Sun Microsystems, Inc. Java Sun Tutorial

[]
</code></pre>
<p>Example of violations:</p>
<pre><code>    class MyClass implements Serializable {
        public ObjectStreamField[] serialPersistentFields = [ new ObjectStreamField(&quot;myField&quot;, List.class) ] as ObjectStreamField[]
    }

    // the JVM sees the field type as Object, which won't work
    class MyOtherClass implements Serializable {
        private static final serialPersistentFields = [ new ObjectStreamField(&quot;myField&quot;, List.class) ] as ObjectStreamField[]
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.serialization.SerialVersionUIDRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Serial Version UID]]></name>
    <internalKey><![CDATA[SerialVersionUID]]></internalKey>
    <description><![CDATA[<p>A <strong>serialVersionUID</strong> is normally intended to be used with Serialization. It needs to be of type
<code>long</code>, <code>static</code>, and <code>final</code>. Also, it should be declared <code>private</code>. Providing
no modifier creates a <em>Property</em> and Groovy generates a <em>getter</em>, which is probably not intended.</p>
<p>From API javadoc for <code>java.io.Serializable</code>: <em>It is also strongly advised that explicit serialVersionUID declarations
use the private modifier where possible, since such declarations apply only to the immediately declaring
class--serialVersionUID fields are not useful as inherited members.</em></p>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.serialization.SerializableClassMustDefineSerialVersionUIDRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Serializable Class Must Define Serial Version UID]]></name>
    <internalKey><![CDATA[SerializableClassMustDefineSerialVersionUID]]></internalKey>
    <description><![CDATA[<p>Classes that implement <code>Serializable</code> should define a <code>serialVersionUID</code>. Deserialization uses this number
to ensure that a loaded class corresponds exactly to a serialized object. If you don't define serialVersionUID, the
system will make one by hashing most of your class's features. Then if you change anything, the UID will change and
Java won't let you reload old data.</p>
<p>An example of a missing serialVersionUID:</p>
<pre><code>    class MyClass implements Serializable {
        // missing serialVersionUID
    }
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- size rules -->

  <rule>
    <key>org.codenarc.rule.size.AbcMetricRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abc Metric]]></name>
    <internalKey><![CDATA[AbcMetric]]></internalKey>
    <description><![CDATA[<p>Calculates the <em>ABC</em> size metric for methods/classes and checks against configured threshold values.</p>
<p>The <strong>maxMethodAbcScore</strong> property holds the threshold value for the ABC score for each method.
If this value is non-zero, a method with an ABC score greater than this value is considered a violation.
The value does not have to be an integer (e.g., 1.7 is allowed).</p>
<p>The <strong>maxClassAverageMethodAbcScore</strong> property holds the threshold value for the average ABC
score for each class. If this value is non-zero, a class with an average ABC score value greater
than this value is considered a violation. The value does not have to be an integer.</p>
<p>The <strong>maxClassAbcScore</strong> property holds the threshold value for the total ABC
score value for each class. If this value is non-zero, a class with a total ABC score
greater than this value is considered a violation. The value does not have to be an integer.</p>
<p>This rule treats &quot;closure fields&quot; as methods. If a class field is initialized to a Closure (ClosureExpression),
then that Closure is analyzed and checked just like a method.</p>
<h3>ABC Size Metric Calculation Rules</h3>
<p>The <em>ABC</em> score is calculated as follows:
The <em>ABC</em> metric measures size by counting the number of Assignments (A), Branches (B) and
Conditions (C) and assigns a single numerical score calculated as:</p>
<p><code>|ABC| = sqrt((A*A)+(B*B)+(C*C))</code></p>
<p>The <em>ABC Metric</em> calculation rules for Groovy:</p>
<ul>
<li>Add one to the <em>assignment</em> count for each occurrence of an assignment operator, excluding constant
declarations: = *= /= %= += **= **= &amp;= |= ^= `=</li>
<li>Add one to the <em>assignment</em> count for each occurrence of an increment or decrement operator
(prefix or postfix): ++ --</li>
<li>Add one to the <em>branch</em> count for each function call or class method call.</li>
<li>Add one to the <em>branch</em> count for each occurrence of the new operator.</li>
<li>Add one to the <em>condition</em> count for each use of a conditional operator: == != *= *= * * <em>=</em> =~ ==~</li>
<li>Add one to the <em>condition</em> count for each use of the following keywords: else case default try catch ?</li>
<li>Add one to the <em>condition</em> count for each unary conditional expression.</li>
</ul>
<h3>Notes</h3>
<ul>
<li>See the <a href="http://www.softwarerenovation.com/ABCMetric.pdf">ABC Metric specification</a></li>
<li>See the <a href="http://jakescruggs.blogspot.com/2008/08/whats-good-flog-score.html">Blog post</a> describing guidelines for interpreting an ABC score</li>
<li>This <a href="https://servicios.excentia.es/confluence/display/QAX/SONAR+ABC+Metric+Plugin">(Spanish) blog post</a> about the
eXcentia Sonar ABC Metric Plugin (for Java) includes a table of risk classifications for ABC scores for both methods and classes.</li>
<li>See the <a href="http://gmetrics.sourceforge.net/gmetrics-AbcMetric.html">GMetrics ABC metric</a>.
This includes a discussion of guidelines for interpreting <em>ABC</em> scores.</li>
<li>This rule requires Groovy 1.6 (or later).</li>
<li>This rule requires the GMetrics jar on the classpath. See <a href="http://gmetrics.sourceforge.net/">GMetrics</a>.</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that that should not cause a rule violation. The names may optionally contain wildcards (*,?). Note that the ignored methods still contribute to the class complexity value.]]></description>
    </param>
    <param>
      <key>maxClassAbcScore</key>
      <description><![CDATA[The maximum ABC score allowed for a class, calculated as the total ABC score of its methods or "closure fields". If zero or null, then do not check class-level scores.]]></description>
      <defaultValue>0</defaultValue>
    </param>
    <param>
      <key>maxClassAverageMethodAbcScore</key>
      <description><![CDATA[The maximum average ABC score allowed for a class, calculated as the average score of its methods or "closure fields". If zero or null, then do not check class-level average scores.]]></description>
      <defaultValue>60</defaultValue>
    </param>
    <param>
      <key>maxMethodAbcScore</key>
      <description><![CDATA[The maximum ABC score allowed for a single method (or "closure field"). If zero or null, then do not check method-level scores.]]></description>
      <defaultValue>60</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.ClassSizeRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Class Size]]></name>
    <internalKey><![CDATA[ClassSize]]></internalKey>
    <description><![CDATA[<p>Checks if the size of a class exceeds the number of lines specified by the <strong>maxLines</strong> property.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>maxLines</key>
      <description><![CDATA[The maximum number of lines allowed in a class definition.]]></description>
      <defaultValue>1000</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.CrapMetricRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Crap Metric]]></name>
    <internalKey><![CDATA[CrapMetric]]></internalKey>
    <description><![CDATA[<p>Calculates the <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=210575">C.R.A.P.</a> (Change Risk Anti-Patterns)
metric score for methods/classes and checks against configured threshold values.</p>
<p>The <em>CRAP</em> metric score is based on the <em>cyclomatic complexity</em> and test coverage for individual methods.
A method with a <em>CRAP</em> value greater than the <strong>maxMethodCrapScore</strong> property causes a violation. Likewise,
a class that has an (average method) <em>CRAP</em> value greater than the <strong>maxClassAverageMethodCrapScore</strong>
property causes a violation.</p>
<p><strong>NOTE:</strong> This rule requires the <strong>GMetrics</strong>[3] jar, version 0.5 (or later), on the classpath, as well as
a <strong>Cobertura</strong>[4]-[6] XML coverage file. If either of these prerequisites is not available, this rule
logs a warning messages and exits (i.e., does nothing).</p>
<p>The <strong>maxMethodCrapScore</strong> property holds the threshold value for the CRAP value for each method. If this
value is non-zero, a method with a cyclomatic complexity value greater than this value is considered a violation.</p>
<p>The <strong>maxClassAverageMethodCrapScore</strong> property holds the threshold value for the average CRAP value
for each class. If this value is non-zero, a class with an average cyclomatic complexity
value greater than this value is considered a violation.</p>
<p>NOTE: This rule does NOT treat <em>closure fields</em> as methods (unlike some of the other size/complexity rules).</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>coberturaXmlFile</key>
      <description><![CDATA[The path to the Cobertura XML coverage file for the Groovy code By default, the path is relative to the classpath. But the path may be optionally prefixed by any of the valid java.net.URL prefixes, such as "file:" (to load from a relative or absolute path on the filesystem), or "http:". This property is REQUIRED.]]></description>
    </param>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that that should not cause a rule violation. The names may optionally contain wildcards (*,?). Note that the ignored methods still contribute to the class complexity value.]]></description>
    </param>
    <param>
      <key>maxClassAverageMethodCrapScore</key>
      <description><![CDATA[The maximum CRAP average metric value allowed for a class, calculated as the average CRAP value of its methods. If zero or null, then do not check the average class-level CRAP value.]]></description>
      <defaultValue>30</defaultValue>
    </param>
    <param>
      <key>maxClassCrapScore</key>
      <description><![CDATA[The maximum total CRAP metric value allowed for a class, calculated as the total CRAP value of its methods. If zero or null, then do not check class-level CRAP value.]]></description>
      <defaultValue>0</defaultValue>
    </param>
    <param>
      <key>maxMethodCrapScore</key>
      <description><![CDATA[The maximum CRAP metric value allowed for a single method. If zero or null, then do not check method-level complexity.]]></description>
      <defaultValue>30</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.CyclomaticComplexityRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Cyclomatic Complexity]]></name>
    <internalKey><![CDATA[CyclomaticComplexity]]></internalKey>
    <description><![CDATA[<p>Calculates the <em>Cyclomatic Complexity</em> for methods/classes and checks against configured threshold values.</p>
<p>The <strong>maxMethodComplexity</strong> property holds the threshold value for the cyclomatic complexity
value for each method. If this value is non-zero, a method with a cyclomatic complexity value greater than
this value is considered a violation.</p>
<p>The <strong>maxClassAverageMethodComplexity</strong> property holds the threshold value for the average cyclomatic
complexity value for each class. If this value is non-zero, a class with an average cyclomatic complexity
value greater than this value is considered a violation.</p>
<p>This rule treats &quot;closure fields&quot; as methods. If a class field is initialized to a Closure (ClosureExpression),
then that Closure is analyzed and checked just like a method.</p>
<h3>Cyclomatic Complexity Metric Calculation Rules</h3>
<p>The <em>cyclomatic complexity</em> value is calculated as follows:</p>
<p><em>Start with a initial (default) value of one (1).
Add one (1) for each occurrence of each of the following:</em></p>
<pre><code> * `if` statement

 * `while` statement

 * `for` statement

 * `case` statement

 * `catch` statement

 * `&amp;&amp;` and `||` boolean operations

 * `?:` ternary operator and `?:` *Elvis* operator.

 * `?.` null-check operator
</code></pre>
<h3>Notes</h3>
<ul>
<li>See the <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity Wikipedia entry</a></li>
<li>See the <a href="http://www.literateprogramming.com/mccabe.pdf">original paper describing Cyclomatic Complexity</a></li>
<li>See the <a href="http://gmetrics.sourceforge.net/gmetrics-CyclomaticComplexityMetric.html">GMetrics Cyclomatic Complexity metric</a>.
This includes a discussion of guidelines for interpreting <em>cyclomatic complexity</em> values.</li>
<li>This rule requires Groovy 1.6 (or later).</li>
<li>This rule requires the GMetrics jar on the classpath. See <a href="http://gmetrics.sourceforge.net/">GMetrics</a>.</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that that should not cause a rule violation. The names may optionally contain wildcards (*,?). Note that the ignored methods still contribute to the class complexity value.]]></description>
    </param>
    <param>
      <key>maxClassAverageMethodComplexity</key>
      <description><![CDATA[The maximum average cyclomatic complexity value allowed for a class, calculated as the average complexity of its methods or "closure fields". If zero or null, then do not check average class-level complexity.]]></description>
      <defaultValue>20</defaultValue>
    </param>
    <param>
      <key>maxClassComplexity</key>
      <description><![CDATA[The maximum total cyclomatic complexity value allowed for a class, calculated as the total complexity of its methods or "closure fields". If zero or null, then do not check total class-level complexity.]]></description>
      <defaultValue>0</defaultValue>
    </param>
    <param>
      <key>maxMethodComplexity</key>
      <description><![CDATA[The maximum cyclomatic complexity value allowed for a single method (or "closure field"). If zero or null, then do not check method-level complexity.]]></description>
      <defaultValue>20</defaultValue>
    </param>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.size.MethodCountRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method Count]]></name>
    <internalKey><![CDATA[MethodCount]]></internalKey>
    <description><![CDATA[<p>Checks if the number of methods within a class exceeds the number of lines specified by the <strong>maxMethod</strong> property.</p>
<p>A class with too many methods is probably a good suspect for refactoring, in order to reduce its
complexity and find a way to have more fine grained objects.</p>
]]></description>
    <tag>bug</tag>
    <param>
      <key>maxMethods</key>
      <description><![CDATA[The maximum number of methods allowed in a class definition.]]></description>
      <defaultValue>30</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.MethodSizeRule.fixed</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Method Size]]></name>
    <internalKey><![CDATA[MethodSize]]></internalKey>
    <description><![CDATA[<p>Checks if the size of a method exceeds the number of lines specified by the <strong>maxLines</strong> property.</p>
<p>Known Limitations:</p>
<ul>
<li>Annotations on a method are included in the size (line count) for that method.</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
    <param>
      <key>maxLines</key>
      <description><![CDATA[The maximum number of lines allowed in a method definition.]]></description>
      <defaultValue>100</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.NestedBlockDepthRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Nested Block Depth]]></name>
    <internalKey><![CDATA[NestedBlockDepth]]></internalKey>
    <description><![CDATA[<p>Checks for blocks or closures nested more deeply than a configured maximum number.
Blocks include <code>if</code>, <code>for</code>, <code>while</code>, <code>switch</code>, <code>try</code>, <code>catch</code>,
<code>finally</code> and <code>synchronized</code> blocks/statements, as well as closures.</p>
<p>Methods calls, constructor calls, and property access through Builder objects are ignore. For instance, this code
does not cause a violation:</p>
<pre><code>    myBuilder.root {
        foo {
            bar {
                baz {
                    quix {
                        qux {
                            quaxz {
                            }
                        }
                    }
                }
            }
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreRegex</key>
      <description><![CDATA[Determines what is a builder call. For instance, closures nested on a method named createBuilder, a property named myBuilder, or a constructor call to object MyBuilder() do not produce violations.]]></description>
      <defaultValue>.*(b|B)uilder</defaultValue>
    </param>
    <param>
      <key>maxNestedBlockDepth</key>
      <description><![CDATA[The maximum number of nesting levels. A block or closure nested deeper than that number of levels is considered a violation.]]></description>
      <defaultValue>5</defaultValue>
    </param>
  </rule>

  <!-- since 0.23 -->
  <rule>
    <key>org.codenarc.rule.size.ParameterCountRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Parameter Count]]></name>
    <internalKey><![CDATA[ParameterCount]]></internalKey>
    <description><![CDATA[<p>Checks if the number of parameters in method/constructor exceeds the number of parameters specified by the maxParameters property.</p>
<p>Example of violations:</p>
<pre><code>    void someMethod(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6) { // violation
    }

    @Override
    void someMethod(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7) { // no violation if ignoreOverriddenMethods == true
    }

    class SampleClass {
        SampleClass(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7) { // violation
        }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreOverriddenMethods</key>
      <description><![CDATA[Ignore number of parameters for methods with @Override annotation]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>maxParameters</key>
      <description><![CDATA[The maximum number of parameters in method/constructor]]></description>
      <defaultValue>5</defaultValue>
    </param>
  </rule>

  <!-- unnecessary rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.AddEmptyStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Add Empty String]]></name>
    <internalKey><![CDATA[AddEmptyString]]></internalKey>
    <description><![CDATA[<p>Finds empty string literals which are being added. This is an inefficient way to convert any type to a String.</p>
<p>Examples:</p>
<pre><code>    // do not add empty strings to things
    def a = '' + 123
    def b = method('' + property)

    // these examples are OK and do not trigger violations
    def c = 456.toString()
    def d = property?.toString() ?: &quot;&quot;
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.ConsecutiveLiteralAppendsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Consecutive Literal Appends]]></name>
    <internalKey><![CDATA[ConsecutiveLiteralAppends]]></internalKey>
    <description><![CDATA[<p>Violations occur when method calls to append(Object) are chained together with literals as parameters. The
chained calls can be joined into one invocation.</p>
<p>Example of violations:</p>
<pre><code>    writer.append('foo').append('bar')      // strings can be joined
    writer.append('foo').append(5)          // string and number can be joined
    writer.append('Hello').append(&quot;$World&quot;) // GString can be joined
</code></pre>
<p>Example of passing code:</p>
<pre><code>    // usage not chained invocation
    writer.append('Hello')
    writer.append('World')

    writer.append(null).append(5)           // nulls cannot be joined

    writer.append().append('Hello')             // no arg append is unknown
    writer.append('a', 'b').append('Hello')     // two arg append is unknown
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.ConsecutiveStringConcatenationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Consecutive String Concatenation]]></name>
    <internalKey><![CDATA[ConsecutiveStringConcatenation]]></internalKey>
    <description><![CDATA[<p>Catches concatenation of two string literals on the same line. These can safely by joined. In Java, the Java compiler
will join two String literals together and place them in the Constant Pool. However, Groovy will not because the plus()
method may override the + operator.</p>
<p>Examples:</p>
<pre><code>    // Violations
    def a = 'Hello' + 'World'   // should be 'HelloWorld'
    def b = &quot;$Hello&quot; + 'World'  // should be &quot;${Hello}World&quot;
    def c = 'Hello' + &quot;$World&quot;  // should be &quot;Hello${World}&quot;
    def d = 'Hello' + 5         // should be 'Hello5'
    def e = 'Hello' + '''
                        world   // should be joined
                      '''
    def f = '''Hello
                  ''' + 'world'   // should be joined


    // Not Violations
    def g = 'Hello' +           // OK because of line break
                'World'
    def h = 'Hello' + null      // OK because not a string
    def i = 'Hello' + method()  // OK because not a string
    def j = 'Hello' - &quot;$World&quot;  // OK because not +
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBigDecimalInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Big Decimal Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryBigDecimalInstantiation]]></internalKey>
    <description><![CDATA[<p>It is unnecessary to instantiate <code>BigDecimal</code> objects. Instead just use the decimal literal
or the 'G' identifier to force the type, such as <code>123.45</code> or <code>123.45G</code>.</p>
<p>This rule does not produce violations when the parameter evaluates to an integer/long, e.g.
<code>new BigDecimal(42)</code>, <code>new BigDecimal(42L)</code> or <code>new BigDecimal(&quot;42&quot;)</code>, because using the
&quot;G&quot; suffix on an integer value produces a <code>BigInteger</code>, rather than a <code>BigDecimal</code>, e.g. <code>45G</code>.
So that means there is no way to produce a <code>BigDecimal</code> with exactly that value using a literal.</p>
<p>This rule also does not produce violations when the parameter is a double, e.g. <code>new BigDecimal(12.3)</code>.
That scenario is covered by the <a href="./codenarc-rules-basic.html#BigDecimalInstantiation">BigDecimalInstantiation</a>
rule, because that produces an unpredictable (double) value (and so it is <em>unsafe</em>, rather than <em>unnecessary</em>).</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBigIntegerInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Big Integer Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryBigIntegerInstantiation]]></internalKey>
    <description><![CDATA[<p>It is unnecessary to instantiate <code>BigInteger</code> objects. Instead just use the literal with
the 'G' identifier to force the type, such as <code>8G</code> or <code>42G</code>.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBooleanExpressionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Boolean Expression]]></name>
    <internalKey><![CDATA[UnnecessaryBooleanExpression]]></internalKey>
    <description><![CDATA[<p>Checks for unnecessary boolean expressions, including ANDing (&amp;&amp;) or ORing (||) with
<code>true</code>, <code>false</code>, <code>null</code>, or a Map/List/String/Number literal.</p>
<p>This rule also checks for negation (!) of <code>true</code>, <code>false</code>,
<code>null</code>, or a Map/List/String/Number literal.</p>
<p>Examples of violations include:</p>
<pre><code>    result = value &amp;&amp; true              // AND or OR with boolean constants
    if (false || value) { .. }
    return value &amp;&amp; Boolean.FALSE

    result = null &amp;&amp; value              // AND or OR with null

    result = value &amp;&amp; &quot;abc&quot;             // AND or OR with String literal

    result = value &amp;&amp; 123               // AND or OR with Number literal
    result = 678.123 || true

    result = value &amp;&amp; [x, y]            // AND or OR with List literal

    result = [a:123] &amp;&amp; value           // AND or OR with Map literal

    result = !true                      // Negation of boolean constants
    result = !false
    result = !Boolean.TRUE

    result = !null                      // Negation of null

    result = !&quot;abc&quot;                     // Negation of String literal

    result = ![a:123]                   // Negation of Map literal

    result = ![a,b]                     // Negation of List literal
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBooleanInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Boolean Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryBooleanInstantiation]]></internalKey>
    <description><![CDATA[<p>Checks for direct call to a <code>Boolean</code> constructor. Use <code>Boolean.valueOf()</code> or the <code>Boolean.TRUE</code>
and <code>Boolean.FALSE</code> constants instead of calling the <code>Boolean()</code> constructor directly.</p>
<p>Also checks for <code>Boolean.valueOf(true)</code> or <code>Boolean.valueOf(false)</code>. Use the <code>Boolean.TRUE</code>
or <code>Boolean.FALSE</code> constants instead.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def b1 = new Boolean(true)             // violation
    def b2 = new java.lang.Boolean(false)  // violation
    def b3 = Boolean.valueOf(true)         // violation
    def b4 = Boolean.valueOf(false)        // violation
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCallForLastElementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Call For Last Element]]></name>
    <internalKey><![CDATA[UnnecessaryCallForLastElement]]></internalKey>
    <description><![CDATA[<p>This rule checks for excessively verbose methods of accessing the last element of an array or list. For
instance, it is possible to access the last element of an array by performing <code>array[array.length - 1]</code>,
in Groovy it is simpler to either call <code>array.last()</code> or <code>array[-1]</code>. The same is true for lists.
This violation is triggered whenever a <code>get</code>, <code>getAt</code>, or array-style access is used with an object
size check.</p>
<p>Code like this all cause violations.</p>
<pre><code>    def x = [0, 1, 2]
    def a = x.get(x.size() -1)
    def b = x.get(x.length -1)
    def c = x.getAt(x.size() -1)
    def d = x.getAt(x.length -1)
    def f = x[(x.size() -1]
    def d = x[(x.length -1]
</code></pre>
<p>All of this code is fine though:</p>
<pre><code>    def x = [0, 1, 2]
    def a = x.last()
    def b = x[-1]
    def c = x.getAt(-1)
    def d = x.get(z.size() -1)     // different objects
    def e = x.get(z.length -1)     // different objects
    def f = x.getAt(z.size() -1)   // different objects
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCallToSubstringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Call To Substring]]></name>
    <internalKey><![CDATA[UnnecessaryCallToSubstring]]></internalKey>
    <description><![CDATA[<p>Calling String.substring(0) always returns the original string. This code is meaningless.</p>
<p>Examples:</p>
<pre><code>    string.substring(0)         // violation
    method().substring(0)       // violation

    prop.substring(1)           // OK, not constant 0
    prop.substring(0, 1)        // OK, end is specified
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCastRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unnecessary Cast]]></name>
    <internalKey><![CDATA[UnnecessaryCast]]></internalKey>
    <description><![CDATA[<p>Checks for unnecessary cast operations.</p>
<p>Example of violations:</p>
<pre><code>    int count = (int)123                    // violation
    def longValue = (long)123456L           // violation
    def bigDecimal = (BigDecimal)1234.56    // violation
    String name = (String) &quot;Joe&quot;            // violation
    def list = (List)[1, 2, 3]              // violation
    def map = (Map)[a:1]                    // violation
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCatchBlockRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Catch Block]]></name>
    <internalKey><![CDATA[UnnecessaryCatchBlock]]></internalKey>
    <description><![CDATA[<p>Violations are triggered when a <em>catch</em> block does nothing but throw the original exception. In this scenario
there is usually no need for a <em>catch</em> block, just let the exception be thrown from the original code. This
condition frequently occurs when catching an exception for debugging purposes but then forgetting to take the
<code>catch</code> statement out.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCollectCallRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Collect Call]]></name>
    <internalKey><![CDATA[UnnecessaryCollectCall]]></internalKey>
    <description><![CDATA[<p>Some method calls to <code>Object.collect(Closure)</code> can be replaced with the spread operator. For instance,
<code>list.collect { it.multiply(2) }</code> can be replaced by <code>list*.multiply(2)</code>.</p>
<p>Examples of violations include:</p>
<pre><code>    assert [1, 2, 3].collect { it.multiply(2) }
    assert [1, 2, 3].collect { x -* x.multiply(2) }
    [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].collect { it.bytes }
</code></pre>
<p>The following code does not produce violations:</p>
<pre><code>    [1, 2, 3].collect { it * it }   // OK, closure parameter is referenced twice

    [1, 2, 3].mapMethod { it.multiply(5) } // OK, method call is not collect

    [1, 2, 3].collect(5) // OK, collect parameter is not a closure

    // OK, the closure is not a simple one line statement
    [1, 2, 3].collect { println it; it.multiply(5) }

    // OK, closure has too many arguments
    [1, 2, 3].collect { a, b -* a.multiply(b) }

    // OK, closure statement references parameter multiple times
    [1, 2, 3].collect { it.multiply(it) }

    // OK, it is referenced several times in the closure
    [1, 2, 3].collect { it.multiply(2).multiply(it) }
    [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].collect { it.bytes.foo(it) }

    // OK, chained methods are too complex to analyze at this point
    [1, 2, 3].collect { it.multiply(2).multiply(4) }

    // in general the above examples can be rewritten like this:
    [1, 2, 3]*.multiply(2)
    [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]*.bytes
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCollectionCallRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Collection Call]]></name>
    <internalKey><![CDATA[UnnecessaryCollectionCall]]></internalKey>
    <description><![CDATA[<p>Checks for useless calls to collections. For any collection <code>c</code>, calling <code>c.containsAll(c)</code>
should always be <code>true</code>, and <code>c.retainAll(c)</code> should have no effect.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryConstructorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Constructor]]></name>
    <internalKey><![CDATA[UnnecessaryConstructor]]></internalKey>
    <description><![CDATA[<p>This rule detects when a constructor is not necessary; i.e., when there's only one constructor, it's
<code>public</code>, has an empty body, and takes no arguments, or else contains only a single call to <code>super()</code>.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        public MyClass() {          // violation; constructor is not necessary
        }
    }

    class MyClass2 extends OtherClass {
        MyClass2() {                // violation; constructor is not necessary
            super()
        }
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
    <param>
      <key>ignoreAnnotations</key>
      <description><![CDATA[If "true", then do not report violations if a constructor has one or more annotations.]]></description>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDefInFieldDeclarationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Def In Field Declaration]]></name>
    <internalKey><![CDATA[UnnecessaryDefInFieldDeclaration]]></internalKey>
    <description><![CDATA[<p>If a field has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance, 'static def constraints = {}' is redundant and can be simplified to 'static constraints = {}.</p>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        // def is redundant
        static def constraints = {  }

        // def and private is redundant
        def private field1 = { }

        // def and protected is redundant
        def protected field2 = { }

        // def and public is redundant
        def public field3 = { }

        // def and static is redundant
        def static field4 = { }

        // def and type is redundant
        def Object field5 = { }
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDefInMethodDeclarationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Def In Method Declaration]]></name>
    <internalKey><![CDATA[UnnecessaryDefInMethodDeclaration]]></internalKey>
    <description><![CDATA[<p>If a method has a visibility modifier or a type declaration, then the def keyword is unneeded.
For instance 'def private method() {}' is redundant and can be simplified to 'private method() {}'.</p>
<p>Examples of violations:</p>
<pre><code>    // def and private is redundant
    def private method1() { return 4 }

    // def and protected is redundant
    def protected method2() { return 4 }

    // def and public is redundant
    def public method3() { return 4 }

    // def and static is redundant
    def static method4() { return 4 }

    // def and type is redundant
    def Object method5() { return 4 }

    class MyClass {
        def MyClass() {}    // def is redundant
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDefInVariableDeclarationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Def In Variable Declaration]]></name>
    <internalKey><![CDATA[UnnecessaryDefInVariableDeclaration]]></internalKey>
    <description><![CDATA[<p>If a variable has a visibility modifier or a type declaration, then the def keyword is unneeded.
For instance 'def private n = 2' is redundant and can be simplified to 'private n = 2'.</p>
<p>Examples of violations:</p>
<pre><code>    // def and private is redundant
    def private string1 = 'example'

    // def and protected is redundant
    def protected string2 = 'example'

    // def and public is redundant
    def public string3 = 'example'

    // def and static is redundant
    def static string4 = 'example'

    // def and final is redundant
    def final string5 = 'example'

    // def and a type is redundant
    def String string6 = 'example'
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDotClassRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Dot Class]]></name>
    <internalKey><![CDATA[UnnecessaryDotClass]]></internalKey>
    <description><![CDATA[<p>To make a reference to a class, it is unnecessary to specify the '.class' identifier. For instance String.class can be shortened to String.</p>
<p>Example of violations:</p>
<pre><code>    // The '.class' identifier is unnecessary, violation occurs
    def x = String.class

    // Ok, unnecessary '.class' identifier has been excluded
    def x = String
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDoubleInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Double Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryDoubleInstantiation]]></internalKey>
    <description><![CDATA[<p>It is unnecessary to instantiate <code>Double</code> objects. Instead just use the double literal
with 'D' identifier to force the type, such as <code>123.45d</code> or <code>0.42d</code>.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryElseStatementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Else Statement]]></name>
    <internalKey><![CDATA[UnnecessaryElseStatement]]></internalKey>
    <description><![CDATA[<p>When an <code>if</code> statement block ends with a <code>return</code> statement, then the <code>else</code> is unnecessary.
The logic in the <code>else</code> branch can be run without being in a new scope.</p>
<p>Example of violations:</p>
<pre><code>    if(value){
        println 'Executing if logic...'
        return true
    } else {
        println 'Executing else logic...'
    }

    // can be replaced by:

    if(value){
        println 'Executing if logic...'
        return true
    }
    println 'Executing else logic...'
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryFinalOnPrivateMethodRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Final On Private Method]]></name>
    <internalKey><![CDATA[UnnecessaryFinalOnPrivateMethod]]></internalKey>
    <description><![CDATA[<p>A private method is marked final. Private methods cannot be overridden, so marking it final is unnecessary.</p>
<p>Example of violations:</p>
<pre><code>    private final method() {}
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryFloatInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Float Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryFloatInstantiation]]></internalKey>
    <description><![CDATA[<p>It is unnecessary to instantiate <code>Float</code> objects. Instead just use the float literal
with the 'F' identifier to force the type, such as <code>123.45F</code> or <code>0.42f</code>.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryGetterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Getter]]></name>
    <internalKey><![CDATA[UnnecessaryGetter]]></internalKey>
    <description><![CDATA[<p>Checks for explicit calls to getter/accessor methods which can, for the most part, be replaced by property access.
A getter is defined as a no-argument method call that matches <code>get[A-Z]</code> but not <code>getClass()</code> or
<code>get[A-Z][A-Z]</code> such as <code>getURL()</code>.</p>
<p>Calls to getter methods within Spock method calls <code>Mock()</code>, <code>Stub()</code> and <code>Spy()</code> are ignored.</p>
<p>These bits of code produce violations:</p>
<pre><code>    x.getProperty()
    x.getFirst()
    x.getFirstName()
    x.getA()

    x.isFirst()         // Violation if checkIsMethods is true
    x.isA()             // Violation if checkIsMethods is true
</code></pre>
<p>These bits of code do not:</p>
<pre><code>    x.property
    x.first
    x.firstName
    x.a
    x.getURL()
    x.getClass()
    x.getProperty('key')
</code></pre>
]]></description>
    <tag>clumsy</tag>
    <param>
      <key>checkIsMethods</key>
      <description><![CDATA[If "true", then also check isXxx() getters methods.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreMethodNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) method names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryGStringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary G String]]></name>
    <internalKey><![CDATA[UnnecessaryGString]]></internalKey>
    <description><![CDATA[<p>String objects should be created with single quotes, and GString objects created with double quotes.
Creating normal String objects with double quotes is confusing to readers.</p>
<p>Example of violations:</p>
<pre><code>    def a = &quot;I am a string&quot;     // violation

    // violation
    def b = &quot;&quot;&quot;
        I am a string
    &quot;&quot;&quot;

    def c = &quot;I am a ' string&quot;       // OK

    def d = &quot;&quot;&quot;I am a ' string&quot;&quot;&quot;   // OK

    def e = &quot;&quot;&quot;I am a ' string&quot;&quot;&quot;   // OK

    def f = &quot;I am a \$ string&quot;  // OK

    // OK
    def g = &quot;&quot;&quot;
        I am a \$ string
    &quot;&quot;&quot;

    // OK
    def h = &quot;&quot;&quot;
        I am a $string
    &quot;&quot;&quot;

    def i = 'i am a string'
    def j = '''i am a
        string
    '''
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryIfStatementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary If Statement]]></name>
    <internalKey><![CDATA[UnnecessaryIfStatement]]></internalKey>
    <description><![CDATA[<p>Checks for unnecessary <strong>if</strong> statements. The entire <strong>if</strong> statement, or at least the <em>if</em> or <em>else</em>
block, are considered unnecessary for the four scenarios described below.</p>
<p>(1) When the <em>if</em> and <em>else</em> blocks contain only an explicit return of <code>true</code> and <code>false</code>
constants. These cases can be replaced by a simple <em>return</em> statement. Examples of violations include:</p>
<pre><code>    if (someExpression)         // can be replaced by: return someExpression
        return true
    else
        return false

    if (someExpression) {       // can be replaced by: return !someExpression
        return false
    } else {
        return true
    }

    if (someExpression) {       // can be replaced by: return someExpression
        return Boolean.TRUE
    } else {
        return Boolean.FALSE
    }
</code></pre>
<p>(2) When the <code>if</code> statement is the last statement in a block and the <em>if</em> and <em>else</em> blocks
are only <code>true</code> and <code>false</code> expressions. This is an <em>implicit</em> return of <code>true</code>/<code>false</code>.
For example, the <code>if</code> statement in the following code can be replaced by <code>someExpression</code>
or <code>someExpression as boolean</code>:</p>
<pre><code>    def myMethod() {
        doSomething()
        if (someExpression)
            true
        else false
    }
</code></pre>
<p>(3) When the second-to-last statement in a block is an <code>if</code> statement with no <code>else</code>, where the block
contains a single <code>return</code> statement, and the last statement in the block is a <code>return</code> statement, and
one <code>return</code> statement returns a <code>true</code> expression and the other returns a <code>false</code> expression.
This check is disabled by setting <code>checkLastStatementImplicitElse</code> to <code>false</code>.
For example, the <code>if</code> statement in the following code can be replaced by <code>return expression1</code>:</p>
<pre><code>    def myMethod() {
        doSomething()
        if (expression1) {
            return true
        }
        return false
    }
</code></pre>
<p>(4) When either the <em>if</em> block or <em>else</em> block of an <code>if</code> statement that is not the last statement
in a block contain only a single constant or literal expression. For example, the <code>if</code> statement
in the following code has no effect and can be removed:</p>
<pre><code>    def myMethod() {
        if (someExpression) { 123 }
        doSomething()
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryInstanceOfCheckRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Instance Of Check]]></name>
    <internalKey><![CDATA[UnnecessaryInstanceOfCheck]]></internalKey>
    <description><![CDATA[<p>This rule finds instanceof checks that cannot possibly evaluate to true. For instance, checking that
<code>(!variable instanceof String)</code> will never be true because the result of a not expression is always a boolean.</p>
<p>Example of violations:</p>
<pre><code>    if (!variable instanceof String) { ... }    // always false
    def x = !variable instanceof String         // always false

    if (!variable instanceof Boolean) { ... }    // always true
    def x = !variable instanceof Boolean         // always true

    // this code is OK
    if (!(variable instanceof String)) { ... }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryInstantiationToGetClassRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Instantiation To Get Class]]></name>
    <internalKey><![CDATA[UnnecessaryInstantiationToGetClass]]></internalKey>
    <description><![CDATA[<p><em>Since in CodeNarc 0.12</em></p>
<p>Avoid instantiating an object just to call getClass() on it; use the .class public member instead.</p>
<pre><code>    public class Foo {
     // Replace this
     Class c = new String().getClass();

     // with this:
     Class c = String.class;
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryIntegerInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Integer Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryIntegerInstantiation]]></internalKey>
    <description><![CDATA[<p>It is unnecessary to instantiate <code>Integer</code> objects. Instead just use the literal with
the 'I' identifier to force the type, such as <code>8I</code> or <code>42i</code>.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryLongInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Long Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryLongInstantiation]]></internalKey>
    <description><![CDATA[<p>It is unnecessary to instantiate <code>Long</code> objects. Instead just use the literal with
the 'L' identifier to force the type, such as <code>8L</code> or <code>42L</code>.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryModOneRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Mod One]]></name>
    <internalKey><![CDATA[UnnecessaryModOne]]></internalKey>
    <description><![CDATA[<p>Any expression mod 1 (exp % 1) is guaranteed to always return zero. This code is probably an error, and should be either (exp &amp; 1) or (exp % 2).</p>
<p>Examples:</p>
<pre><code>    if (exp % 1) {}         // violation
    if (method() % 1) {}    // violation

    if (exp &amp; 1) {}     // ok
    if (exp % 2) {}     // ok
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryObjectReferencesRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Object References]]></name>
    <internalKey><![CDATA[UnnecessaryObjectReferences]]></internalKey>
    <description><![CDATA[<p>Violations are triggered when an excessive set of consecutive statements all reference the same variable.
This can be made more readable by using a <code>with</code> or <code>identity</code> block. By default, 5 references
are allowed. You can override this property using the **maxReferencesAllowed` property on the rule.</p>
<p>These two bits of code produce violations:</p>
<pre><code>    def p1 = new Person()
    p1.firstName = 'Hamlet'
    p1.lastName = &quot;D'Arcy&quot;
    p1.employer = 'Canoo'
    p1.street = 'Kirschgaraten 5'
    p1.city = 'Basel'
    p1.zipCode = '4051'

    def p2 = new Person()
    p2.setFirstName('Hamlet')
    p2.setLastName(&quot;D'Arcy&quot;)
    p2.setEmployer('Canoo')
    p2.setStreet('Kirschgaraten 5')
    p2.setCity('Basel')
    p2.setZipCode('4051')
</code></pre>
<p>However, these two bits of code do not because they use either a <code>with</code> or <code>identity</code> block.</p>
<pre><code>    def p1 = new Person().with {
        firstName = 'Hamlet'
        lastName = &quot;D'Arcy&quot;
        employer = 'Canoo'
        street = 'Kirschgaraten 5'
        city = 'Basel'
        zipCode = '4051'
    }

    def p2 = new Person().identity {
        firstName = 'Hamlet'
        lastName = &quot;D'Arcy&quot;
        employer = 'Canoo'
        street = 'Kirschgaraten 5'
        city = 'Basel'
        zipCode = '4051'
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryNullCheckRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Null Check]]></name>
    <internalKey><![CDATA[UnnecessaryNullCheck]]></internalKey>
    <description><![CDATA[<p>Groovy contains the safe dereference operator. It can be used in boolean conditional statements to safely
replace explicit <code>x == null</code> tests. Also, testing the 'this' or 'super' reference for null equality is
pointless and can be removed.</p>
<p>Examples of violations:</p>
<pre><code>    if (obj != null &amp;&amp; obj.method()) { }

    if (obj != null &amp;&amp; obj.prop) { }

    // this is pointless and won't avoid NullPointerException
    if (obj.method() &amp;&amp; obj != null ) { }

    if (this == null) { }
    if (null == this) { }
    if (this != null) { }
    if (null != this) { }

    if (super == null) { }
    if (null == super) { }
    if (super != null) { }
    if (null != super) { }
</code></pre>
<p>Examples of acceptable code:</p>
<pre><code>    // null check it OK
    if (obj != null) { }

    // null safe dereference in if is OK
    if (obj?.method()) { }

    // null safe dereference in ternary is OK
    (obj?.prop &amp;&amp; obj?.prop2) ? x : y

    // obj is reused in a parameter list, so OK
    if (obj != null &amp;&amp; obj.method() &amp;&amp; isValid(obj)) { }

    // rule is not so complex yet...
    (obj != null &amp;&amp; obj.prop &amp;&amp; obj.method()) ? x : y
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryNullCheckBeforeInstanceOfRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Null Check Before Instance Of]]></name>
    <internalKey><![CDATA[UnnecessaryNullCheckBeforeInstanceOf]]></internalKey>
    <description><![CDATA[<p>There is no need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.</p>
<p>Example:</p>
<pre><code>    if (x != null &amp;&amp; x instanceof MyClass) {
        // should drop the &quot;x != null&quot; check
    }

    if (x instanceof MyClass &amp;&amp; x != null) {
        // should drop the &quot;x != null&quot; check
    }

    // should drop the &quot;x != null&quot; check
    (x != null &amp;&amp; x instanceof MyClass) ? foo : bar

    if (x != null &amp;&amp; x instanceof MyClass &amp;&amp; x.isValid()) {
        // this is OK and causes no violation because the x.isValid() requires a non null reference
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryOverridingMethodRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Overriding Method]]></name>
    <internalKey><![CDATA[UnnecessaryOverridingMethod]]></internalKey>
    <description><![CDATA[<p>Checks for an overriding method that merely calls the same method defined in a superclass. Remove it.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryPackageReferenceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Package Reference]]></name>
    <internalKey><![CDATA[UnnecessaryPackageReference]]></internalKey>
    <description><![CDATA[<p>Checks for explicit package reference for classes that Groovy imports by default, such as <code>java.lang.String</code>,
<code>java.util.Map</code> and <code>groovy.lang.Closure</code>, as well as classes that were explicitly imported.</p>
<p>You do not need to specify the package for any classes from <em>java.lang</em>, <em>java.util</em>, <em>java.io</em>, <em>java.net</em>,
<em>groovy.lang</em> and <em>groovy.util</em>, as well as the classes <em>java.math.BigDecimal</em> and <em>java.math.BigInteger</em>.</p>
<p>Examples of violations include:</p>
<pre><code>    // Field types
    class MyClass {
        java.math.BigDecimal amount = 42.10                     // violation
    }

    // Within expressions
    if (value.class == java.math.BigInteger) { }                // violation
    println &quot;isClosure=${v instanceof groovy.lang.Closure}&quot;     // violation
    def p = java.lang.Runtime.availableProcessors()             // violation

    // Constructor calls
    def url = new java.net.URL('http://abc@example.com')        // violation

    // Variable types
    void doSomething() {
        java.math.BigInteger maxValue = 0                       // violation
        java.net.URI uri                                        // violation
    }

    // Method return types
    java.io.Reader getReader() { }                              // violation
    groovy.util.AntBuilder getAntBuilder() { }                  // violation

    // Method parameter types
    void writeCount(java.io.Writer writer, int count) { }       // violation
    void init(String name, groovy.lang.Binding binding) { }     // violation

    // Closure parameter types
    def writeCount = { java.io.Writer writer, int count -* }    // violation

    // Extends and implements
    class MyHashMap extends java.util.HashMap { }               // violation
    class MyList implements java.util.List { }                  // violation

    // Explicitly imported classes
    import javax.servlet.http.Cookie
    import javax.sql.DataSource

    class MyClass {
        void doStuff(javax.servlet.http.Cookie cookie) {        // violation
            def dataSource = [:] as javax.sql.DataSource        // violation
        }
    }
</code></pre>
<p>Known limitations:</p>
<ul>
<li>
<p>Does not catch class declarations that explicitly extend <code>java.lang.Object</code>. For instance,
<code>class MyClass extends java.lang.Object { }</code>. Just don't do that, okay?</p>
</li>
<li>
<p>Does not catch class declarations that explicitly extend <code>groovy.lang.Script</code>. For instance,
<code>class MyScript extends groovy.lang.Script{ }</code>. Don't do that, either!</p>
</li>
<li>
<p>Does not catch unnecessary package references if they are the types of anonymous inner class
definitions, for older versions of Groovy (* 1.7.10?). For instance,
<code>def runnable = new java.lang.Runnable() { ... }</code>.</p>
</li>
</ul>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryParenthesesForMethodCallWithClosureRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Parentheses For Method Call With Closure]]></name>
    <internalKey><![CDATA[UnnecessaryParenthesesForMethodCallWithClosure]]></internalKey>
    <description><![CDATA[<p>If a method is called and the only parameter to that method is an inline closure then the parentheses of the method call can be omitted.</p>
<p>Example of violations:</p>
<pre><code>    [1,2,3].each() { println it }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryPublicModifierRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Public Modifier]]></name>
    <internalKey><![CDATA[UnnecessaryPublicModifier]]></internalKey>
    <description><![CDATA[<p>The 'public' modifier is not required on methods, constructors or classes.</p>
<p>Because of Groovy parsing limitations, this rule ignores methods (and constructors) that include Generic types in the method declaration.</p>
<p>Example of violations:</p>
<pre><code>    // violation on class
    public class MyClass {
        // violation on constructor
        public MyClass() {}

        // violation on method
        public void myMethod() {}
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryReturnKeywordRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Return Keyword]]></name>
    <internalKey><![CDATA[UnnecessaryReturnKeyword]]></internalKey>
    <description><![CDATA[<p>In Groovy, the <code>return</code> keyword is often optional. If a statement is the last line in a method or
closure then you do not need to have the <code>return</code> keyword.</p>
<p>Note: This rule is pretty much the opposite of the <a href="./codenarc-rules-convention.html#implicitreturnstatement-rule">ImplicitReturnStatement</a> rule.
You don't want to enable both rules.
Some describe this as the <em>CodeNarc Heisenberg Principle</em>: You can either have the
<strong>ImplicitReturnStatement</strong> rule enabled or <strong>UnnecessaryReturnKeyword</strong>, but not both.</p>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySafeNavigationOperatorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Safe Navigation Operator]]></name>
    <internalKey><![CDATA[UnnecessarySafeNavigationOperator]]></internalKey>
    <description><![CDATA[<p>Check for the <em>safe navigation</em> operator (<code>?.</code>) applied to constants and literals, or <code>this</code>
or <code>super</code>, or constructor calls, all of which can never be null.</p>
<p>Example of violations:</p>
<pre><code>    def myMethod() {
        &quot;abc&quot;?.bytes            // violation
        [1,2]?.getSize()        // violation
        [abc:123]?.name         // violation
        [:]?.toString()         // violation
        123?.class              // violation
        123.45?.getClass()      // violation
        Boolean.FALSE?.class    // violation
        Boolean.TRUE?.class     // violation
        this?.class             // violation
        super?.getClass()       // violation
        new Long(100)?.class    // violation
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySelfAssignmentRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Self Assignment]]></name>
    <internalKey><![CDATA[UnnecessarySelfAssignment]]></internalKey>
    <description><![CDATA[<p>Method contains a pointless self-assignment to a variable or property. Either the code is pointless or the equals()/get()
method has been overridden to have a side effect, which is a terrible way to code getters and violates the contract of
equals().</p>
<p>Examples:</p>
<pre><code>    x = x               // violation
    def method(y) {
        y = y           // violation
    }
    a.b.c = a.b.c       // violation

    x = y               // acceptable
    a.b = a.zz          // acceptable
    a.b = a().b         // acceptable
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySemicolonRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Semicolon]]></name>
    <internalKey><![CDATA[UnnecessarySemicolon]]></internalKey>
    <description><![CDATA[<p>Semicolons as line terminators are not required in Groovy: remove them. Do not use a semicolon as a replacement for
empty braces on for and while loops; this is a confusing practice.</p>
<p>The rule contains a String property called 'excludePattern'. Any source code line matching this pattern will not
trigger a violation. The default value is '\s?\<em>.</em>|/\<em>.</em>|.<em>//.</em>|.<em>\</em>/.*' This is to filter out comments.
Any source line that even looks like it is a comment is ignored.</p>
<ul>
<li><code>\s?\*.*</code>  ==  whitespace plus star character plus anything</li>
<li><code>/\*.*</code>    == any line that contains the /* sequence</li>
<li><code>.*//.*</code>   == any line that contains the // sequence</li>
<li><code>.*\*/.*</code>  == any line that contains the */ sequence</li>
</ul>
<p>Example of violations:</p>
<pre><code>    package my.company.server;  // violation

    import java.lang.String;    // violation

    println(value) ;             // violation

    for (def x : list);         // violation

    // this code is OK
    println(value); println (otherValue)
</code></pre>
<p>Known limitations:</p>
<ul>
<li>Will not flag a semicolon on a field declaration with no initial value specified when running on Groovy 3.x.</li>
</ul>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 1.0 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySetterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Setter]]></name>
    <internalKey><![CDATA[UnnecessarySetter]]></internalKey>
    <description><![CDATA[<p>Checks for explicit calls to setter methods which can, for the most part, be replaced by assignment to property.
A setter is defined as a method call that matches set[A-Z] but not set[A-Z][A-Z] such as setURL().
Setters take one method argument. Setter calls within an expression are ignored.</p>
<p>These bits of code produce violations:</p>
<pre><code>  x.setProperty(1)
  x.setProperty(this.getA())
  x.setProperty([])
</code></pre>
<p>These bits of code do not:</p>
<pre><code>  x.set(1)                              // Nothing after &quot;set&quot;
  x.setup(2)                            // The letter after &quot;set&quot; must be capitalized
  x.setURL('')                          // But setters with multiple capital letters after &quot;set&quot; are ignored
  x.setSomething('arg1', 'arg2')        // Setter must have exactly one argument
  if (!file.setExecutable(true)) { }    // Set method called within expression
  def count = x.setCount(92)            // Set method called within expression
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySubstringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Substring]]></name>
    <internalKey><![CDATA[UnnecessarySubstring]]></internalKey>
    <description><![CDATA[<p>NOTE: This rule is <em>deprecated</em> and will be removed in a future CodeNarc version. Its recommendation to use subscripts on
strings is not always safe/valid. See <a href="https://github.com/CodeNarc/CodeNarc/issues/562">#562</a>.</p>
<p>This rule finds usages of <code>String.substring(int)</code> and <code>String.substring(int, int)</code> that can be replaced by use of the
subscript operator. For instance, <code>var.substring(5)</code> can be replaced with <code>var[5..-1]</code>.</p>
<p>Note that the String.substring(beginIndex,endIndex) method specifies a range of beginIndex..endIndex-1, while
Groovy's String subscript specifies an inclusive range. So, <code>&quot;123456&quot;.substring(1, 5)</code> is equivalent to <code>&quot;123456&quot;[1..4]</code>.</p>
<p>Example of violations:</p>
<pre><code>    myVar.substring(5)          // can use myVar[5..-1] instead
    myVar.substring(1, 5)       // can use myVar[1..4] instead
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryStringInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary String Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryStringInstantiation]]></internalKey>
    <description><![CDATA[<p>Checks for direct call to the <code>String</code> constructor that accepts a <code>String</code> literal.
In almost all cases, this is unnecessary. Use a <code>String</code> literal (e.g., &quot;...&quot;) instead of calling the
corresponding <code>String</code> constructor (<code>new String(&quot;..&quot;)</code>) directly.</p>
<p>Here is an example of code that produces a violation:</p>
<pre><code>    def s = new String('abc')
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryTernaryExpressionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Ternary Expression]]></name>
    <internalKey><![CDATA[UnnecessaryTernaryExpression]]></internalKey>
    <description><![CDATA[<p>Checks for ternary expressions where the conditional expression always evaluates to a boolean
and the <em>true</em> and <em>false</em> expressions are merely returning <code>true</code> and <code>false</code> constants.
These cases can be replaced by a simple boolean expression. Examples of violations include:</p>
<pre><code>    x==99 ? true : false                    // can be replaced by: x==99
    x &amp;&amp; y ? true : false                   // can be replaced by: x &amp;&amp; y
    x||y ? false : true                     // can be replaced by: !(x||y)
    x *= 1 ? true: false                    // can be replaced by: x *= 1
    x * 99 ? Boolean.TRUE : Boolean.FALSE   // can be replaced by: x * 99
    !x ? true : false                       // can be replaced by: !x
</code></pre>
<p>The rule also checks for ternary expressions where the <em>true</em> and <em>false</em> expressions are
the same constant or variable. Examples include:</p>
<pre><code>    x ? '123' : '123'              // can be replaced by: '123'
    x ? null : null                // can be replaced by: null
    x ? 23 : 23                    // can be replaced by: 23
    x ? MAX_VALUE : MAX_VALUE      // can be replaced by: MAX_VALUE
    ready ? minValue : minValue    // can be replaced by: minValue
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryTransientModifierRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Transient Modifier]]></name>
    <internalKey><![CDATA[UnnecessaryTransientModifier]]></internalKey>
    <description><![CDATA[<p>The field is marked as transient, but the class isn't Serializable, so marking it as transient has no effect.
This may be leftover marking from a previous version of the code in which the class was
transient, or it may indicate a misunderstanding of how serialization works.</p>
<p>Some Java frameworks change the semantics of the transient keyword. For instance, when using Terracotta
the transient keyword may have slightly different semantics. You may need to turn this rule off depending
on which Java frameworks are in use.</p>
<p>Examples:</p>
<pre><code>    class MyClass {
        // class not serializable, violation occurs
        transient String property
    }

    class MySerializableClass implements Serializable {
        // OK, class is serializable
        transient String property
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryToStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unnecessary To String]]></name>
    <internalKey><![CDATA[UnnecessaryToString]]></internalKey>
    <description><![CDATA[<p>Checks for unnecessary calls to <code>toString()</code>. This includes:</p>
<ul>
<li>
<p>Calls to <code>toString()</code> on a String literal or expression</p>
</li>
<li>
<p>Calls to <code>toString()</code> for the value assigned to a <code>String</code> field or variable (if <em>checkAssignments</em> is <code>true</code>).</p>
</li>
</ul>
<p>Example of violations:</p>
<pre><code>    def name = &quot;Joe&quot;.toString()                             // violation - string literal
    def groupId = ((String)row.get('GroupID')).toString()   // violation - string expression

    class MyClass {
        String name = nameNode.toString()           // violation - field
        String code = account.getCode().toString()  // violation - field

        def name = &quot;Joe&quot; + new Date().toString()    // violation - adding object to String

        void run() {
            String name = nameNode.toString()       // violation - variable
            String id = account.id.toString()       // violation - variable

            def string = &quot;processing ${123L.toString()} or ${new Date().toString()}&quot;    // 2 violations - GString value
        }
    }
</code></pre>
]]></description>
    <tag>clumsy</tag>
    <param>
      <key>checkAssignments</key>
      <description><![CDATA[If "true", then check for calls to "toString()" for the value assigned to a "String" field or variable.]]></description>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- unused rules -->

  <rule>
    <key>org.codenarc.rule.unused.UnusedArrayRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Array]]></name>
    <internalKey><![CDATA[UnusedArray]]></internalKey>
    <description><![CDATA[<p>Checks for array allocations that are not assigned or used, unless it is the last
statement within a block (because it may be the intentional return value). Examples
include:</p>
<pre><code>    int myMethod() {
        new String[3]               // unused
        return -1
    }

    String[] myMethod() {
        new String[3]               // OK (last statement in block)
    }

    def closure = {
        doStuff()
        new Date[3]                 // unused
        doOtherStuff()
    }

    def closure = { new Date[3] }   // OK (last statement in block)
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.unused.UnusedMethodParameterRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Method Parameter]]></name>
    <internalKey><![CDATA[UnusedMethodParameter]]></internalKey>
    <description><![CDATA[<p>This rule finds instances of method (or constructor) parameters not being used. It does not analyze private methods (that is done by
the UnusedPrivateMethodParameter rule) or methods marked @Override.</p>
<ul>
<li>
<p>This rule ignores <code>main()</code> methods. In Groovy, the <code>main()** method can either specify a </code>void<code>return type or else omit a return type (be dynamically typed). The</code>main()** method must have exactly one
parameter. That parameter can either be typed as <code>String[]</code> or else the type can be omitted
(be dynamically typed). And the <code>main()** method must be </code>static`.</p>
</li>
<li>
<p>You can specify an ignore list of parameter names using the 'ignoreRegex' property. By default, a parameter
named 'ignore' or 'ignored'  does not trigger a violation (the regex value is 'ignore|ignored').
You can add your own ignore list using this property.</p>
</li>
<li>
<p>You can specify a class name pattern to ignore using the 'ignoreClassRegex' property. By default classes named
'*.Category' are ignored because they are category classes and have unused parameters in static methods.</p>
</li>
</ul>
<p>Example of violations:</p>
<pre><code>    class MyClass {
        def method(def param) {
            // param is unused
        }
    }
</code></pre>
<p>Example of code that does not cause violations:</p>
<pre><code>    class MyClass {
        @Override
        def otherMethod(def param) {
            // this is OK because it overrides a super class
        }
    }

    class MyCategory {
        // Category classes are ignored by default
        void myMethod1(String string, int value) { }
        void myMethod1(String string, int value, name) { }
    }

    class MainClass1 {
        // main() methods are ignored
        public static void main(String[] args) { }
    }
    class MainClass2 {
        // This is also a valid Groovy main() method
        static main(args) { }
    }
</code></pre>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreClassRegex</key>
      <description><![CDATA[Regex that specifies the names of the classes to skip checking.]]></description>
      <defaultValue>'.*Category'</defaultValue>
    </param>
    <param>
      <key>ignoreRegex</key>
      <description><![CDATA[Regex that specifies the parameter names to ignore.]]></description>
      <defaultValue>'ignore|ignored'</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedObjectRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Object]]></name>
    <internalKey><![CDATA[UnusedObject]]></internalKey>
    <description><![CDATA[<p>Checks for object allocations that are not assigned or used, unless it is the last
statement within a block (because it may be the intentional return value). Examples
include:</p>
<p>By default, this rule does not analyze test files. This rule sets the default value of the
<em>doNotApplyToFilesMatching</em> property to ignore file names ending in 'Spec.groovy, ''Test.groovy', 'Tests.groovy'
or 'TestCase.groovy'. Invoking constructors without using the result is a common pattern in tests.</p>
<pre><code>    int myMethod() {
        new BigDecimal(&quot;23.45&quot;)     // unused
        return -1
    }

    BigDecimal myMethod() {
        new BigDecimal(&quot;23.45&quot;)     // OK (last statement in block)
    }

    def closure = {
        doStuff()
        new Date()                  // unused
        doOtherStuff()
    }

    def closure = { new Date() }    // OK (last statement in block)
</code></pre>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedPrivateFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Private Field]]></name>
    <internalKey><![CDATA[UnusedPrivateField]]></internalKey>
    <description><![CDATA[<p>Checks for private fields that are not referenced within the same class. Note that the <code>private</code>
modifier is not currently &quot;respected&quot; by Groovy code (i.e., Groovy can access <code>private</code>
members within other classes).</p>
<p>By default, fields named <code>serialVersionUID</code>, and fields annotated with <code>groovy.lang.Delegate</code> are ignored.
The rule has a property named <em>ignoreFieldNames</em>, which can be set to ignore other field names as well.
For instance, to also ignore fields named 'fieldx', set the property to the 'fieldx, serialVersionUID'</p>
<p>Known limitations:</p>
<ul>
<li>Does not recognize field access when field name is a GString (e.g. <code>this.&quot;${fieldName}&quot;</code>)</li>
<li>Does not recognize access of private field of another instance (i.e. other than <code>this</code>)</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>allowConstructorOnlyUsages</key>
      <description><![CDATA[Should be set to "false" if violations are to be raised for fields which are used only within constructors.]]></description>
      <defaultValue>true</defaultValue>
    </param>
    <param>
      <key>ignoreFieldNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) field names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
      <defaultValue>serialVersionUID</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedPrivateMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Private Method]]></name>
    <internalKey><![CDATA[UnusedPrivateMethod]]></internalKey>
    <description><![CDATA[<p>Checks for private methods that are not referenced within the same class. Note that the <code>private</code>
modifier is not currently &quot;respected&quot; by Groovy code (i.e., Groovy can access <code>private</code>
members within other classes).</p>
<p>Known limitations:</p>
<ul>
<li>Does not recognize method reference through property access (e.g. <code>getName()</code> accessed as <code>x.name</code>)</li>
<li>Does not recognize method invocations when method name is a GString (e.g. <code>this.&quot;${methodName}&quot;()</code>)</li>
<li>Does not recognize invoking private method of another instance (i.e. other than <code>this</code>)</li>
<li>Does not recognize when a private method is used as @MethodSource</li>
<li>Does not differentiate between multiple private methods with the same name but different parameters (i.e., overloaded)</li>
<li>Does not check for unused constructors</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreMethodsWithAnnotationNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) annotation names that mark private methods that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
      <defaultValue>''</defaultValue>
    </param>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unused.UnusedPrivateMethodParameterRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Private Method Parameter]]></name>
    <internalKey><![CDATA[UnusedPrivateMethodParameter]]></internalKey>
    <description><![CDATA[<p>Checks for parameters to private methods (or constructors) that are not referenced within the method body. Note that the
<code>private</code> modifier is not currently &quot;respected&quot; by Groovy code (i.e., Groovy can access <code>private</code>
members within other classes).</p>
<p>Known limitations:</p>
<ul>
<li>Does not recognize parameter references within an inner class. See
<a href="https://sourceforge.net/tracker/index.php?func=detail&amp;aid=3155974&amp;group_id=250145&amp;atid=1126573">CodeNarc bug #3155974</a>.</li>
<li>Does not recognize parameter references when parameter name is a GString (e.g. <code>println &quot;${parameterName}&quot;</code>)</li>
<li>You can specify an ignore list using the 'ignoreRegex' property. By default, a parameter named 'ignore' or 'ignored'
does not trigger a violation (the regex value is 'ignore|ignored'). You can add your own ignore list using this property.</li>
</ul>
]]></description>
    <tag>bug</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedVariableRule.fixed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Variable]]></name>
    <internalKey><![CDATA[UnusedVariable]]></internalKey>
    <description><![CDATA[<p>Checks for variables that are never referenced. An assignment to the variable is not considered a reference.</p>
<p>The rule has a property named ignoreVariableNames, which can be set to ignore some variable names.
For instance, to ignore fields named 'unused', set the property to 'unused'.</p>
<p>Known limitations:</p>
<ul>
<li>Incorrectly considers a variable referenced if another variable with the same name is referenced
elsewhere (in another scope/block).</li>
</ul>
]]></description>
    <tag>bug</tag>
    <param>
      <key>ignoreVariableNames</key>
      <description><![CDATA[Specifies one or more (comma-separated) variable names that should be ignored (i.e., that should not cause a rule violation). The names may optionally contain wildcards (*,?).]]></description>
    </param>
  </rule>

</rules>
